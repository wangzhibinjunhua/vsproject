/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2001
*
*****************************************************************************/
/*!
 * \file meta.h
 * \mainpage Mobile Equipment Testing Architecture Development Kit
 * \author MediaTek Inc.
 ******************************************
 * \defgroup META_Result META_RESULT
 * META_RESULT is an enumeration type, which is defined as following. If an exported function of META-DLL has returned value, the type of this returned value is always META_RESULT.
 ******************************************
 *
 * \defgroup NoDefYet NoDefYet
 * This section describe the NoDefYet -- should be grouped
 ******************************************
 *
 * \defgroup General General
 * This section describe the General functions
 *
 * \defgroup GeneralStruct Structure of General 
 * \ingroup General
 * GeneralStruct is a subgroup of General
 *
 ******************************************
 *
 * \defgroup InitConn Initialization-Connection
 * This section describe the initialization and connection functions
 *
 * \defgroup InitConnStruct Structure of InitConn 
 * \ingroup InitConn
 * InitConnStruct is a subgroup of InitConn
 *
 ******************************************
 *
 * \defgroup MDLogging Modem Logging
 * This section describe the Modem logging functions
 *
 * \defgroup MDLoggingStruct Structure of MDLogging 
 * \ingroup MDLogging
 * MDLoggingStruct is a subgroup of MDLogging
 *
 ******************************************
 *
 * \defgroup Utility Utility
 * This section describe the utility functions
 *
 * \defgroup UtilityStruct Structure of Utility 
 * \ingroup Utility
 * UtilityStruct is a subgroup of Utility
 *
 ******************************************
 * \defgroup NVRAM NVRAM
 * This section describe the APIs used in NVRAM functions
 *
 * \defgroup NVRAMStruct Structure of NVRAM 
 * \ingroup NVRAM
 * NVRAMStruct is a subgroup of NVRAM
 *
 ******************************************
 *
 * \defgroup fpOnly Feature phone only
 * This section describe the Feature phone only functions
 *
 * \defgroup fpOnlyStruct Structure of fpOnly 
 * \ingroup fpOnly
 * fpOnlyStruct is a subgroup of fpOnly
 *
 ******************************************
 * \defgroup MultiMode Multi-Mode
 * This section describe the functions used in multi-mode calibration
 *
 * \defgroup MultiModeStruct Structure of MultiMode RF functions
 * \ingroup MultiMode
 * MultiModeStruct is a subgroup of MultiMode
 ******************************************
 * \defgroup GSM GSM
 * This section describe the functions used in GSM calibration
 *
 * \defgroup GSMStruct Structure of GSM functions
 * \ingroup GSM
 * GSMStruct is a subgroup of GSM
 ******************************************
 * \defgroup WCDMA WCDMA
 * This section describe the functions used in WCDMA calibration
 *
 * \defgroup WCDMAStruct Structure of WCDMA functions
 * \ingroup WCDMA
 * WCDMAStruct is a subgroup of WCDMA
 ******************************************
 * \defgroup LTE LTE
 * This section describe the functions used in LTE calibration
 *
 * \defgroup LTEStruct Structure of LTE functions
 * \ingroup LTE
 * LTEStruct is a subgroup of LTE
 ******************************************
 * \defgroup TDSCDMA TDSCDMA
 * This section describe the functions used in TDSCDMA calibration
 ******************************************
 * \defgroup C2K C2K
 * This section describe the functions used in C2K calibration
 *
 * \defgroup C2KStruct Structure of C2K functions
 * \ingroup C2K
 * C2KStruct is a subgroup of C2K
 */
/*******************************************************************************
 * Filename:
 * ---------
 * meta.h
 *
 * Project:
 * --------
 *   META
 *
 * Description:
 * ------------
 *   This module contains the definitions for using META_DLL.dll.
 *
 * Author:
 * -------
 *  CH Liang (mtk00419)
 *
 *==============================================================================
 *           HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * $Revision:   1.36  $
 * $Modtime:   Jan 16 2006 17:47:32  $
 * $Log:   //mtkvs01/vmdata/meta_dll/archives/maui/META_DLL/meta.h-arc  $
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/
#ifndef META_DLL_H
#define META_DLL_H

#ifndef __cplusplus
typedef unsigned char bool;
#endif  // #ifndef (__cplusplus)

#include "meta_boot_def.h"


#if defined(__cplusplus)
extern "C" {
#endif // #if defined(__cplusplus)

#if defined(__CHECK_REENTRANCY__)
#define NON_REENTRANT_FUNC __declspec(deprecated("this is not a reentrant function"))
#else
#define NON_REENTRANT_FUNC
#endif // #if !defined(__CHECK_REENTRANCY__)

//--------------------------------------------------------------------------//
//  META General                                                            //
//--------------------------------------------------------------------------//

#define INVALID_HANDLE  -1
#define MAX_BAUDRATE_ITEM_NUM 12

extern unsigned long g_defaultMinTimeout;
extern unsigned long g_defaultDebugTimeout;

// SP META TOOL
#define STATUS_OK_DIRVER          1
#define STATUS_FAIL_DIRVER        0
#define STATUS_OK_DVB             1
#define STATUS_FAIL_DVB           0


// SP META TOOL
#define STATUS_OK_FT              0
#define STATUS_FAIL_FT            1


//-----------------------------------------------------//
//  META General: data structure definition            //
//-----------------------------------------------------//
typedef enum
{
    /**
     * META_DLL received a corrupted frame
     */
    META_CNF_FRAME_ERROR = 0,

    /**
     * META_DLL received a confirm or indication from target,
     * but there is not corresponding call back function
     * installed for this confirm or indication.
     */
    META_CNF_NO_CALLBACK = 1,

    /**
     * META_DLL received a corrupted primitive.
     */
    META_CNF_PRIMITIVE_ERROR = 2,

    /**
     * META_DLL received a confirm or indication from
     * target, but there is no sufficient memory to process.
     */
    META_CNF_NO_MEMORY = 3,

    /**
     * META_DLL retrieved a callback function, however,
     * the user input arguments are invalid.
     */
    META_CNF_CALLBACK_PARAMETER_ERROR = 4,

    /**
     * META_DLL received a confirm with peer msg, however,
     * the peer msg is corrupted.
     */
    META_CNF_PEER_MSG_ERROR = 5,

    /**
     * META_DLL received a confirm and successfully executed
     * the callback function.
     */
    META_CNF_OK = 6,

    /**
     * SP META DLL Received a confirm but the status is not OK
     */
    META_CNF_FT_STATUS_ERROR = 7
}
META_CNF_ERR_CODE;

// The magic value to stop usb enumerate process
#define ENUM_USB_STOP   9876
#define ENUM_ANY_STOP   9876

/** 
 * \ingroup META_Result 
 */
typedef enum
{
    META_SUCCESS = 0,
    META_FAILED = 1,
    META_COMM_FAIL = 2,
    META_NORESPONSE = 3,
    META_EBOOT_FAILED = 4,
    META_BUFFER_LEN = 5,
    META_FILE_BAD = 6,
    META_LID_INVALID = 7,
    META_INTERNAL_DB_ERR = 8,
    META_NO_MEMORY = 9,
    META_INVALID_ARGUMENTS = 10,
    META_TIMEOUT = 11,
    META_BUSY = 12,
    META_INVALID_HANDLE = 13,
    META_FAT_ERROR = 14,
    META_FAT_DISK_FULL = 15,
    META_FAT_ROOT_DIR_FULL = 16,
    META_FAT_INVALID_FILENAME = 17,
    META_FAT_INVALID_FILE_HANDLE = 18,
    META_FAT_FILE_NOT_FOUND = 19,
    META_FAT_DRIVE_NOT_FOUND = 20,
    META_FAT_PATH_NOT_FOUND = 21,
    META_FAT_ACCESS_DENIED = 22,
    META_FAT_TOO_MANY_FILES = 23,
    META_INCORRECT_TARGET_VER = 24,
    META_COM_ERROR = 25,
    META_BROM_CMD_ERROR = 26,
    META_INCORRECT_BBCHIP_TYPE = 27,
    META_BROM_ERROR = 28,
    META_STOP_BOOTUP_PROCEDURE = 29,
    META_CANCEL = 30,
    META_FUNC_NOT_IMPLEMENT_YET = 31,
    META_NOT_SUPPORT = META_FUNC_NOT_IMPLEMENT_YET,
    META_FAT_APP_QUOTA_FULL = 32,
    META_IMEI_CD_ERROR = 33,
    META_RFID_MISMATCH = 34,
    META_NVRAM_DB_IS_NOT_LOADED_YET = 35,
    META_WAIT_FOR_TARGET_READY_TIMEOUT = 36,
    META_ERR_EXCEED_MAX_PEER_BUF_SIZE = 37,
    META_BROM_SECURITY_CHECK_FAIL = 38,
    META_MAUI_DB_INCONSISTENT = 39,
    META_FAT_FILEPATH_TOO_LONG = 40,
    META_FAT_RESTRICTED_FILEPATH = 41,
    META_FAT_DIR_NOT_EXIST = 42,
    META_FAT_DISK_SPACE_IS_NOT_ENOUGH = 43,
    META_TDMB_ERR_BAND_NOT_EXIST = 44,
    META_TDMB_ERR_FREQ_NOT_EXIST = 45,
    META_TDMB_ERR_ENSM_NOT_EXIST = 46,
    META_TDMB_ERR_SERV_NOT_EXIST = 47,
    META_TDMB_ERR_SUB_CHAN_NOT_EXIST = 48,
    META_TDMB_ERR_DEMOD_STATE = 49,
    META_ENUMERATE_USB_FAIL = 50,
    META_STOP_ENUM_USB_PROCEDURE = 51,
    META_MISC_TARGET_LOAD_NEED_TO_BE_PATCHED = 52,
    META_MISC_INI_FILE_SETTINGS_WRONG = 53,
    META_MISC_FAIL_TO_READ_IMEI = 54,
    META_MISC_FAIL_TO_BACKUP_FILE = 55,
    META_MISC_FAIL_TO_WRITE_BACKUP_RESULT = 56,
    META_MISC_FAIL_TO_GET_NVRAM_FOLDER_PATH = 57,
    META_MISC_FAIL_TO_GET_NVRAM_MUST_LIST = 58,
    META_STOP_CURRENT_PROCEDURE = 59,
    META_MISC_CUSTOMIZED_NVRAM_ERROR = 60,
    META_MISC_FOLDER_EMPTY_CHECKING_FAIL = 61,
    META_MISC_TOO_MANY_BACKUP_RESULT_FILE = 62,
    META_MISC_TOO_MANY_RESTORE_RESULT_FILE = 63,
    META_MISC_RESTORE_RESULT_FILE_NOT_EXIST = 64,
    META_MISC_RESTORE_RESULT_FILE_INCOMPLETE = 65,
    META_FAIL_TO_CELAR_ALL_IN_BACUP_FOLDER = 66,
    META_MISC_BACKUP_RESULT_FILE_NOT_EXIST = 67,
    META_MISC_BACKUP_RESULT_FILE_INCOMPLETE = 68,
    META_MISC_IMEI_MISMATCH = 69,
    META_MISC_SML_FILE_VERIFY_FAIL = 70,
    META_MISC_BACKUP_RESULT_NOT_ENOUGH_FOR_NEW_LOAD = 71,
    META_MISC_FAIL_TO_RESTORE_FILE = 72,
    META_MISC_FAIL_TO_WRITE_RESTORE_RESULT = 73,
    META_MISC_USE_WRONG_API_FOR_NEW_LOAD = 74,
    META_MISC_QUERY_TARGET_CAPABILITY_FAIL = 75,
    META_MISC_INI_SETTINGS_ERR_IN_NVRAM_SEC = 76,
    META_MISC_INI_SETTINGS_ERR_IN_TARGET_SEC = 77,
    META_MISC_INI_SETTINGS_ERR_IN_PC_SEC = 78,
    META_MISC_NO_FILES_NEED_TO_BE_UPLOAD = 79,
    META_FAT_ACTION_NOT_SUPPORT = 80,
    META_MISC_EMPTY_UPLOADFILES_AND_IMEI_SEC = 81,
    META_MISC_INI_SETTINGS_ERR_IN_MORE_SEC = 82,
    META_MISC_INI_SETTINGS_ERR_IN_DELETE_SEC = 83,
    META_MISC_CHECK_TARGET_NVRAM_FILES_FAIL = 84,
    META_MISC_FAIL_TO_GET_NVRAM_FOLDER_AMOUNT = 85,
    META_AUDIO_CHECK_WAVE_FILE_FAIL = 86,
    META_MISC_COLLECT_NVRAM_FOLDER_FILES_FAILED = 87,
    META_MISC_COLLECT_NVRAM_FOLDER_FILES_FIRST = 88,
    META_MISC_BACKUP_FILE_NOT_FOUND_IN_NVRAM = 89,
    META_MISC_BACKUP_MORE_FILE_NOT_FOUND_IN_NVRAM = 90,
    META_MISC_LOCAL_FS_UNKNOWN_ERROR = 91,
    META_MISC_RETORE_FILE_NOT_FOUND_IN_BACKUP_RESULT = 92,
    META_MISC_LEGACY_ADC_FILE_NOT_FOUND = 93,
    META_MISC_LEGACY_BARCODE_FILE_NOT_FOUND = 94,
    META_MISC_FILE_SIZE_MISMATCH = 95,
    META_MISC_RESTORE_TARGET_NOT_FOUND_IN_NVRAM = 96,
    META_UTIL_CONVERT_MULTIBYTE_TO_WCHAR_FAILED = 97,
    META_FAT_RECURSIVE_CREATE_FOLDER_FAILED = 98,
    META_FAT_COPY_INVALID_SOURCE_FOLDER = 99,
    META_FAT_COPY_EMPTY_SOURCE_FOLDER = 100,
    META_MISC_MULTIPLE_ENTRY_NOT_SUPPORTED = 101,
    META_MISC_INVALID_FORMAT = 102,
    META_FAT_FILE_LENGTH_ZERO = 103,
    META_MISC_INI_SETTINGS_ERR_IN_PC_FOLDER_SEC = 104,
    META_PC_FILE_NOT_FOUND = 105,
    META_MEMBER_FIELD_TYPE_NOT_FOUND = 106,
    META_MEMBER_FIELD_OFFSET_NOT_FOUND = 107,
    META_NVRAM_GET_KEY_LENGTH_CALLBACK_ERROR = 108,
    META_NVRAM_ALLOCATE_KEY_BUFFER_ERROR = 109,
    META_NVRAM_GET_KEY_BUFFER_CALLBACK_ERROR = 110,
    META_NVRAM_KEY_ENTRY_MISSING = 111,
    META_NVRAM_KEY_ENTRY_ERROR = 112,
    META_NVRAM_KEY_LENGTH_EXCEEDS_INTERNAL_BUFFER = 113,
    META_FAT_SPACE_SIZE_OVERFLOW = 114,
    META_LIB_INCONSISTENT = 115,
    META_INTERNAL_DB_ERROR = 116,
    META_REQUIRED_TOOL_VERSION_CHECK_FAILD = 117,               /**< 117, the current tool version does not fullfil the required tool version */
    META_CROSS_BRANCH_BACKUP_OPEN_FAILED = 118,
    META_CROSS_BRANCH_BACKUP_PARSE_FAILED = 119,
    META_CROSS_BRANCH_BACKUP_FILE_ATT_NOT_MATCH = 120,
    META_NVRAM_VALUE_NOT_LEGAL = 121,
    META_INIT_CONNECTION_STARTED = 122,
    META_QUERY_NO_MODEM_SUPPORT = 123,
    META_MEMBER_FIELD_SIZE_NOT_FOUND = 124,                       /**< 124, the member field size look-up failed */
    META_MDLOGGING_SET_FILTER_COMMAND_ERROR = 125,
    META_RF_RESULT_PENDING = 126, /**< the calibration result is pending, waiting for target to complete */
    META_URF_RESULT_PENDING = 127, /**< the calibration result is pending, waiting for target to complete */
    META_MODE_TRACE_CONFIG_FAILED = 128, /**< setting up META mode trace parameter failed */
    META_NVRAM_DB_GET_ENUM_TYPE_FAIL = 129,
    META_NOT_SUPPORTED_VC_CONFIG = 130, /**< Not supported virtual channel configuration, for the MODEM protocol is TST or DHL */
    META_MODEM_EXCEPTION = 131,
    META_MAUI_DB_NOT_FIND = 132,
    META_CCT_NOT_IMPORT_PROFILE = 133,
    META_CCT_INVALID_SENSOR_ID = 134,
    META_CCT_NOT_IMPLEMENT_YET = META_FUNC_NOT_IMPLEMENT_YET,
    META_CCT_PREVIEW_ALREADY_STARTED = 135,
    META_CCT_PREVIEW_ALREADY_STOPPED = 136,
    META_CCT_ERR_PREVIEW_MUST_DISABLE = 138,
    META_PERMISSION_DENIED = 139,
    META_LOG_ERROR_OPEN_FILE = 140,
    META_MDLOGGER_ERROR_WRITE_FILTER = 141,
    META_SLA_VERIFICATION_FAILED = 142,
    META_SLA_VER_NOT_MATCH = 143,
    META_CMD_NOT_SUPPORTED = 144,
    META_CMD_NOT_ALLOWED = 145,
    META_LAST_RESULT,
} META_RESULT;

typedef enum
{
    META_BAUD2400 = 0, /**< Baud Rate: 2400bps */
    META_BAUD4800 = 1, /**< Baud Rate: 4800bps */
    META_BAUD9600 = 2, /**< Baud Rate: 9600bps */
    META_BAUD14400 = 3, /**< Baud Rate: 14400bps */
    META_BAUD19200 = 4, /**< Baud Rate: 19200bps */
    META_BAUD57600 = 5, /**< Baud Rate: 57600bps */
    META_BAUD115200 = 6, /**< Baud Rate: 115200bps */
    META_BAUD230400 = 7, /**< Baud Rate: 230400bps */
    META_BAUD460800 = 8, /**< Baud Rate: 460800bps */
    META_BAUD921600 = 9, /**< Baud Rate: 921600bps */
    META_BAUD1500000 = 10, /**< Baud Rate: 1500000bps */
    META_BAUD_END = 0xFF
} META_COMM_BAUDRATE;

typedef enum
{
    META_NO_FLOWCTRL = 0,   /**< no flow control */
    META_SW_FLOWCTRL = 1,   /**< enable S/W flow control (0x11: 0x77, 0x01; 0x13: 0x77, 0x02; 0x77: 0x77, 0x03) */
    META_ADV_SW_FLOWCTRL = 2,  /**< enable ADV S/W flow control (0x11: 0x77, 0xEE; 0x13: 0x77, 0xEC; 0x77: 0x77, 0x88) */
    META_FLOWCTRL_END
} META_FLOWCTRL;

typedef struct
{
    char    BB_CHIP[64];    /**< BaseBand chip version */
    char    ECO_VER[4];     /**< ECO version */
    char    DSP_FW[64];     /**< DSP firmware version */
    char    DSP_PATCH[64];  /**< DSP patch version */
    char    SW_VER[64];     /**< S/W version */
    char    HW_VER[64];     /**< H/W board version */
    char    MELODY_VER[64]; /**< Melody version */
    char    SW_FLAVOR[64];  /**< Build flavor information*/
    char    SW_TIME[64];    /**< SP META needs S/W time*/
    unsigned char status;   /** SP META needs status*/
} VerInfo_Cnf;

/**
* SP META Tool needs to use
*/
typedef struct {
    char    BB_CHIP[64];       // BaseBand chip version
    char    ECO_VER[4];        // ECO version
    char    SW_TIME[64];
    char    DSP_FW[64];        // DSP firmware version
    char    DSP_PATCH[64];     // DSP patch version
    char    SW_VER[64];        // S/W version
    char    HW_VER[64];        // H/W board version
    char    MELODY_VER[64];    // Melody version
    char    BUILD_DISP_ID[64]; //build version
    unsigned char status;
} VerInfo_V2_Cnf;

/**
* SP META Tool needs to query chip information
*/
typedef struct {
    char    code_func[64];
    char    code_proj[64];
    char    code_date[64];
    char    code_fab[64];
    unsigned char status;
} ChipInfo_Cnf;

typedef struct
{
    unsigned short   sla_config;   /**< the SLA config of target \n 1: enabled\n 0:disabled\n */
    unsigned short   sla_verified; /**< the SLA verification status of target \n 1: verified\n 0:not verified\n */
} SlaStatus_Cnf;

typedef struct
{
    unsigned short      com_port_list[255];
    unsigned short      com_port_num;
    unsigned int        ms_connect_timeout; /**< [META] META enumerate port timeout value */
} META_Enumerate_USB_Req;

typedef struct
{
    int                 com_port;
    META_COMM_BAUDRATE  baudrate[12];       /**< [META] META stage baudrate polling array, it must end with META_BAUD_END. */
    META_FLOWCTRL       flowctrl;           /**< [META] META stage uart flow control type. */
    FBOOT_META_ARG      boot_meta_arg;      /**< [BootROM] please refer to brom.h */
    unsigned int        ms_connect_timeout; /**< [META] META stage sync timeout value (after BootROM negotiation pass) */
} META_Connect_Req;

typedef enum
{
    GENERAL_MODE = 0,
    CATCHER_RELAY_MODE = 1,
    LOGGING_TOOL_RELAY_MODE = CATCHER_RELAY_MODE,
    FILE_DUMP_MODE = 2,
    TRACE_MODE_NUM
} META_TRACE_MODE;

typedef  struct
{
    bool            enable;
    char*           dump_file_path;
} META_COMM_TRACE_PARA_T;

typedef  struct
{
    bool            enable;
    const wchar_t*  dump_file_path;
} META_COMM_TRACE_PARA_TW;

typedef  struct
{
    META_TRACE_MODE        mode;
    int                    modem_index;
    char*                  dump_file_path;
} META_MODE_TRACE_PARA_T;

typedef  struct
{
    META_TRACE_MODE        mode;
    int                    modem_index;
    const wchar_t*         dump_file_path;
} META_MODE_TRACE_PARA_TW;

typedef struct
{
    int                    com_port;
    META_COMM_BAUDRATE     baudrate[12];       /**< [META] META stage baudrate polling array, it must end with META_BAUD_END. */
    META_FLOWCTRL          flowctrl;           /**< [META] META stage uart flow control type. */
    FBOOT_META_ARG         boot_meta_arg;      /**< [BootROM] please refer to brom.h */
    unsigned int           ms_connect_timeout; /**< [META] META stage sync timeout value (after BootROM negotiation pass) */
    unsigned int           usb_enable: 1;      /**< [META] Connect target with UART or USB, 0: UART 1: USB others:reserved */
    unsigned int           InMetaMode: 1;      /**< [META] Decide that need boot META or not 0:need boot META 1:already in meta mode */
    unsigned int           escape: 1;          /**< [META] Force to connect target with escaping */
    unsigned int           close_com_port: 1;  /**< [META] Choose to close com port or handle */
    META_MODE_TRACE_PARA_T trace_para;         /**< [META] META mode trace parameters */
    unsigned int           protocol: 4;        /**< [META] Only for MultiMode connection API. When InMetaMode==true, connect target with different protocol 0||1:TST 2:DHL */
    unsigned int           channel_type: 4;    /**< [META] Only for MultiMode connection API. Connect target with different channel type, 0||1: native channel, 2: tunneling, 3: tunneling with check sum ignored */
    META_COMM_TRACE_PARA_T commTrace;          /**< [META] META dump com port raw data */
} META_Connect_Ex_Req;

typedef struct
{
    unsigned int m_u4TargetMainVersion;
    unsigned int m_u4TargetMinorVersion;
    unsigned int m_u4TargetBuildNum;
} META_VER_REQUIRED_BY_TARGET;

typedef struct
{
    META_COMM_BAUDRATE  final_baudrate;                 /**< [META] Detected META stage baudrate. */
    unsigned int        meta_ver_required_by_target;    /**< [META] Target required META_DLL version.  ==> always return 0 */
    FBOOT_RESULT        boot_result;                    /**< [BootROM] boot-up result. */
    FBOOT_STATUS        boot_meta_ret;                  /**< [BROM_DLL] The return code of Boot_META function. */
    META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         /**< [META] Target required META_DLL version. */
} META_Connect_Report;

typedef struct _METACONN_RESULT
{
    META_Connect_Report *output_para;
    int *pHandle;
} METACONN_RESULT;

typedef struct
{
    int                 com_port;
    FBOOT_META_ARG       boot_meta_arg;      /**< [BootROM] please refer to brom.h */
    unsigned int        ms_connect_timeout; /**< [META] META stage sync timeout value (after BootROM negotiation pass) */
} META_ConnectByUSB_Req;

typedef struct
{
    unsigned int        meta_ver_required_by_target;    /**< [META] Target required META_DLL version.  ==> always return 0 */
    FBOOT_RESULT         boot_result;                    /**< [BootROM] boot-up result. */
    FBOOT_STATUS         boot_meta_ret;                  /**< [BROM_DLL] The return code of Boot_META function. */
    META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         /**< [META] Target required META_DLL version. */
} META_ConnectByUSB_Report;

typedef struct
{
    int                 com_port;
    META_COMM_BAUDRATE  baudrate[11];       /**< [META] META stage baudrate polling array, it must end with META_BAUD_END. */
    META_FLOWCTRL       flowctrl;           /**< [META] META stage uart flow control type. */
    unsigned int        ms_connect_timeout; /**< [META] META stage sync timeout value (after BootROM negotiation pass) */
} META_ConnectInMETA_Req;

typedef struct
{
    int                 com_port;
    META_COMM_BAUDRATE  baudrate[11];       /**< [META] META stage baudrate polling array, it must end with META_BAUD_END. */
    META_FLOWCTRL       flowctrl;           /**< [META] META stage uart flow control type. */
    unsigned int        ms_connect_timeout; /**< [META] META stage sync timeout value (after BootROM negotiation pass) */
    bool                escape;             /**< [META] Force to connect target with escaping */
} META_ConnectInMETA_Ex_Req;

typedef struct
{
    META_COMM_BAUDRATE            final_baudrate;                   /**< [META] Detected META stage baudrate. */
    unsigned int                  meta_ver_required_by_target;  /**< [META] Target required META_DLL version.  ==> always return 0 */
    META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         /**< [META] Target required META_DLL version. */
} META_ConnectInMETA_Report;

// sp meta struct
typedef struct {
    int                 com_port;
    META_COMM_BAUDRATE  baudrate[11];        // [META] META stage baudrate polling array, it must end with META_BAUD_END. 
    META_FLOWCTRL          flowctrl;            // [META] META stage uart flow control type. 
    unsigned int        ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass) 
}WM_META_ConnectInMETA_Req;


typedef struct {
    META_COMM_BAUDRATE  final_baudrate;                    // [META] Detected META stage baudrate. 
    unsigned int        meta_ver_required_by_target;    // [META] Target required META_DLL version. 
}WM_META_ConnectInMETA_Report;

//-----------------------------------------------------//
//  META General: callback function definition         //
//-----------------------------------------------------//
typedef void (__stdcall* META_Error_CallBack)(const META_CNF_ERR_CODE  mr);
typedef void (__stdcall* META_SysTrace_CallBack)(const char* sys_trace, void* arg);
typedef void (__stdcall* META_GET_VERSION_INFO_CNF)(const VerInfo_Cnf*  cnf, const short token, void* usrData);

// SP META Tool needs to query version and chip information
typedef void (__stdcall *META_GET_VERSION_INFO_V2_CNF)(const VerInfo_V2_Cnf  *cnf_v2, const short token, void *usrData);
typedef void (__stdcall *META_GET_CHIP_INFO_CNF)(const ChipInfo_Cnf  *cnf, const short token, void *usrData);
typedef void (__stdcall *SP_META_SysTrace_CallBack)(const char *sys_trace);

//-----------------------------------------------------//
//  META for CTI                                       //
//-----------------------------------------------------//
typedef enum
{
    CTI_OK = 0,
    CTI_MISSING_HEADER = 1,
    CTI_CORRUPTED_FAME = 2,
    CTI_EXCEED_LEN = 3,
    CTI_END
} CTI_RET_ENUM;
typedef void (__stdcall* META_CTI_CallBack)(CTI_RET_ENUM  ret, const int size, const unsigned char* data, void* param);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_CTI_SendPacketCmd(const unsigned char* pPayLoadBuffer, int nPayloadLength);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_CTI_SendPacketCmd_r(const int meta_handle, const unsigned char* pPayLoadBuffer, int nPayloadLength);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_CTI_SetPacketCallback(META_CTI_CallBack  pCBFunc, void* param);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_CTI_SetPacketCallback_r(const int meta_handle, META_CTI_CallBack  pCBFunc, void* param);

//-----------------------------------------------------//
//  Switch TST message format                          //
//-----------------------------------------------------//
typedef enum
{
    META_TST_MSG_2G = 0,
    META_TST_MSG_3G = 1,
    META_TST_MSG_FORMAT_END
} META_TST_MSG_FORMAT;
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_SetTstMsgFormat_r
  */
META_RESULT  __stdcall META_SetTstMsgFormat(META_TST_MSG_FORMAT  msg_fmt);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_SetTstMsgFormat_r(const int meta_handle, META_TST_MSG_FORMAT  msg_fmt);

//-----------------------------------------------------//
//  META Debug: exported debug function definition     //
//-----------------------------------------------------//
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn(void);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn_With_FilePath(const char* filepath);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn_With_FilePathW(const wchar_t* filepath);
/**
 * \ingroup General
 * \details Turn on the META DLL debug log in c:\META_DLL_HANDLE%d_COM%d.log.
 * \details For example, the meta_handle is 0 and COM port number is 10. Then the log file will be c:\META_DLL_HANDLE0_COM10.log
 * \param [in] meta_handle context handle to specific DUT
 */
META_RESULT  __stdcall META_DebugOn_ex(const int meta_handle);
/**
 * \ingroup General
 * \details Turn on META DLL debug log in c:\META_DLL_HANDLE%d_COM%d.log
 * for example the meta_handle is 0 and COM port number is 10 then the log file will be c:\META_DLL_HANDLE0_COM10.log
 * \param [in] meta_handle context handle to specific DUT
 * \param [out] path the buffer to store the log location for upper layer.
 * \note there is no boundary check for this function. The underlying buffer of [path] is 260 bytes.
 */
META_RESULT  __stdcall META_DebugOn_ex2(const int meta_handle, char* path);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn_ex2W(const int meta_handle, wchar_t* path);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn_With_Handle_FilePath(const int meta_handle, const char* filename);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn_With_Handle_FilePathW(const int meta_handle, const wchar_t* filename);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn_With_Handle_FilePath_Cumulative(const int meta_handle, const char* filename);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOn_With_Handle_FilePath_CumulativeW(const int meta_handle, const wchar_t* filename);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOff(void);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugOff_With_Handle(const int meta_handle);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugClear(void);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_DebugClear_With_Handle(const int meta_handle);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_Print(const int meta_handle, const char* sourceName, const char* stringLog);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_SetIpComPortMap(int comPort, const char* ipAddress,int ipPort);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_ClearIpComPortMap(void);
// SP META Tool for debug
META_RESULT  __stdcall SP_META_DebugOn(void);
META_RESULT  __stdcall SP_META_DebugOn_ex(const int meta_handle);
META_RESULT  __stdcall SP_META_DebugOff(void);
META_RESULT  __stdcall SP_META_DebugClear(void);
META_RESULT  __stdcall SP_META_DebugOnThePath(const char * path);
META_RESULT  __stdcall SP_META_DebugOnThePathW(const wchar_t * path);
META_RESULT  __stdcall SP_META_DebugOnThePath_ex(const int meta_handle,const char * path);
META_RESULT  __stdcall SP_META_DebugOffThePath(void);


//-----------------------------------------------------//
//  META UnitTest                                      //
//-----------------------------------------------------//

typedef struct
{
    unsigned int    m_TestCaseID;
    const char*     m_pDescription;
} META_UT_TestCaseID_T;


typedef void (__stdcall* META_UnitTest_Print_CallBack)(const char* str, void* arg);
typedef struct
{
    META_UnitTest_Print_CallBack   m_Function;
    void*     m_pArg;
} META_UT_Print_CallBack_T;
/**
  * \ingroup NoDefYet
  */
void __stdcall META_QueryTestCase(META_UT_TestCaseID_T**  ppTestCase, unsigned int*  pTestCaseCount);
/**
  * \ingroup NoDefYet
  */
bool __stdcall META_UnitTest(const unsigned int*  p_TestCaseID_Array, unsigned int  TestCaseCount, META_UT_Print_CallBack_T PrintCallBack);

//-----------------------------------------------------//
//  META General: exported function definition         //
//-----------------------------------------------------//

#define     FT_MT_UNKNOWN  0
#define     FT_MT6305  1
#define     FT_MT6318  2
#define     FT_MT6326  3

typedef struct
{
    unsigned char   id;
} PMIC_ID;
typedef struct
{
    unsigned int    pcl;
} RF_GetITC_PCL;
// General
/**
  * \ingroup General
  */
void  __stdcall META_GetDLLVer(unsigned int* major_ver, unsigned int* minor_ver, unsigned int* build_num, unsigned int* patch_num);
/**
  * \ingroup General
  */
void  __stdcall META_GetDLLInfo(const char** pp_version, const char** pp_release_type, const char** pp_build_date, const char** pp_load_path);
/**
  * \ingroup General
  */
void  __stdcall META_GetDLLInfoW(const char** pp_version, const char** pp_release_type, const char** pp_build_date, const wchar_t** pp_load_path);
/**
  * \ingroup General
  */
void  __stdcall META_GetDLLInfo_r(const int meta_handle, const char** pp_version, const char** pp_release_type, const char** pp_build_date, const wchar_t** pp_load_path);
/**
  * \ingroup General
  * \sa non-reentrant version of META_Cancel_r
  */
void  __stdcall META_Cancel(const short token);
/**
  * \ingroup General
  */
void  __stdcall META_Cancel_r(const int meta_handle, const short token);
/**
  * \ingroup General
 * \sa non-reentrant version of META_CancelAllBlockingCall_r
  */
void  __stdcall META_CancelAllBlockingCall(void);
/**
  * \ingroup General
  */
void  __stdcall META_CancelAllBlockingCall_r(const int meta_handle);
/**
  * \ingroup General
  */
void  __stdcall META_ForceCancelAllBlockingCall(void);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryIfFunctionSupportedByTarget_r
  */
META_RESULT  __stdcall META_QueryIfFunctionSupportedByTarget(unsigned int ms_timeout, const char* query_func_name);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfFunctionSupportedByTarget_r(const int meta_handle, unsigned int ms_timeout, const char* query_func_name);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfTargetSupportISP(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfTargetSupportISP_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryIfTargetSupportAcoustic16level_r
  */
META_RESULT  __stdcall META_QueryIfTargetSupportAcoustic16level(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfTargetSupportAcoustic16level_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryIfTargetSupportAudioParam45Tap_r
  */
META_RESULT  __stdcall META_QueryIfTargetSupportAudioParam45Tap(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfTargetSupportAudioParam45Tap_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryIfTargetIsLowCostSingleBankFlash_r
  */
META_RESULT  __stdcall META_QueryIfTargetIsLowCostSingleBankFlash(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfTargetIsLowCostSingleBankFlash_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryPMICID_r
  */
META_RESULT  __stdcall META_QueryPMICID(unsigned int ms_timeout, PMIC_ID*  cnf);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryPMICID_r(const int meta_handle, unsigned int ms_timeout, PMIC_ID*  cnf);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_BTPowerOn(unsigned int ms_timeout);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_BTPowerOn_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryIfTargetSupportWifiALC_r
  */
META_RESULT  __stdcall META_QueryIfTargetSupportWifiALC(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfTargetSupportWifiALC_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryITC_PCL_r
  */
META_RESULT  __stdcall META_QueryITC_PCL(unsigned int ms_timeout, RF_GetITC_PCL*  cnf);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryITC_PCL_r(const int meta_handle, unsigned int ms_timeout, RF_GetITC_PCL*  cnf);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryIfTargetSupportDRC_r
  */
META_RESULT  __stdcall META_QueryIfTargetSupportDRC(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfTargetSupportDRC_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryIfBTPowerOn_r
  */
META_RESULT  __stdcall META_QueryIfBTPowerOn(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryIfBTPowerOn_r(const int meta_handle, unsigned int ms_timeout);

// SP META Tool API start
void  __stdcall SP_META_GetDLLVer(unsigned int *major_ver, unsigned int *minor_ver, unsigned int *build_num, unsigned int *patch_num);
void  __stdcall SP_META_GetDLLInfo(const char **pp_version, const char **pp_release_type, const char **pp_build_date, const char **pp_load_path);
void  __stdcall SP_META_Cancel(const short token);
void  __stdcall SP_META_Cancel_r(const int meta_handle, const short token);
void  __stdcall SP_META_CancelAllBlockingCall(void);
void  __stdcall SP_META_CancelAllBlockingCall_r(const int meta_handle);

META_RESULT  __stdcall SP_META_QueryIfFunctionSupportedByTarget(unsigned int ms_timeout, const char *query_func_name);
META_RESULT  __stdcall SP_META_QueryIfFunctionSupportedByTarget_r(const int meta_handle, unsigned int ms_timeout, const char *query_func_name);


//META_RESULT  __stdcall SP_META_QuerySpeakerCalibrationSupport(unsigned int ms_timeout);
//META_RESULT  __stdcall SP_META_QuerySpeakerCalibrationSupport_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall SP_META_QueryIfTargetIsLowCostSingleBankFlash(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetIsLowCostSingleBankFlash_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryPMICID(unsigned int  ms_timeout, PMIC_ID  *cnf);
META_RESULT  __stdcall SP_META_QueryPMICID_r(const int meta_handle, unsigned int  ms_timeout, PMIC_ID  *cnf);
META_RESULT  __stdcall SP_META_QueryITC_PCL(unsigned int  ms_timeout, RF_GetITC_PCL  *cnf);
META_RESULT  __stdcall SP_META_QueryITC_PCL_r(const int meta_handle, unsigned int  ms_timeout, RF_GetITC_PCL  *cnf);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportDRC(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportDRC_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfBTPowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfBTPowerOn_r(const int meta_handle, unsigned int ms_timeout);
// SP META Tool API end

//-----------------------------------------------------//
//  UTILITY--ENABLE WATCHDOG                           //
//-----------------------------------------------------//
#define GPIO_DEV_LED_MAINLCD 0
//#define GPIO_DEV_LED_SUBLCD 1

typedef struct
{
    unsigned int    ms_timeout_interval;
} FtWatchDog;

typedef struct
{
    unsigned char       led_light_level;
} FtLEDLevel;

typedef struct
{
    unsigned char       lcd_type;
    unsigned char       lcd_light_level;
} FtLCDLevel;

typedef struct
{
    unsigned char       onoff;
} FtVibratorOnOff;

typedef struct
{
    unsigned char       m_rtc_sec;    /**< seconds after the minute   - [0,59]  */
    unsigned char       m_rtc_min;    /**< minutes after the hour     - [0,59]  */
    unsigned char       m_rtc_hour;   /**< hours after the midnight   - [0,23]  */
    unsigned char       m_rtc_day;    /**< day of the month           - [1,31]  */
    unsigned char       m_rtc_mon;    /**< months                     - [1,12] */
    unsigned char       m_rtc_wday;   /**< days in a week             - [1,7] */
    unsigned char       m_rtc_year;
} T_Rtc;

typedef enum
{
    DATA_LIBRARY_MODE_OPENDB = 0,
    DATA_LIBRARY_MODE_EDB = 1
} DATA_LIBRARY_MODE;
/**
  * \ingroup General
  * \sa non-reentrant version of META_EnableWatchDogTimer_r
  */
META_RESULT  __stdcall META_EnableWatchDogTimer(unsigned int ms_timeout, FtWatchDog* req);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_EnableWatchDogTimer_r(const int meta_handle, unsigned int ms_timeout, FtWatchDog* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_SetLEDLightLevel_r
  */
META_RESULT  __stdcall META_SetLEDLightLevel(unsigned int ms_timeout, FtLEDLevel* req);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_SetLEDLightLevel_r(const int meta_handle, unsigned int ms_timeout, FtLEDLevel* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_SetVibratorOnOff_r
  */
META_RESULT  __stdcall META_SetVibratorOnOff(unsigned int ms_timeout, FtVibratorOnOff* req);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_SetVibratorOnOff_r(const int meta_handle, unsigned int ms_timeout, FtVibratorOnOff* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_QueryLocalTime_r
  */
META_RESULT  __stdcall META_QueryLocalTime(unsigned int ms_timeout, T_Rtc*  cnf);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_QueryLocalTime_r(const int meta_handle, unsigned int ms_timeout, T_Rtc*  cnf);
/**
  * \ingroup General
  * \sa non-reentrant version of META_SetMainSubLCDLightLevel_r
  */
META_RESULT  __stdcall META_SetMainSubLCDLightLevel(unsigned int ms_timeout, FtLCDLevel* req);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_SetMainSubLCDLightLevel_r(const int meta_handle, unsigned int ms_timeout, FtLCDLevel* req);


// timer-related APIs
/**
  * \ingroup General
  * \sa non-reentrant version of META_StartTimer_r
  */
META_RESULT  __stdcall META_StartTimer(void);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_StartTimer_r(const int meta_handle);
/**
  * \ingroup General
  * \sa non-reentrant version of META_StopTimer_r
  */
META_RESULT  __stdcall META_StopTimer(void);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_StopTimer_r(const int meta_handle);
/**
  * \ingroup General
  * \sa non-reentrant version of META_GetProcessTime_r
  */
META_RESULT __stdcall META_GetProcessTime(unsigned int*  pProcessTime, unsigned short* pNumAPIs);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_GetProcessTime_r(const int meta_handle, unsigned int* pProcessTime, unsigned short* pNumAPIs);
/**
  * \ingroup General
  */
const char* __stdcall META_GetErrorString(META_RESULT  ErrCode);
/**
  * \ingroup InitConn
  */
const char* __stdcall META_BaudrateEnumToName(META_COMM_BAUDRATE  baudrate);

// Initialization
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_GetAvailableHandle(int* p_meta_handle);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_GetAvailableHandle_Ex(int* p_meta_handle, DATA_LIBRARY_MODE mode);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_Init_r
  */
META_RESULT  __stdcall META_Init(const META_Error_CallBack  cb);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_Init_r(const int meta_handle, const META_Error_CallBack  cb);
/**
  * \ingroup General
  * \sa non-reentrant version of META_EnableLocalFrameCompression_r
  */
META_RESULT  __stdcall META_EnableLocalFrameCompression(bool enabled);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_EnableLocalFrameCompression_r(const int meta_handle, bool enabled);

/* [Dual Talk] */
typedef struct
{
    unsigned int number_of_md: 8;
    unsigned int active_md_idx: 8;
    unsigned int multi_talk: 1; /**< 0: no multi-talk, 1: multi-talk */
    unsigned int multi_frame_type: 1; /**< 0: all MD use the same frame type, 1: each MD is assigned a frame type */
    unsigned int number_of_mdSwImg: 4; /**< world phone (multi-MDtype) */
    unsigned int active_mdtype_idx: 4;
    unsigned int multi_mdtype: 1; /**< 0: no multi-MDtype, 1: multi-MDtype */
    unsigned int multi_md_capability_support: 1;
    unsigned int reserved: 4;
} META_MD_Query_Result_T;
typedef enum
{
    md_type_invalid = 0,
    modem_2g = 1,
    modem_3g = 2,
    modem_wg = 3,
    modem_tg = 4,
    modem_lwg = 5,
    modem_ltg = 6,
    modem_ltng = 7,
    modem_ultg = 8,
    modem_ulwg = 9,
    modem_ulwtg = 10,
    modem_ulwcg = 11,
    modem_ulwctg = 12,
    modem_ulttg = 13,
    modem_ulfwg = 14,
    modem_ulfwcg = 15,
    num_modem_type  //number of md type need to -1, bescause "md_type_invalid = 0"
} modem_type_t;
/**
  * \ingroup InitConn
  */
const char* __stdcall META_GetModemTypeString(modem_type_t mdType);
//for switch mdtype callback arguments
typedef struct
{
    unsigned int md_idx: 8;
    unsigned int mdtype_idx: 8;
    unsigned int reserved: 16;
} META_MDTYPE_Switch_Param_T;
/**
 * \brief the callback function for querying the multi-talk capability on the target system
 * \return the query result
 */
typedef META_MD_Query_Result_T (__stdcall* META_MD_Query_CallBack)(void* arg);
/**
 * \brief the callback function for MODEM switching
 * \return 0: success, otherwise, fail
 */
typedef int (__stdcall* META_MD_Switch_CallBack)(void* arg);
/**
 * \brief the callback function for MODEM TYPEswitching
 * \return 0: success, otherwise, fail
 */
typedef int (__stdcall* META_MDTYPE_Switch_CallBack)(META_MDTYPE_Switch_Param_T mdtype_switch_param, void* arg);
/**
 * \ingroup InitConn
 * \sa non-reentrant version of META_Init_Ex_r
 */
META_RESULT  __stdcall META_Init_Ex(const META_Error_CallBack err_cb,
                                    const META_MD_Query_CallBack md_query_cb,
                                    void* md_query_arg,
                                    const META_MD_Switch_CallBack md_switch_cb,
                                    void* md_switch_arg
                                   );
/**
 * \ingroup InitConn
 * \details META_Init extended version for multiple-talk project
 * \param meta_handle the operating session ID (meta_handle)
 * \param err_cb the error handler for META DLL
 * \param md_query_cb the switching implementation of upper layer (OPTIONAL)
 *        in different product segment, the multiple-talk product could be all-in-one chip or
 *        external MODEM solution
 *        external MODEM solution needs extra switching procedure
 *        all-in-one solution needs no extra switching procedure
 * \param md_query_arg the argument to be passed to md_query_cb (OPTIONAL)
 * \param md_switch_cb the switching implementation of upper layer (OPTIONAL)
 * \param md_switch_arg the argument to be passed to md_switch_arg (OPTIONAL)
 * \return On success: META_SUCCESS
 *         On fail: META_FAILED or META_INVALID_ARGUMENTS
 */
META_RESULT  __stdcall META_Init_Ex_r(const int meta_handle,
                                      const META_Error_CallBack err_cb,
                                      const META_MD_Query_CallBack md_query_cb,
                                      void* md_query_arg,
                                      const META_MD_Switch_CallBack md_switch_cb,
                                      void* md_switch_arg
                                     );
/**
 * \ingroup InitConn
 * \sa non-reentrant version of META_Init_Ex_2_r
 */
META_RESULT  __stdcall META_Init_Ex_2(const META_Error_CallBack err_cb,
                                      const META_MD_Query_CallBack md_query_cb,
                                      void* md_query_arg,
                                      const META_MD_Switch_CallBack md_switch_cb,
                                      void* md_switch_arg,
                                      const META_MDTYPE_Switch_CallBack mdtype_switch_cb,
                                      void* mdtype_switch_arg
                                     );
/**
 * \ingroup InitConn
 * \details META_Init extended version for multiple-modemtype project [world phone]
 * \param meta_handle the operating session ID (meta_handle)
 * \param err_cb the error handler for META DLL
 * \param md_query_cb the switching implementation of upper layer (OPTIONAL)
 *        in different product segment, the multiple-talk product could be all-in-one chip or
 *        Multiple MODEM Typesolution
 *        Multiple MODEM solution needs extra switching procedure
 *        all-in-one solution needs no extra switching procedure
 * \param md_query_arg the argument to be passed to md_query_cb (OPTIONAL)
 * \param md_switch_cb the switching implementation of upper layer (OPTIONAL)
 * \param md_switch_arg the argument to be passed to md_switch_arg (OPTIONAL)
 * \param mdtype_switch_cb the mdtype switching implementation of upper layer (OPTIONAL)
 * \param mdtype_switch_arg the argument to be passed to mdtype_switch_arg (OPTIONAL)
 * \retval META_SUCCESS successful
 * \retval META_FAILED failed
 * \retval META_INVALID_ARGUMENTS invalid arguments
 */
META_RESULT  __stdcall META_Init_Ex_2_r(const int meta_handle,
                                        const META_Error_CallBack err_cb,
                                        const META_MD_Query_CallBack md_query_cb,
                                        void* md_query_arg,
                                        const META_MD_Switch_CallBack md_switch_cb,
                                        void* md_switch_arg,
                                        const META_MDTYPE_Switch_CallBack mdtype_switch_cb,
                                        void* mdtype_switch_arg
                                       );
/**
 * \ingroup InitConn
 * \sa non-reentrant version of META_SwitchCurrentModem_r
 */
META_RESULT  __stdcall META_SwitchCurrentModem(const unsigned int ms_timeout, const unsigned int md_index);
/**
 * \ingroup InitConn
 * \details switch the current operating MODEM to specified md_index
 * \param meta_handle the operating session ID (meta_handle)
 * \param ms_timeout time out (ms)
 * \param md_index the specified md_index to be switched to
 * \retval META_SUCCESS Successful
 * \retval META_MAUI_DB_INCONSISTENT if the DB does not match with the switched MODEM
 * \retval META_FAILED failed to switch to specifed md_index
 * \retval META_FUNC_NOT_IMPLEMENT_YET for single-talk project
 * \retval META_INVALID_ARGUMENTS for not supported md_index
 *         for example, md_index 0 and 1 are valid on dual-talk projects
 */
META_RESULT  __stdcall META_SwitchCurrentModem_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int md_index);
/**
 * \ingroup InitConn
 * \sa non-reentrant version of META_QueryCurrentModem_r
 */
META_RESULT  __stdcall META_QueryCurrentModem(unsigned int* md_index);
/**
 * \ingroup InitConn
 * \brief Query the current operating MODEM of the specified meta_handle
 * \param meta_handle the operating session ID (meta_handle)
 * \param [out] md_index the query result
 * \return On success: META_SUCCESS
 */
META_RESULT  __stdcall META_QueryCurrentModem_r(const int meta_handle, unsigned int* md_index);
/**
 * \ingroup InitConn
 * \sa non-reentrant version of META_SwitchCurrentModem_r
 *        this API switch the operating MODEM of meta_handle 0
 */
META_RESULT  __stdcall META_SwitchCurrentModemEx(const unsigned int ms_timeout, const unsigned int md_index, const unsigned int protocol, const unsigned int channel_type, const META_MODE_TRACE_PARA_T* trace_para, const META_COMM_TRACE_PARA_T* commTrace_para);
/**
 * \ingroup InitConn
 * \details switch the current operating MODEM to specified md_index and protocol and channel type
 * \param meta_handle the operating session ID (meta_handle)
 * \param ms_timeout time out (ms)
 * \param md_index the specified md_index to be switched to
 * \param protocol the protocol type of the specified meta handle
 * \param channel_type the channel type of the specified meta handle
 * \param trace_para the META mode trace parameter of the specified meta handle
 * \retval META_SUCCESS Successful
 * \retval META_MAUI_DB_INCONSISTENT if the DB does not match with the switched MODEM
 * \retval META_FAILED failed to switch to specifed md_index
 * \retval META_FUNC_NOT_IMPLEMENT_YET for single-talk project
 * \retval META_INVALID_ARGUMENTS for not supported md_index
 *         for example, md_index 0 and 1 are valid on dual-talk projects
 */
META_RESULT  __stdcall META_SwitchCurrentModemEx_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int md_index, const unsigned int protocol, const unsigned int channel_type, const META_MODE_TRACE_PARA_T* trace_para, const META_COMM_TRACE_PARA_T* commTrace_para);
/**
 * \ingroup InitConn
 * \sa non-reentrant version of META_QueryCurrentModem_r
 */
META_RESULT  __stdcall META_QueryCurrentModemEx(unsigned int* md_index, unsigned int* protocol, unsigned int* channel_type);
/**
 * \ingroup InitConn
 * \details Query the current operating MODEM of the specified meta_handle
 * \param meta_handle the operating session ID (meta_handle)
 * \param [out] md_index the query result
 * \param [out] protocol the protocol type used for specified meta handle
 * \param [out] channel_type the channel type used for specified meta handle
 * \return On success: META_SUCCESS
 */
META_RESULT  __stdcall META_QueryCurrentModemEx_r(const int meta_handle, unsigned int* md_index, unsigned int* protocol, unsigned int* channel_type);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_SetSysTraceCallback_r
  */
META_RESULT  __stdcall META_SetSysTraceCallback(const META_SysTrace_CallBack  sys_cb, void* arg);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_SetSysTraceCallback_r(const int meta_handle, const META_SysTrace_CallBack  sys_cb, void* arg);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_Deinit_r
  */
void  __stdcall META_Deinit(void);
/**
  * \ingroup InitConn
  */
void  __stdcall META_Deinit_r(int* p_meta_handle);
/**
 * \ingroup InitConn
 * \sa non-reentrant version of META_SetInfo4SwitchModemType_r
 */
META_RESULT  __stdcall META_SetInfo4SwitchModemType(const unsigned int ms_timeout, const unsigned int md_index, const unsigned int mdtype_index);
/**
 * \ingroup InitConn
 * \details Set the current operating MODEM type of the specified meta_handle
 * \param meta_handle the operating session ID (meta_handle)
 * \param ms_timeout time out (ms)
 * \param md_index index of MODEM handle
 * \param mdtype_index index of MODEM software type handle
 * \return On success: META_SUCCESS
 */
META_RESULT  __stdcall META_SetInfo4SwitchModemType_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int md_index, const unsigned int mdtype_index);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_GetInfo4SwitchModemType_r(const int meta_handle, const unsigned int ms_timeout, unsigned int* md_index, unsigned int* mdtype_index);
// connect with target
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectWithTarget_r
  */
META_RESULT  __stdcall META_ConnectWithTarget(const META_Connect_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithTarget_r(const int meta_handle, const META_Connect_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectWithTargetEx_r
  */
META_RESULT  __stdcall META_ConnectWithTargetEx(const META_Connect_Ex_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithTargetEx_r(const int meta_handle, const META_Connect_Ex_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectWithMultiModeTarget_r
  */
META_RESULT  __stdcall META_ConnectWithMultiModeTarget(const META_Connect_Ex_Req*  req, const unsigned int requestLengthlength, int* p_bootstop, META_Connect_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithMultiModeTarget_r(const int meta_handle, const META_Connect_Ex_Req*  req, const unsigned int requestLengthlength, int* p_bootstop, META_Connect_Report*  p_report);
// dsiconnect and shutdown target
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_DisconnectWithTarget_r
  */
META_RESULT  __stdcall META_DisconnectWithTarget(void);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_DisconnectWithTarget_r(const int meta_handle);

// connect with target when target already in meta mode
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectInMetaMode_r
  */
META_RESULT  __stdcall META_ConnectInMetaMode(const META_ConnectInMETA_Req*  req, int* p_bootstop, META_ConnectInMETA_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectInMetaMode_r(const int meta_handle, const META_ConnectInMETA_Req* req, int* p_bootstop, META_ConnectInMETA_Report* p_report);
// connect with target when target already in meta mode for SP connection via UART with escaping
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectInMetaMode_Ex_r
  */
META_RESULT  __stdcall META_ConnectInMetaMode_Ex(const META_ConnectInMETA_Ex_Req* req, int* p_bootstop, META_ConnectInMETA_Report* p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectInMetaMode_Ex_r(const int meta_handle, const META_ConnectInMETA_Ex_Req* req, int* p_bootstop, META_ConnectInMETA_Report* p_report);
// dsiconnect without shutdown target
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_DisconnectInMetaMode_r
  */
META_RESULT  __stdcall META_DisconnectInMetaMode(void);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_DisconnectInMetaMode_r(const int meta_handle);

// USB-related connect
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectInMetaModeByUSB_r
  */
META_RESULT  __stdcall META_ConnectInMetaModeByUSB(const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectInMetaModeByUSB_r(const int meta_handle, const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);

/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectWithTargetByUSB_r
  */
META_RESULT  __stdcall META_ConnectWithTargetByUSB(const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithTargetByUSB_r(const int meta_handle, const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);

/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ConnectWithTargetByUSBEx_r
  */
META_RESULT  __stdcall META_ConnectWithTargetByUSBEx(const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report, bool close_com_port);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithTargetByUSBEx_r(const int meta_handle, const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report, bool close_com_port);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_QueryConnectionMedia_r
  */
META_RESULT  __stdcall META_QueryConnectionMedia(unsigned int* indicator, int* comport);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_QueryConnectionMedia_r(const int meta_handle, unsigned int* indicator, int* comport);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_QueryConnectionInfo_r
  */
META_RESULT  __stdcall META_QueryConnectionInfo(unsigned int* protocol, unsigned int* channel_type);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_QueryConnectionInfo_r(const int meta_handle, unsigned int* protocol, unsigned int* channel_type);

/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_GetDynamicUSBComPort_r
  */
META_RESULT  __stdcall META_GetDynamicUSBComPort(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_GetDynamicUSBComPort_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_GetDynamicUSBComPortWithPrefix_r
  */
META_RESULT  __stdcall META_GetDynamicUSBComPortWithPrefix(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, const char* prefix);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_GetDynamicUSBComPortWithPrefix_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, const char* prefix);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_GetDynamicUSBComPortEx_r
  */
META_RESULT  __stdcall META_GetDynamicUSBComPortEx(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_GetDynamicUSBComPortEx_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length);
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_GetDynamicUSBComPortExWithFilter_r
  */
META_RESULT  __stdcall META_GetDynamicUSBComPortExWithFilter(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length, char* valid_usb_info);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_GetDynamicUSBComPortExWithFilter_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length, char* valid_usb_info);

/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectCOMChannelWithMultiTarget_r(const int meta_handle, const META_Connect_Ex_Req* req);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_DisconnectCOMChannelWithMultiTarget_r(const int meta_handle);
/**
 * \ingroup General
 * \sa non-reentrant version of META_GetTargetVerInfo_r
 * \details Get target S/W, H/W and Melody version with fixed timeout value in a asynchronous way
 */
META_RESULT  __stdcall META_GetTargetVerInfo(const META_GET_VERSION_INFO_CNF  cb, short* token, void* usrData);
/**
 * \ingroup General
 * \details Get the target S/W, H/W and Melody version with fixed timeout value in asynchronous way
 * \param[in] meta_handle context handle to specific DUT
 * \param[in] cb callback function for the get target version result
 * \param[out] token the given token value of the transaction
 * \param[out] usrData the parameter for the callback function
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT  __stdcall META_GetTargetVerInfo_r(const int meta_handle, const META_GET_VERSION_INFO_CNF  cb, short* token, void* usrData);
/**
 * \ingroup General
 * \sa non-reentrant version of META_GetTargetVerInfo2_r
 */
META_RESULT  __stdcall META_GetTargetVerInfo2(const int ms_timeout, const META_GET_VERSION_INFO_CNF cb, short* token, void* usrData);
/**
 * \ingroup General
 * \brief Get target S/W, H/W and Melody version with user defined timeout value in asynchronous way
 * \param meta_handle meta handle
 * \param ms_timeout timeout value in ms
 * \param cb callback function for the get target version result
 * \param[out] token the given token value of the transaction
 * \param usrData the parameter for the callback function
 */
META_RESULT  __stdcall META_GetTargetVerInfo2_r(const int meta_handle, const int ms_timeout, const META_GET_VERSION_INFO_CNF cb, short* token, void* usrData);
/**
 * \ingroup General
 * \sa non-reentrant version of META_GetTargetVerInfoEx_r
 */
META_RESULT  __stdcall META_GetTargetVerInfoEx(VerInfo_Cnf* cnf);
/**
 * \ingroup General
 * \details Get target S/W, H/W and Melody version with fixed timeout value in synchronous way
 * \param meta_handle meta handle
 * \param cnf the result of get target version
 */
META_RESULT  __stdcall META_GetTargetVerInfoEx_r(const int meta_handle, VerInfo_Cnf* cnf);
/**
 * \ingroup General
 * \sa non-reentrant version of META_GetTargetVerInfoEx2_r
 */
META_RESULT  __stdcall META_GetTargetVerInfoEx2(const int ms_timeout, VerInfo_Cnf* cnf);
/**
 * \ingroup General
 * \brief Get target S/W, H/W and Melody version with user defined timeout value in synchronous way
 * \param meta_handle meta handle
 * \param ms_timeout timeout value in ms
 * \param cnf the result of get target version
 */
META_RESULT  __stdcall META_GetTargetVerInfoEx2_r(const int meta_handle, const int ms_timeout, VerInfo_Cnf* cnf);

/**
 * \ingroup General
 */

 /**
 * \ingroup General
 * \details For getting target SLA status
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] cnf SlaStatus_Cnf
 *
 * \retval META_SUCCESS The operation completed successfully.
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired.
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT  __stdcall META_GetSlaStatus_r(const int meta_handle, const unsigned int  ms_timeout, SlaStatus_Cnf* cnf);

/**
 * \ingroup General
* \details For triggering SLA verification flow
* \param [in] meta_handle context handle to specific DUT
* \param [in] ms_timeout API transaction timeout value in milliseconds
*
* \retval META_SUCCESS The operation completed successfully.
* \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired.
* \retval META_FAILED The requested operation was unsuccessful.
* \retval META_SLA_VERIFICATION_FAILED SLA verification was unsuccessful.
 */
META_RESULT  __stdcall META_VerifySla_r(const int meta_handle, const unsigned int  ms_timeout);

// Shutdown target
/**
  * \ingroup InitConn
  * \sa non-reentrant version of META_ShutDownTarget_r
  */
META_RESULT  __stdcall META_ShutDownTarget(void);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ShutDownTarget_r(const int meta_handle);
// Get target send bytes
/**
  * \ingroup General
  * \sa non-reentrant version of META_GetReadBytes_r
  */
META_RESULT  __stdcall META_GetReadBytes(unsigned long* read_bytes);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_GetReadBytes_r(const int meta_handle, unsigned long* read_bytes);
/**
  * \ingroup General
  * \sa non-reentrant version of META_GetReadBytesEx_r
  */
META_RESULT  __stdcall META_GetReadBytesEx(unsigned long long* read_bytes);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_GetReadBytesEx_r(const int meta_handle, unsigned long long* read_bytes);

// ***** Expired Functions -- BEGIN ***** //
// these functions are expired, we encourage you to use META_ConnectWithTarget and META_DisconnectWithTarget
/**
 * \ingroup NoDefYet
 * \sa non-reentrant version of META_COMM_Set_Baudrate_r
 * \deprecated This API is deprecated.
 */
META_RESULT  __stdcall META_COMM_Set_Baudrate(const META_COMM_BAUDRATE  baudrate);
/**
 * \ingroup NoDefYet
 * \details set baud rate for current meta handle
 * \deprecated This API is deprecated.
 * \param meta_handle meta handle
 * \param baudrate baud rate
 */
META_RESULT  __stdcall META_COMM_Set_Baudrate_r(const int meta_handle, const META_COMM_BAUDRATE  baudrate);
/**
 * \ingroup NoDefYet
 * \sa non-reentrant version of META_COMM_Start_r
  *\sa non-reentrant version of META_ConnectWithTarget_r
 * \deprecated This API is deprecated.
 */
META_RESULT  __stdcall META_COMM_Start(const int comm_port, const META_FLOWCTRL  flowctrl);
/**
 * \ingroup NoDefYet
 * \details start the underlaying connection handle
 * \deprecated This API is deprecated.
 * \param meta_handle meta handle
 * \param comm_port the number of com port
 * \param flowctrl flow control mode
 * \sa non-reentrant version of META_ConnectWithTarget_r
 */
META_RESULT  __stdcall META_COMM_Start_r(const int meta_handle, const int comm_port, const META_FLOWCTRL  flowctrl);
/**
 * \ingroup NoDefYet
 * \sa non-reentrant version of META_COMM_Stop_r
 * \deprecated This API is deprecated.
 * \sa non-reentrant version of META_DisconnectWithTarget_r
 */
META_RESULT  __stdcall META_COMM_Stop(void);
/**
 * \ingroup NoDefYet
 * \details stop the underlaying connection handle
 * \deprecated This API is deprecated.
 * \param meta_handle meta handle
 * \sa non-reentrant version of META_DisconnectWithTarget_r
 */
META_RESULT  __stdcall META_COMM_Stop_r(const int meta_handle);
/**
 * \ingroup NoDefYet
 * \sa non-reentrant version of META_WaitForTargetReady_r
 * \deprecated This API is deprecated.
 * \sa non-reentrant version of META_ConnectWithTarget_r
 */
META_RESULT  __stdcall META_WaitForTargetReady(unsigned int ms_waiting_time, unsigned int request_count);
/**
 * \ingroup NoDefYet
 * \details start the underlaying connection handle
 * \deprecated This API is deprecated.
 * \param meta_handle meta handle
 * \param ms_waiting_time time out in ms
 * \param request_count number of request to be sent
 * \sa non-reentrant version of META_ConnectWithTarget_r
 */
META_RESULT  __stdcall META_WaitForTargetReady_r(const int meta_handle, unsigned int ms_waiting_time, unsigned int request_count);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_GetTargetRequiredMetaVer(unsigned int* p_meta_ver_required_by_target);
/**
  * \ingroup NoDefYet
  */
META_RESULT  __stdcall META_GetTargetRequiredMetaVer_r(const int meta_handle, unsigned int* p_meta_ver_required_by_target);
// ***** Expired Functions -- END ***** //
/**
  * \ingroup General
  */
const char* __stdcall META_GetBBChipNameByType(unsigned int type);
/**
  * \ingroup General
  */
const char* __stdcall META_GetBBChipNameByType_r(const int meta_handle, unsigned int type);
/**
  * \ingroup General
  */
unsigned int __stdcall META_GetBBChipTypeByString(const char* bb_str);
/**
  * \ingroup General
  */
unsigned int __stdcall META_GetBBChipTypeByString_r(const int meta_handle, const char* bb_str);

/**
 * \ingroup WCDMAStruct
 * \brief
 * Using cost down PA, is needed to add compensation for dealing with transient state unstable situation
 * when switching mode, e.g., Low mode to High mode.
 */
typedef struct
{
    short pa_drift_comp_w_table[6][2];
    short pa_drift_comp_h_table[6][4];
} U_sPADRIFTSETTING;
typedef struct
{
    U_sPADRIFTSETTING txPaDriftCompData;
} ul1Cal_txPaDriftCompData_T;

typedef struct
{
    short   vga_comp_by_temperature[8][2];  ///<[0]:slope in dB (unit: 1/32 dB), [1]:offset in txdac
} U_sRACHCOMP;
typedef struct
{
    U_sRACHCOMP power_dac[3];///<0:PA high mode, 1:PA mid mode, 2:PA low mode (use 0&1 if only 2 mode)
} U_sPARACHTMCOMPDATA;
typedef struct
{
    U_sPARACHTMCOMPDATA txPrachTmCompData;
} ul1cal_txPrachTmCompData_T;

typedef struct
{
    unsigned short ul_uarfcn;       /**< UL uarfcn range:????Read from NVRAM?? (9612 ~ 9888) */
    unsigned short dl_uarfcn;
    unsigned short dl_psc;      /**< 0~511. */
    unsigned short signature;   /**< 0~15, for single signature decision. */
    unsigned char  pa_mode; /**< 0: high 1: middle 2: low */
    char           init_power;  /**< Assume cpich_rscp=0, ul_interference=0. */
    unsigned char  power_step;     /**< Preamble power ramping step. 1 ~ 8dB */
    unsigned char  max_retrans; /**< 1~64 */
    unsigned char  asc;            /**< 0~7 */
} URfTestCmdTxAccess;
typedef struct
{
    unsigned short  ul_freq;
    short   psc;        /**< 0~511. */
    unsigned int    sc_code;    /**< Scrambling code #. 0 ~ 16777215 */
    unsigned char   power_ctrl_mode;
    unsigned char   pa_mode;
    unsigned short  idx;
    unsigned short  afc_dac;
    unsigned char   dpcch_pwr;
    unsigned char   dpdch_pwr;
    unsigned char   rf_band;
    unsigned char   vm1;
    unsigned char   vm2;
    unsigned short  dc2dc_dac;
    unsigned short  vbias_dac;
    bool            pwr_det;
    unsigned short  apc_dac;
} URfTestCmdTxDPCh;
typedef struct
{
    unsigned short  dl_freq;
    short   psc;    /**< 0~511. */
    unsigned char   ssc;    /**< 0~15. */
    short   ovsf;   /**< 0~sf-1. */
    unsigned short  afc_dac;
    bool    hwAGC;
    unsigned char   mode;       /**< 0: mode0, 1: mode1. */
    short   gain;       /**< mode0. */
    unsigned char   LNAmode;     /**< mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /**< mode1. */
} URfTestCmdRxDPCh;
#define MAX_FREQ_LIST 36
typedef struct
{
    unsigned char   num_freq;
    unsigned short  dl_freq[ MAX_FREQ_LIST ];
    unsigned char   temperature;
    bool    hwAGC;
    unsigned char   mode;       /**< 0: mode0, 1: mode1. */
    short   gain;       /**< mode0. */
    unsigned char   LNAmode;    /**< mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /**< mode1. */
} URfTestCmdRSSI;
typedef struct
{
    unsigned char   num_freq;
    unsigned short  dl_freq[ MAX_FREQ_LIST ];
    unsigned char   temperature;
    bool    hwAGC;
    unsigned char   mode;       /**< 0: mode0, 1: mode1. */
    short   gain;       /**< mode0. */
    unsigned char   LNAmode;    /**< mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /**< mode1. */
    unsigned char   lpm_mode;   /* 0: normal LNA gain mode, 1: low poer LNA gain mode*/
} URfTestCmdLPMRSSI;
typedef struct
{
    unsigned char   num_freq;
    unsigned short  dl_freq[ MAX_FREQ_LIST ];
    unsigned char   temperature;
    bool    hwAGC;
    unsigned char   mode;       /**< 0: mode0, 1: mode1. */
    short   gain;       /**< mode0. */
    unsigned char   LNAmode;    /**< mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /**< mode1. */
} URfTestCmdRxGainSweep;
typedef struct
{
    unsigned char   num_freq;
    unsigned short  dl_freq[ MAX_FREQ_LIST ];
    unsigned char   temperature;
    bool    hwAGC;
    unsigned char   mode;       /**< 0: mode0, 1: mode1. */
    unsigned char   lpm_mode;   /* 0: normal LNA gain mode, 1: low poer LNA gain mode*/
    short           rx_gain;
    unsigned char   rx_LNAmode;
    unsigned short  rx_pga;
    short           rxd_gain;
    unsigned char   rxd_LNAmode;
    unsigned short  rxd_pga;
    unsigned char   antenna_path;
    bool is_cal;
} URfTestCmdELNARSSI;
typedef struct
{
    bool            pscan_before_cell_search;   /**< True if UL1TST needs power scan before cell search/RSCP. */
    unsigned short  dl_freq;    /**< Specific dl_freq to do cell search. Valid if pscan_before_cell_search=F. */
    unsigned char   sample_num_per_cell;
    bool            read_sfn;   /**< True if we need to do SFN measurement for the found cell. */
    bool            hwAGC;
    unsigned char   mode;       /**< 0: mode0, 1: mode1. */
    short           gain;       /**< mode0. */
    unsigned char   LNAmode;    /**< mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /**< mode1. */
} URfTestCmdRSCP;
typedef struct
{
    short           dl_freq;    /**< Specific dl_freq to do cell search. Valid if pscan_before_cell_search=F. */
    short           afc_dac;
    bool            hwAGC;
    unsigned char   mode;       /**< 0: mode0, 1: mode1. */
    short           gain;       /**< mode0. */
    unsigned char   LNAmode;    /**< mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /**< mode1. */
} URfTestCmdAFC;
typedef struct
{
    char            m_cRfBand;    ///< only 0 ~ 5
    unsigned short  m_u2Idx;
    unsigned char   m_ucPaMode;
    unsigned char    m_ucVm1;
    unsigned char    m_ucVm2;
    unsigned short   m_u2DC2DC_Dac;
    unsigned short   m_u2Vbias_Dac;
    unsigned short   m_u2ApcDac;
} UL1D_RF_TX_PA_APC_REQ_T;

typedef struct
{
    unsigned char  pseudo_hscch[5];
    unsigned char  pseudo_hdsch[5];
    unsigned short beta_hs_p[15];
    unsigned short beta_hs_q[15];
} UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSDPA;

typedef struct
{
    unsigned char  edch_enable[5];
    unsigned char  is_new_tx[5];
    unsigned char  etfci[5];
    unsigned char  beta_ed_num[5];
    unsigned short  beta_ed0_sf[5];
    unsigned short  beta_ed1_sf[5];
    unsigned short  beta_ed2_sf[5];
    unsigned short  beta_ed3_sf[5];
    unsigned short  beta_ec[5];
    unsigned short  beta_ed_x_beta_c_0[5];
    unsigned short  beta_ed_x_beta_c_1[5];
    unsigned short  beta_ed_x_beta_c_2[5];
    unsigned short  beta_ed_x_beta_c_3[5];
    unsigned char  delta_harq[5];
} UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSUPA;

typedef struct
{
    unsigned int   normcon;
    short          net_maxpow;
    short          net_minpow;
    UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSDPA frame_info_r5r6_hsdpa;
    UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSUPA frame_info_r5r6_hsupa;
} UL1D_RF_HWTPC_FRAME_INFO_R5R6;

typedef struct
{
    unsigned char tpc_step;
    unsigned char itp;
    unsigned char rpp;
    unsigned char fmt_idx;
    unsigned char dl_frame_type;
    unsigned short slot_mask;
    char   tpc_cmd[15];
    unsigned char  beta_c;
    unsigned char  beta_d;
    UL1D_RF_HWTPC_FRAME_INFO_R5R6 r5r6_parameters;
} UL1D_RF_HWTPC_FRAME_INFO;

typedef struct
{
    unsigned short  h_dpch_offset;
    unsigned char   h_cqi_cycle;
    unsigned char   h_cqi_rep_factor;
    unsigned char   h_delta_cqi;
    unsigned char   h_delta_ack;
    unsigned char   h_delta_nack;
    unsigned char   h_acknack_repe_factor;
    unsigned char   h_harq_pre_mode;
} UL1D_RF_HWTPC_INFO_R5R6_HSDPA;

typedef struct
{
    unsigned char   e_tti;
    unsigned char   e_ul_dpch_num;
    unsigned char   e_beta_ec_idx;
    unsigned char   e_ref_etfci_num;
    unsigned char   e_etfci_table_idx;
    unsigned char   e_pl_non_max;
    unsigned char   e_ref_etfci[8];
    unsigned char   e_ref_etfci_po[8];
} UL1D_RF_HWTPC_INFO_R5R6_HSUPA;

typedef struct
{
    short         max_pow;
    short         min_pow;
    unsigned char hsdpa;
    unsigned char hsupa;
    UL1D_RF_HWTPC_INFO_R5R6_HSDPA hwtpc_info_r5r6_hsdpa;
    UL1D_RF_HWTPC_INFO_R5R6_HSUPA hwtpc_info_r5r6_hsupa;

} UL1D_RF_HWTPC_INFO_R5R6_EXTRA;

typedef struct
{
    unsigned char pc_algo;
    unsigned char tpc_used_frame;  ///< at most 8 so far
    short  p_ini;
    UL1D_RF_HWTPC_INFO_R5R6_EXTRA hw_tpc_r5r6_extra;
    UL1D_RF_HWTPC_FRAME_INFO frame_info[9];
} UL1D_RF_HWTPC_CONFIG_REQ_T;
typedef struct
{
    unsigned char rf_band;
} UL1D_RF_GET_PWR_THR_REQ_T;
typedef struct
{
    unsigned int bsi_data;
} UL1D_RF_SET_BSI_DATA_REQ_T;
typedef struct
{
    unsigned int bsi_addr;
} UL1D_RF_GET_BSI_DATA_REQ_T;
#define FT_MAX_FHC_FREQ_COUNT 40
#define FT_MAX_FHC_PWR_COUNT 40
#define FT_MAX_CAL_BAND     10
typedef struct
{
    bool              no_loop_ctrl;
    unsigned short    afc_dac;
    bool              pwr_det;///<0 off/manual mode, 1 on/auto mode
    unsigned char     power_ctrl_mode;///<1: HW->O3, 2: SW->59D, Smarti
    unsigned char     vm1[FT_MAX_CAL_BAND][3];      ///<PA param
    unsigned char     vm2[FT_MAX_CAL_BAND][3];      ///<PA param
    unsigned short    dc2dc_dac[FT_MAX_CAL_BAND][3];///<PA param
    unsigned short    vbias_dac[FT_MAX_CAL_BAND][3];///<PA param
    bool              init_tx_onoff;             ///<0:off, 1:on
    bool              ready_tx_onoff;            ///<0:off, 1:on
    unsigned char     init_pa_mode;
    unsigned char     ready_pa_mode;
    unsigned short    init_pa_gain;
    unsigned short    ready_pa_gain;
    unsigned short    init_vga_dac_tpc_idx;
    unsigned short    ready_vga_dac_tpc_idx;
    unsigned char     temperature;
    bool              hwAGC;       ///<0:SW gain mode, 1:HW AGC. AGC must on for RSSI measure. HW limit
    short             gain_init;     /* for HW mode */
    bool              init_condition; ///<0: max_pwr, 1:min_pwr
    unsigned char     step_duration;  ///<in slot
    unsigned char     ready_duration; ///<in slot
    unsigned char     retune_duration; ///<in slot
    unsigned char     gain_stable_time; ///<in slot
    unsigned short    max_vga_dac;
    unsigned short    min_vga_dac;
    unsigned short    jump_vga_dac;
    unsigned char     freq_count;
    unsigned char     pwr_count;
    unsigned char     freq_start_idx;
    unsigned char     pwr_start_idx;
    unsigned char     odd_record;  /*for Anritsu8820, only odd step (1,3,5...start from 1) is for measurement.  */
    unsigned char     pa_gain_start_idx; ///< for O3 TPC
    unsigned char     pd_gain_start_idx; ///< for O3 TPC
    unsigned char     dl_band[FT_MAX_FHC_FREQ_COUNT]; ///<1:band1, 2:band2, 3:band3, 5:band5
    unsigned char     ul_band[FT_MAX_FHC_FREQ_COUNT]; ///<1:band1, 2:band2, 3:band3, 5:band5
    unsigned short    dl_freq[FT_MAX_FHC_FREQ_COUNT]; ///<in uarfcn
    unsigned short    ul_freq[FT_MAX_FHC_FREQ_COUNT]; ///<in uarfcn
    unsigned char     pa_mode[FT_MAX_FHC_PWR_COUNT];
    unsigned short    vga_dac_tpc_idx[FT_MAX_FHC_PWR_COUNT];///<power_ctrl_mode=HW, tpc_idx. Vice versa.
    unsigned short    pa_gain[FT_MAX_FHC_PWR_COUNT]; ///< for O3 TPC
    unsigned char     pd_gain[FT_MAX_FHC_FREQ_COUNT]; ///< [FT_MAX_MQC_FREQ_COUNT]; // for O3 TPC
} UL1D_RF_FHC_REQ_T;
typedef struct
{
    bool              no_loop_ctrl;
    unsigned short    afc_dac;
    bool              pwr_det;///<0 off/manual mode, 1 on/auto mode
    unsigned char     power_ctrl_mode;///<1: HW->O3, 2: SW->59D, Smarti
    unsigned char     vm1[FT_MAX_CAL_BAND][3];      ///<PA param
    unsigned char     vm2[FT_MAX_CAL_BAND][3];      ///<PA param
    unsigned short    dc2dc_dac[FT_MAX_CAL_BAND][3];///<PA param
    unsigned short    vbias_dac[FT_MAX_CAL_BAND][3];///<PA param
    bool              init_tx_onoff;             ///<0:off, 1:on
    bool              ready_tx_onoff;            ///<0:off, 1:on
    unsigned char     init_pa_mode;
    unsigned char     ready_pa_mode;
    unsigned short    init_pa_gain;
    unsigned short    ready_pa_gain;
    unsigned short    init_vga_dac_tpc_idx;
    unsigned short    ready_vga_dac_tpc_idx;
    unsigned char     temperature;
    bool              hwAGC;       ///<0:SW gain mode, 1:HW AGC. AGC must on for RSSI measure. HW limit
    short             gain_init;     /* for HW mode */
    bool              init_condition; ///<0: max_pwr, 1:min_pwr
    unsigned char     step_duration;  ///<in slot
    unsigned char     ready_duration; ///<in slot
    unsigned char     retune_duration; ///<in slot
    unsigned char     gain_stable_time; ///<in slot
    unsigned short    max_vga_dac;
    unsigned short    min_vga_dac;
    unsigned short    jump_vga_dac;
    unsigned char     freq_count;
    unsigned char     pwr_count;
    unsigned char     freq_start_idx;
    unsigned char     pwr_start_idx;
    unsigned char     odd_record;  /*for Anritsu8820, only odd step (1,3,5...start from 1) is for measurement.  */
    unsigned char     pa_gain_start_idx; ///< for O3 TPC
    unsigned char     pd_gain_start_idx; ///< for O3 TPC
    unsigned char     dl_band[FT_MAX_FHC_FREQ_COUNT]; ///<1:band1, 2:band2, 3:band3, 5:band5
    unsigned char     ul_band[FT_MAX_FHC_FREQ_COUNT]; ///<1:band1, 2:band2, 3:band3, 5:band5
    unsigned short    dl_freq[FT_MAX_FHC_FREQ_COUNT]; ///<in uarfcn
    unsigned short    ul_freq[FT_MAX_FHC_FREQ_COUNT]; ///<in uarfcn
    unsigned char     pa_mode[FT_MAX_FHC_PWR_COUNT];
    unsigned short    vga_dac_tpc_idx[FT_MAX_FHC_PWR_COUNT];///<power_ctrl_mode=HW, tpc_idx. Vice versa.
    unsigned short    pa_gain[FT_MAX_FHC_PWR_COUNT]; ///< for O3 TPC
    unsigned char     pd_gain[FT_MAX_FHC_FREQ_COUNT]; ///< [FT_MAX_MQC_FREQ_COUNT]; // for O3 TPC
    unsigned char     pa_section[FT_MAX_FHC_PWR_COUNT];
    unsigned short    lna_gain[FT_MAX_FHC_FREQ_COUNT];  /**< 80 path loss 3 lna mode fixed gain */
} UL1D_RF_FHC_EX_REQ_T;
typedef struct
{
    bool              no_loop_ctrl;
    unsigned short    afc_dac;
    bool              pwr_det;///<0 off/manual mode, 1 on/auto mode
    unsigned char     power_ctrl_mode;///<1: HW->O3, 2: SW->59D, Smarti
    unsigned char     vm1[FT_MAX_CAL_BAND][3];      ///<PA param
    unsigned char     vm2[FT_MAX_CAL_BAND][3];      ///<PA param
    unsigned short    dc2dc_dac[FT_MAX_CAL_BAND][3];///<PA param
    unsigned short    vbias_dac[FT_MAX_CAL_BAND][3];///<PA param
    unsigned char     temperature;
    bool              hwAGC;       ///<0:SW gain mode, 1:HW AGC. AGC must on for RSSI measure. HW limit
    unsigned char     step_duration;  ///<in slot
    unsigned char     freq_count;
    unsigned char     pwr_count;
    unsigned char     freq_start_idx;
    unsigned char     pwr_start_idx;
    unsigned char     pa_gain_start_idx; ///< for O3 TPC
    unsigned char     pd_gain_start_idx; ///< for O3 TPC
    unsigned char     lna_gain_start_idx;
    unsigned char     dl_band[FT_MAX_FHC_FREQ_COUNT]; ///<1:band1, 2:band2, 3:band3, 5:band5
    unsigned char     ul_band[FT_MAX_FHC_FREQ_COUNT]; ///<1:band1, 2:band2, 3:band3, 5:band5
    unsigned short    dl_freq[FT_MAX_FHC_FREQ_COUNT]; ///<in uarfcn
    unsigned short    ul_freq[FT_MAX_FHC_FREQ_COUNT]; ///<in uarfcn
    unsigned char     pd_gain[FT_MAX_FHC_FREQ_COUNT];
    unsigned char     pa_mode[FT_MAX_FHC_PWR_COUNT];
    unsigned short    vga_dac_tpc_idx[FT_MAX_FHC_PWR_COUNT];///<power_ctrl_mode=HW, tpc_idx. Vice versa.
    unsigned short    pa_gain[FT_MAX_FHC_PWR_COUNT]; ///< for O3 TPC
    unsigned char     pa_section[FT_MAX_FHC_PWR_COUNT];
    unsigned short    rx_lna_gain[FT_MAX_FHC_FREQ_COUNT]; // WCDMA ELNA
    unsigned short    rxd_lna_gain[FT_MAX_FHC_FREQ_COUNT]; // WCDMA ELNA
    unsigned char     fix_pga_gain[FT_MAX_FHC_FREQ_COUNT]; // WCDMA ELNA
    unsigned char     is_lpm[FT_MAX_FHC_FREQ_COUNT]; // WCDMA ELNA
} UL1D_RF_FHC_ELNA_REQ_T;
#define FT_MAX_FHC_RSSI_COUNT 400
typedef struct
{
    bool             ok;
    unsigned char    freq_count;
    unsigned char    pwr_count;
    unsigned char    freq_start_idx;
    unsigned char    pwr_start_idx;
    short            rssi[FT_MAX_FHC_RSSI_COUNT];
    short            pwr_det_value[FT_MAX_FHC_FREQ_COUNT];
} UL1D_RF_FHC_CNF_T;
typedef struct
{
    bool             ok;
    unsigned char    freq_count;
    unsigned char    pwr_count;
    unsigned char    freq_start_idx;
    unsigned char    pwr_start_idx;
    unsigned char    rx_lna_mode[FT_MAX_FHC_RSSI_COUNT];
    short            rssi[FT_MAX_FHC_RSSI_COUNT];
    short            pwr_det_value[FT_MAX_FHC_FREQ_COUNT][3];
} UL1D_RF_FHC_EX_CNF_T;

typedef struct
{
    bool             ok;
    unsigned char    freq_count;
    unsigned char    pwr_count;
    unsigned char    freq_start_idx;
    unsigned char    pwr_start_idx;
    unsigned char    rx_lna_mode[FT_MAX_FHC_RSSI_COUNT];
    short            rssi[FT_MAX_FHC_RSSI_COUNT];
    short            pwr_det_value[FT_MAX_FHC_FREQ_COUNT][3];
    short            Gbb_Offset[FT_MAX_FHC_RSSI_COUNT];   /**< TX Gbb power compensation */
    unsigned char    rxd_lna_mode[FT_MAX_FHC_RSSI_COUNT]; /**< Rx diversity path lna mode */
    short            rxd_rssi[FT_MAX_FHC_RSSI_COUNT];     /**< Rx diversity path RSSI */
} UL1D_RF_FHC_EX2_CNF_T;

typedef struct
{
    unsigned short m_u2TxPclIndex;
} UL1D_RF_GET_PWR_DET_REPORT_REQ_T;
typedef struct
{
    unsigned short m_u2PwrDetResult;
} UL1D_RF_GET_PWR_DET_REPORT_CNF_T;
typedef struct
{
    unsigned char m_u1PwrCtrlMode;
} UL1D_RF_SET_PWR_CTRL_MODE_REQ_T;
/**
 * \ingroup WCDMAStruct
 * This structure is used for non-Signal factory Final Test
 */
typedef struct
{
  /** afc dac valid flag\n
   *  TRUE  :\n
   *  FALSE :
   */
    bool              b_afc_dac_valid;
  /** afc dac value
   */
    unsigned short    u2_afc_dac;
  /** loopback type (enumeration):\n
   *  0:no loopback\n
   *  1:loopback type 1\n
   *  2:loopback type 2
   */
    unsigned char     u1_loopbackType;///<0: no loopback, 1: loopback type 1, 2: loopback type 2
  /** frame shift value, default 0
   */
    unsigned char     u1_frame_shift;///<default=0, depends on Test Machine
  /** RMC type (enumeration):\n
   *  1:12.2K\n
   *  2:64K\n
   *  3:144K\n
   *  4:384K
   */
    unsigned char     u1_rmc_type;///<1: 12.2k, 2: 64k, 3: 144k, 4: 384k
  /** instrument ctfc setting\n
   *  8960  :0,1,2,3\n
   *  CMU200:0,2,1,3
   */
    unsigned char     u1_ctfc[4];///<8960=0,1,2,3; cmu200=0,2,1,3
  /** Instrument bit pattern setting (enumeration):\n
   *  0:single ended ber disable\n
   *  1:all one\n
   *  2:all zero
   */
    unsigned char     u1_bit_pattern;///<0: single ended ber disable, 1: all one, 2: all zero
  /** DL frequency
   * \sa UARFCN
   */
    short             i2_dl_freq;
  /** DL Primary Synchronization Code
   */
    short             i2_dl_psc;/* 0~511. */
  /** DL Orthogonal Variable Spreading Factor
   */
    short             i2_dl_ovsf;///<RMC12.2k: <128, but test set not allow all ovsf,
  /** UL frequency
   * \sa UARFCN
   */
    short            i2_ul_freq;
  /** UL Transport Format Combination Identifier
   */
    unsigned short   u2_ul_tfci;
  /** UL Scrambling code
  */
    unsigned int     u4_ul_sc_code;  /* Scrambling code #. 0 ~ 16777215 */
  /** DPDCH DPCCH power valid flag\n
   *  TRUE  : vaild\n
   *  FALSE : invalid
   */
    bool             b_iq_pwr_valid;///<valid dpcch, dpdch power
  /** UL DPCCH power value, default value is 8
   */
    unsigned char    u1_dpcch_pwr;///<default 8, depends on testing requirement
  /** UL DPDCH power value, default value is 15
   */
    unsigned char    u1_dpdch_pwr;///<default 15, depends on testing requirement
} UL1D_RF_NSFT_REQ_T;

/** list mode */
#define FT_MAX_LIST_MODE_FREQ_COUNT 50
typedef struct
{
    bool afc_dac_valid;
    unsigned short afc_dac;
    unsigned char loopbackType;///<0: no loopback, 1: loopback type 1, 2: loopback type 2
    unsigned char frame_shift;///<default=0, depends on Test Machine
    unsigned char rmc_type;///<1: 12.2k, 2: 64k, 3: 144k, 4: 384k
    unsigned char ctfc[4];///<8960=0,1,2,3; cmu200=0,2,1,3
    unsigned char bit_pattern;///<0: single ended ber disable, 1: all one, 2: all zero
    /* DL parameters */
    short dl_freq[50];
    short dl_psc;/* 0~511. */
    short dl_ovsf;///<RMC12.2k: <128, but test set not allow all ovsf, //RMC12.2k default ovsf=9
    /* UL parameters */
    short ul_freq[50];
    unsigned short ul_tfci;
    unsigned int ul_sc_code;    /* Scrambling code #. 0 ~ 16777215 */
    bool iq_pwr_valid;///<valid dpcch, dpdch power
    unsigned char dpcch_pwr;///<default 8, depends on testing requirement
    unsigned char dpdch_pwr;///<default 15, depends on testing requirement
    /* common parameters */
    unsigned char valid_freq; ///<valid count of dl/ul freq.
    unsigned short test_item[50]; /**
                                   * <bit0, reserved. //bit1=1: single ended BER enable //bit2=1: rssi enable //bit3, reserved //bit4, reserved
                                   * bit5=1: ILPC_ABC enable //bit6=1: ILPC_EF enable //bit7=1: ILPC_GH enable
                                   * the time settings, unit = frame
                                   * */
    unsigned short full_test_time;///<the total time of one freq.
    unsigned char ready_time; ///< for first sync after TX transmit
    unsigned char sync_time; ///< from cs_start to LBK is 26 frame
    unsigned char retrial; ///<just for first sync
    unsigned short test_time; ///<the time of test for max&min TX power tests
    unsigned short rx_rssi_start_time[3]; ///<RSSI start time for 3 LNA mode
    unsigned char rx_rssi_duration[3];
    unsigned short rx_ber_start_time; ///<BER start time, no used now.
    unsigned char rx_ber_duration;
    unsigned short ILPC_ABC_time; ///<the time of ILPC ABC
    unsigned short ILPC_EF_time; ///<the time of ILPC EF
    unsigned short ILPC_GH_time; ///<the time of ILPC GH
    unsigned short transition_time; ///<the limitation of UE state machine is 4 frame at least
} URfNsftListModeReq;
/**
 * \ingroup WCDMAStruct
 * META DLL HSPA NSFT parameter
 */
typedef struct
{
    UL1D_RF_NSFT_REQ_T r99Param;
    unsigned char      subTest;
} META_URfTestCmdHspaNsft;

typedef struct
{
    bool    ok;
    unsigned char   num_freq;
    short   dl_freq[ MAX_FREQ_LIST ];
    int inband_pow[ MAX_FREQ_LIST ];
} URfTestResultRxGainSweep;

typedef struct
{
    bool    ok;
    unsigned char   num_freq;
    short   dl_freq[ MAX_FREQ_LIST ];
    int rssi[ MAX_FREQ_LIST ];
} URfTestResultRSSI;

typedef struct
{
    bool      ok;
    int       NSFT_RSSI;
    int       NSFT_RSSI_RXD;
    int          cmd_location;
} URfTestResultNSFTRSSI;

typedef struct
{
    bool ok;
    unsigned int  u4TotalBits;
    unsigned int  u4ErrorBits;
} URfTestResultNSFTResetBERResult;

typedef struct
{
    bool    ok;
    unsigned char   num_freq;
    short   dl_freq[ MAX_FREQ_LIST ];
    int rssi[ MAX_FREQ_LIST ];
    int rssi_rxd[ MAX_FREQ_LIST ];
} URfTestResultRSSIRxD;
typedef struct
{
    unsigned char   num_freq;
    short   dl_freq[ MAX_FREQ_LIST ];
    int rx_rssi[ MAX_FREQ_LIST ];
    int rxd_rssi[ MAX_FREQ_LIST ];
    unsigned char rx_LNAmode[ MAX_FREQ_LIST ];
    unsigned char rxd_LNAmode[ MAX_FREQ_LIST ];
} URfTestResultELNARSSI;

typedef struct
{
    unsigned short  psc;        /**< Primary scrambling code */
    int tm;     /**< Cell frame boundary offset to LST */
    short   off;        /**< Cell frame number offset to LST */
    bool    sttd;       /**< True for STTD used. */
    unsigned char   sample_num;
    short rscp_sum;
    short freq_error;  // 20070514
} UL1TST_cpich_result_T;
#define MAX_NUM_MEAS_CELL 32
typedef struct
{
    bool        ok;
    unsigned char       num_cell;
    UL1TST_cpich_result_T   cpich_result[ MAX_NUM_MEAS_CELL ];
} URfTestResultRSCP;
typedef struct
{
    bool            ok;
    unsigned short  psc;        /**< Primary scrambling code */
    int             tm;     /**< Cell frame boundary offset to LST */
    bool            sttd;       /**< True for STTD used. */
    unsigned char   rscp_sum;
    short           freq_error;
} URfTestResultAFC;
typedef struct
{
    bool            ok;
    unsigned short  psc;        /**< Primary scrambling code */
    int             tm;         /**< Cell frame boundary offset to LST */
    bool            sttd;       /**< True for STTD used. */
    unsigned char   rscp_sum;
    int             freq_error;
} URfTestResultAFC_Ex;
typedef struct
{
    bool    ok;
    unsigned int    ber;    /**< Spec requirement=10^-3. We will count 10^5 frames(100 times spec requirement) for BER calculation. Only count for the only TRCh for DPDCh. */
} URfTestResultRxDPCh;
#define  UL1D_RF_ID_SONY_CXA3359    0x00000001
#define  UL1D_RF_ID_MT6159B         0x00000002
#define  UL1D_RF_ID_SMARTI3G        0x00000003
#define  UL1D_RF_ID_MT6159C         0x00000004
#define  UL1D_RF_ID_MT6159D         0x00000005
#define  UL1D_RF_ID_MT6159E         0x00000006
#define  UL1D_RF_ID_MT6160          0x00000007
#define  UL1D_RF_ID_MT6161          0x00000010
#define  UL1D_RF_ID_MT6162          0x00000008
#define  UL1D_RF_ID_MT6162_DUAL     0x00000009
#define  UL1D_RF_ID_MT6280          0x0000000B
#define  UL1D_RF_ID_MT6167          0x0000000C
#define  UL1D_RF_ID_MT6166          0x0000000D
#define  UL1D_RF_ID_MT6169          0x0000000E
#define  UL1D_RF_ID_MT6580          0x0000000F
#define  UL1D_RF_ID_MT6176          0x00000011
#define  UL1D_RF_ID_MT6179          0x00000012
#define  UL1D_RF_ID_MT6570          0x00000013
#define  UL1D_RF_ID_MT6177          0x00000014
#define  UL1D_RF_ID_MT6177M         0x00000015
#define  UL1D_RF_ID_MT6185          0x00000016
#define  UL1D_RF_ID_MT6186          0x00000017


typedef struct
{
    unsigned int m_u4Rfid;
} URfTestResultRFID;
typedef struct
{
    unsigned char m_u1Result;
} URfTestResultPwrDtStep;
typedef struct
{
    unsigned short m_u2Result;
} URfTestResultPwrDtDac;
typedef struct
{
    unsigned char m_u1Result;
} URfTestResultPwrDtDefaultThr;

#define UMTS_SUPPORT_BAND1       0x00000001
#define UMTS_SUPPORT_BAND2       0x00000002
#define UMTS_SUPPORT_BAND3       0x00000004
#define UMTS_SUPPORT_BAND4       0x00000008
#define UMTS_SUPPORT_BAND5       0x00000010
#define UMTS_SUPPORT_BAND6       0x00000020
#define UMTS_SUPPORT_BAND7       0x00000040
#define UMTS_SUPPORT_BAND8       0x00000080
#define UMTS_SUPPORT_BAND9       0x00000100
#define UMTS_SUPPORT_BAND10      0x00000200
#define UMTS_SUPPORT_BAND11      0x00000400
#define UMTS_SUPPORT_BAND12      0x00000800
#define UMTS_SUPPORT_BAND13      0x00001000
#define UMTS_SUPPORT_BAND14      0x00002000
#define UMTS_SUPPORT_BAND15_DMY  0x00004000 /* dummy band */
#define UMTS_SUPPORT_BAND16_DMY  0x00008000 /* dummy band */
#define UMTS_SUPPORT_BAND17      0x00010000
#define UMTS_SUPPORT_BAND18_DMY  0x00020000 /* dummy band */
#define UMTS_SUPPORT_BAND19      0x00040000
#define UMTS_SUPPORT_BAND_COUNT  19


typedef struct
{
    unsigned int    PaOctLevelControl: 1;                  // 0x00000001
    unsigned int    PaPhaseCompensationConversion: 1;      // 0x00000002
    unsigned int    PaCouplerLossByPaMode: 1;              // 0x00000004
    unsigned int    HsdpaNsft: 1;                          // 0x00000008
    unsigned int    HsupaNsft: 1;                          // 0x00000010
    unsigned int    UmtsFddDcxoSupport: 1;                 // 0x00000020
    unsigned int    UmtsFddRxDiversitySupport: 1;          // 0x00000040
    unsigned int    UmtsFddRxDualCellSupport: 1;           // 0x00000080
    unsigned int    PdMeasurementDbConversion: 1;          // 0x00000100
    unsigned int    PaDriftCompenstaion: 1;                // 0x00000200
    unsigned int    UmtsTempAdcUsingL1API: 1;              // 0x00000400
    unsigned int    Dc2DcLevelUnused: 1;                   // 0x00000800
    unsigned int    RxSoftwareModeTracking: 1;             // 0x00001000
    unsigned int    FhcTxVgaBB0Mode: 1;                    // 0x00002000
    unsigned int    FhcTxFrameDurationLimit: 1;            // 0x00004000  /**< frame time 15 ms * x */
    unsigned int    NsftSetICSInitialGain: 1;              // 0x00008000  /**< setup initial gain for ICS */
    unsigned int    UmtsFddTxPRACHTemperatureCompensationSupport: 1; // 0x00010000  /**< setup temperature compensation for PRACH Tx*/
    unsigned int    RfCapabilityExtension: 1;              // 0x00020000  /**< indicates the extended capability API is supported by UL1 */
    unsigned int    UmtsFddDpdSupport: 1;                  // 0x00040000  /**< indicates that wcdma dpd support band is reported by L1 */
} UMTS_MsCapabilityEx_Bits;
typedef struct
{
    unsigned int        capability;
    unsigned int        band_support;
    /** R8 RX diversity band support */
    unsigned int        rxd_band_support;
    /** R8 Pa drift compenstaion band support */
    unsigned int        padrift_band_support;
    unsigned int        dpd_band_support;
} UMTS_MsCapabilityEx;
typedef struct
{
    UMTS_MsCapabilityEx_Bits      capability;
    unsigned int                  band_support;
    /** R8 RX diversity band support */
    unsigned int                  rxd_band_support;
    /** R8 Pa drift compenstaion band support */
    unsigned int                  padrift_band_support;
    unsigned int                  dpd_band_support;
} UMTS_MsCapabilityEx2;
typedef struct
{
    bool         bDataValid;
    unsigned int u4TotalBits; ///< if bDataValid = true, the value here is valid
    unsigned int u4ErrorBits; ///< if bDataValid = true, the value here is valid
} UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T;

/**
 * \ingroup WCDMAStruct
 * This structure defines the report of NSFT synchronize status
 */
typedef struct
{
  /** link status flag\n
   *  TRUE  :Sucess\n
   *  FALSE :Fail
   */
    bool          ok;
  /** link status report (enumeration):\n
   *  1: Cell Search synchronize Fail\n
   *  2: System Frame Number synchronize Fail\n
   *  4: Synchronize successfully, loopback mode ready
   */
    unsigned char link_status;
} UMTS_NSFTLinkStatusReport;

typedef struct
{
    unsigned char status;
    unsigned char current_idx;
    short   total_bits[FT_MAX_LIST_MODE_FREQ_COUNT][2]; ///<[0]:real ber test. [1]: ber test for debug
    short   error_bits[FT_MAX_LIST_MODE_FREQ_COUNT][2];
    short   rssi[FT_MAX_LIST_MODE_FREQ_COUNT][3]; ///<RSSI at 3 LNA mode
    short   rssi_rxd[FT_MAX_LIST_MODE_FREQ_COUNT][3]; ///<RSSI at 3 LNA mode
    char    lnamode[3]; ///<0 : high, 1 : mid, 2 : low
} URfNsftListModeCnf;

typedef struct
{
    bool          ok;    /**< ok indicator */
    unsigned int  sum;   /**< the sum of measure_count times of temp sensor result */
} URfTestResultGetRfTempSensor;

typedef struct
{
    unsigned int is_capable      : 1; /**< the indicator to indicate if this item is supported by SW or HW */
    unsigned int is_mandatory    : 1; /**< the indicator to indicate if this item is mandatory to be calibrated */
    unsigned int parameter       : 30; /**< parameter to be carried to tool side */
} UL1TSTCalibrationItem;

typedef struct
{
    unsigned int mipi_pa_support_band; /**< bit map of mipi pa support band */
    unsigned int rx_gain_sweep_support; /**< bit map of rx gain sweep support>*/
} UL1TSTCapabilityItemSet;

/* DO NOT Modify the member order of UL1TSTCalibrationItemSet, Items must be added to the end  */
typedef struct
{
    UL1TSTCalibrationItem tadc_cal;                                   /**<  [0] TADC calibration capability.           ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem multi_rat_tadc_bitmap;                      /**<  [1] bit map of multi-rat TADC calibration. ;is_capable (0: not supported, 1: supported) parameter (0|0|C|Lf|Lt|T|W|G) */
    UL1TSTCalibrationItem multi_rat_afc_bitmap;                       /**<  [2] bit map of multi-rat AFC calibration.  ;is_capable (0: not supported, 1: supported) parameter (0|0|C|Lf|Lt|T|W|G) */
    UL1TSTCalibrationItem mipi_pa_level_and_cw_num;                   /**<  [3] MIPI PA power level and codeword number;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem temperature_info;                           /**<  [4] Target support temperature info.       ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem list_mode_support;                          /**<  [5] Target support list mode API.          ;is_capable (0: not supported, 1: supported) parameter (0: not supportted Rxd RSSI 1: supported Rxd RSSI) */
    UL1TSTCalibrationItem thermal_sensor_type;                        /**<  [6] Target support temp sensor type.       ;is_capable (0: not supported, 1: supported) parameter (0: internal 1: external) */
    UL1TSTCalibrationItem ubin_mode_switch_support;                   /**<  [7] Target support universal bin switch.   ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem nvram_access_interface;                     /**<  [8] Target support nvram access interface. ;is_capable (0: not supported, 1: supported) parameter (0x01 RX pathloss)*/
    UL1TSTCalibrationItem rx_gain_lpm_offset;                         /**<  [9] Target support RX low power gain mode. ;is_capable (0: not supported, 1: supported) parameter (bit0-4 normal gain number, bit5-9 low power offset number) */
    UL1TSTCalibrationItem nsft_get_RSSI;                              /**< [10] Target support get RSSI during NSFT.   ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem new_prf_select_method;                      /**< [11] Prf selection for fitting H/M/L mode.  ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem nsft_reset_ber_result;                      /**< [12] Support reset ber result command       ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem elna_addition;                              /**< [13] Target support eLNA                    ;is_capable (0: not supported, 1: supported) parameter (band support bitmap of eLNA |...|band4|band3|band2|band1|)*/
    UL1TSTCalibrationItem apc_extend;                                 /**< [14] Support APC additional gain cal        ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem elna_addition_diversity_path;               /**< [15] Target support eLNA div path           ;is_capable (0: not supported, 1: supported) parameter (band support bitmap of eLNA |...|band4|band3|band2|band1|)*/
    UL1TSTCalibrationItem cancel_polling_action_when_get_fhc_result;  /**< [16] cancel polling when get fhc result     ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem wcdma_md_cal_generation;                    /**< [17] Modem calibration generation           ;is_capable (0: not supported, 1: supported) parameter (3:V3)*/
    UL1TSTCalibrationItem dpd_generation;                             /**< [18] WCDMA DPD support                      ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem wcdma_iq_dump;                              /**< [19] WCDMA IQ dump support                  ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem wcdma_afc_rscp_generation;                  /**< [20] Indicate WCDMA AFC & RSCP version      ;is_capable (0: not supported, 1: supported) */
    UL1TSTCalibrationItem wcdma_nsft_tx_power_offset;                 /**< [21] Support WCDMA TX power offset function ;is_capable (0: not supported, 1: supported) */
} UL1TSTCalibrationItemSet;

typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} URfTestCmdGetRfCapabilityReq;

typedef struct
{
    int                    valid;
    int                    status;
    UL1TSTCapabilityItemSet capabilityItems;
    UL1TSTCalibrationItemSet calibrationItems;
} URfTestResultGetRfCapabilityCnf;
#define MAX_URF_MIPI_POWER_LEVEL   16
#define MAX_URF_MIPI_CODE_WORD_NUM 16
typedef struct
{
    unsigned short       rf_band_idx;
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_URF_MIPI_POWER_LEVEL][MAX_URF_MIPI_CODE_WORD_NUM];
} URfTestCmdSetMIPICodeWord;
typedef struct
{
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_URF_MIPI_POWER_LEVEL][MAX_URF_MIPI_CODE_WORD_NUM];
} URfTestResultGetMIPICodeWord;
typedef struct
{
    short status;
    short tadc_dac;
    short temperature;
    short temp_index;
} META_Rf_TemperatureInfo_T;
typedef META_Rf_TemperatureInfo_T META_3Grf_TemperatureInfo_T;
typedef union
{
    bool                                   ok;
    char                                   nvramAccessResult;
    char                                   m_i1CurGainTableState;
    unsigned int                           bsi_data;
    unsigned int                           m_u4MaxCapId;
    unsigned char                          currentLnaMode;
    URfTestResultRSSI                      rssi;
    URfTestResultRSSIRxD                   rssi_rxd; /**< \brief R8 get both rx path RSSI */
    URfTestResultELNARSSI                  rssi_elna;
    URfTestResultAFC                       afc;
    URfTestResultRSCP                      rscp;
    URfTestResultRFID                      rfid;
    UL1D_RF_FHC_CNF_T                      m_rMQCResult;
    URfTestResultAFC_Ex                    afc_ex;
    URfTestResultRxDPCh                    rx_dpch;
    UMTS_MsCapabilityEx                    m_rTargetCapability;
    UL1D_RF_FHC_EX2_CNF_T                  fhcExResult;
    URfTestResultPwrDtDac                  pwr_dt_dac;
    URfTestResultPwrDtStep                 pwr_dt_step;
    UMTS_NSFTLinkStatusReport              m_rNSFTLinkStatusReport;
    URfNsftListModeCnf                     m_rNSFTListModeLinkStatusReport;
    URfTestResultGetRfTempSensor           rfTemperature;
    URfTestResultPwrDtDefaultThr           pwr_dt_default_thr;
    UL1D_RF_GET_PWR_DET_REPORT_CNF_T       m_rPwrDetResult;
    UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T m_rNSFTBERResult;
    URfTestResultRxGainSweep               rx_gain_sweep;
    URfTestResultNSFTRSSI                  rssi_nsft;
    URfTestResultNSFTResetBERResult        resetBERResult;
} URfTestResultParam;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_TxAccess_r
 */
META_RESULT  __stdcall META_3Grf_TxAccess(unsigned int ms_timeout, URfTestCmdTxAccess* req, URfTestResultParam* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_TxAccess_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdTxAccess* req, URfTestResultParam* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_TestStop_r
 */
META_RESULT  __stdcall META_3Grf_TestStop(unsigned int ms_timeout, URfTestResultParam* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_TestStop_r(const int meta_handle, unsigned int ms_timeout, URfTestResultParam* cnf);


/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_TxDpch_r
 */
META_RESULT  __stdcall META_3Grf_TxDpch(unsigned int ms_timeout, URfTestCmdTxDPCh* req, URfTestResultParam* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_TxDpch_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdTxDPCh* req, URfTestResultParam* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_RxDpch_r
 */
META_RESULT  __stdcall META_3Grf_RxDpch(unsigned int ms_timeout, URfTestCmdRxDPCh* req, URfTestResultRxDPCh* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_RxDpch_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdRxDPCh* req, URfTestResultRxDPCh* cnf);


/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Rssi_r
 */
META_RESULT  __stdcall META_3Grf_Rssi(unsigned int ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSI* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Rssi_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSI* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_QueryNsftRssi_r
 */
META_RESULT  __stdcall META_3Grf_QueryNsftRssi(unsigned int ms_timeout, URfTestResultNSFTRSSI* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_QueryNsftRssi_r(const int meta_handle, unsigned int ms_timeout, URfTestResultNSFTRSSI* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_NSFT_Reset_BER_Result_r
 */
META_RESULT  __stdcall META_3Grf_NSFT_Reset_BER_Result(unsigned int ms_timeout, URfTestResultNSFTResetBERResult* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_NSFT_Reset_BER_Result_r(const int meta_handle, unsigned int ms_timeout, URfTestResultNSFTResetBERResult* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_RxDRssi_r
 **/
META_RESULT  __stdcall META_3Grf_RxDRssi(unsigned int ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSIRxD* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
  * \brief R8 RF tool. RX diversity RSSI.
 */
META_RESULT  __stdcall META_3Grf_RxDRssi_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSIRxD* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Rscp_r
 */
META_RESULT  __stdcall META_3Grf_Rscp(unsigned int ms_timeout, URfTestCmdRSCP* req, URfTestResultRSCP* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Rscp_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdRSCP* req, URfTestResultRSCP* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Set_Tx_PaApc_r
 */
META_RESULT  __stdcall META_3Grf_Set_Tx_PaApc(unsigned int ms_timeout, UL1D_RF_TX_PA_APC_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Set_Tx_PaApc_r(const int meta_handle, unsigned int ms_timeout, UL1D_RF_TX_PA_APC_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_AFC_r
 */
META_RESULT  __stdcall META_3Grf_AFC(unsigned int ms_timeout, URfTestCmdAFC* req, URfTestResultAFC* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_AFC_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdAFC* req, URfTestResultAFC* cnf);


/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRFID_r
 */
META_RESULT  __stdcall META_3Grf_GetRFID(unsigned int ms_timeout, URfTestResultRFID* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetRFID_r(const int meta_handle, unsigned int ms_timeout, URfTestResultRFID* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_ConfigHWTPC_r
 */
META_RESULT  __stdcall META_3Grf_ConfigHWTPC(unsigned int ms_timeout, UL1D_RF_HWTPC_CONFIG_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_ConfigHWTPC_r(const int meta_handle, unsigned int ms_timeout, UL1D_RF_HWTPC_CONFIG_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetPwrDtStep_r
 */
META_RESULT  __stdcall META_3Grf_GetPwrDtStep(unsigned int ms_timeout, URfTestResultPwrDtStep* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetPwrDtStep_r(const int meta_handle, unsigned int ms_timeout, URfTestResultPwrDtStep* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetPwrDtDac_r
 */
META_RESULT  __stdcall META_3Grf_GetPwrDtDac(unsigned int ms_timeout, URfTestResultPwrDtDac* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetPwrDtDac_r(const int meta_handle, unsigned int ms_timeout, URfTestResultPwrDtDac* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetPwrDtDefaultThr_r
 */
META_RESULT  __stdcall META_3Grf_GetPwrDtDefaultThr(unsigned int ms_timeout, UL1D_RF_GET_PWR_THR_REQ_T* req, URfTestResultPwrDtDefaultThr* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetPwrDtDefaultThr_r(const int meta_handle, unsigned int ms_timeout, UL1D_RF_GET_PWR_THR_REQ_T* req, URfTestResultPwrDtDefaultThr* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetImmediateBSI_r
 */
META_RESULT  __stdcall META_3Grf_SetImmediateBSI(unsigned int ms_timeout, const UL1D_RF_SET_BSI_DATA_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_SET_BSI_DATA_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetImmediateBSI_r
 */
META_RESULT  __stdcall META_3Grf_GetImmediateBSI(unsigned int ms_timeout, const UL1D_RF_GET_BSI_DATA_REQ_T* req, unsigned int* p_bsi_data);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_GET_BSI_DATA_REQ_T* req, unsigned int* p_bsi_data);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_ContinuousRX_r
 */
META_RESULT  __stdcall META_3Grf_ContinuousRX(unsigned int ms_timeout, URfTestCmdRSSI* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_ContinuousRX_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdRSSI* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_FHC_Start_r
 */
META_RESULT  __stdcall META_3Grf_FHC_Start(unsigned int ms_timeout, const UL1D_RF_FHC_REQ_T* req, UL1D_RF_FHC_CNF_T* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_FHC_Start_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_FHC_REQ_T* req, UL1D_RF_FHC_CNF_T* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_FHC_NoWaitResult_r
 */
META_RESULT  __stdcall META_3Grf_FHC_NoWaitResult(unsigned int ms_timeout, const UL1D_RF_FHC_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_FHC_NoWaitResult_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_FHC_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_QueryFHCResult_r
 */
META_RESULT  __stdcall META_3Grf_QueryFHCResult(unsigned int ms_timeout, UL1D_RF_FHC_CNF_T* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_QueryFHCResult_r(const int meta_handle, unsigned int ms_timeout, UL1D_RF_FHC_CNF_T* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetPwrDtMeasureResult_r
 */
META_RESULT  __stdcall META_3Grf_GetPwrDtMeasureResult(unsigned int ms_timeout,
        const UL1D_RF_GET_PWR_DET_REPORT_REQ_T* req,
        UL1D_RF_GET_PWR_DET_REPORT_CNF_T* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */        
META_RESULT  __stdcall META_3Grf_GetPwrDtMeasureResult_r(const int meta_handle, unsigned int ms_timeout,
        const UL1D_RF_GET_PWR_DET_REPORT_REQ_T* req,
        UL1D_RF_GET_PWR_DET_REPORT_CNF_T* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetPowerControlMode_r
 */
META_RESULT  __stdcall META_3Grf_SetPowerControlMode(unsigned int ms_timeout, const UL1D_RF_SET_PWR_CTRL_MODE_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetPowerControlMode_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_SET_PWR_CTRL_MODE_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_ReplaceGainTableforCal_r
 */
META_RESULT  __stdcall META_3Grf_ReplaceGainTableforCal(unsigned int ms_timeout, const unsigned char* pTableType, char* pCurState);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_ReplaceGainTableforCal_r(const int meta_handle, unsigned int ms_timeout, const unsigned char* pTableType, char* pCurState);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_QueryTargetCapability_r
 */
META_RESULT  __stdcall META_3Grf_QueryTargetCapability(unsigned int ms_timeout, UMTS_MsCapabilityEx* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_QueryTargetCapability_r(const int meta_handle, unsigned int ms_timeout, UMTS_MsCapabilityEx* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_NSFT_Start_r
 */
META_RESULT  __stdcall META_3Grf_NSFT_Start(unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_NSFT_Start_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_NSFT_GetBitCountForSingleEndedBER_r
 */
META_RESULT  __stdcall META_3Grf_NSFT_GetBitCountForSingleEndedBER(unsigned int ms_timeout, UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_NSFT_GetBitCountForSingleEndedBER_r(const int meta_handle, unsigned int ms_timeout, UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_NSFT_SetILPCStep_r
 */
META_RESULT  __stdcall META_3Grf_NSFT_SetILPCStep(unsigned int ms_timeout, unsigned char step);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_NSFT_SetILPCStep_r(const int meta_handle, unsigned int ms_timeout, unsigned char step);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_NSFT_StartEx_r
 */
META_RESULT  __stdcall META_3Grf_NSFT_StartEx(unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req, UMTS_NSFTLinkStatusReport* cnf);
/**
 * \details For triggering WCDMA TX NSFT Test
 * \ingroup WCDMA
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req UL1D_RF_NSFT_REQ_T
 * \param [out] cnf UMTS_NSFTLinkStatusReport
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */

META_RESULT  __stdcall META_3Grf_NSFT_StartEx_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req, UMTS_NSFTLinkStatusReport* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_HsdpaNsftStart_r
 */
META_RESULT  __stdcall META_3Grf_HsdpaNsftStart(unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_HsdpaNsftStart_r(const int meta_handle, unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_HsupaNsftStart_r
 */
META_RESULT  __stdcall META_3Grf_HsupaNsftStart(unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_HsupaNsftStart_r(const int meta_handle, unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_NSFT_List_Mode_Start_r
 */
META_RESULT  __stdcall META_3Grf_NSFT_List_Mode_Start(unsigned int ms_timeout, const URfNsftListModeReq* req, URfNsftListModeCnf* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_NSFT_List_Mode_Start_r(const int meta_handle, unsigned int ms_timeout, const URfNsftListModeReq* req, URfNsftListModeCnf* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_FHC_StartEx_r
 */
META_RESULT  __stdcall META_3Grf_FHC_StartEx(unsigned int ms_timeout, const UL1D_RF_FHC_EX_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_FHC_StartEx_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_FHC_EX_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_QueryFHCExResult_r
 */
META_RESULT  __stdcall META_3Grf_QueryFHCExResult(unsigned int ms_timeout, UL1D_RF_FHC_EX2_CNF_T* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_QueryFHCExResult_r(const int meta_handle, unsigned int ms_timeout, UL1D_RF_FHC_EX2_CNF_T* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_QueryCurrentLnaMode_r
 */
META_RESULT  __stdcall META_3Grf_QueryCurrentLnaMode(unsigned int ms_timeout, unsigned char* mode);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_QueryCurrentLnaMode_r(const int meta_handle, unsigned int ms_timeout, unsigned char* mode);


/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_FHC_ELNA_r
 */
META_RESULT  __stdcall META_3Grf_FHC_ELNA(unsigned int ms_timeout, const UL1D_RF_FHC_ELNA_REQ_T* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_FHC_ELNA_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_FHC_ELNA_REQ_T* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_ELNA_Rssi_r
 */
META_RESULT  __stdcall META_3Grf_ELNA_Rssi(unsigned int ms_timeout, URfTestCmdELNARSSI* req, URfTestResultELNARSSI* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_ELNA_Rssi_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdELNARSSI* req, URfTestResultELNARSSI* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_ELNA_ContinuousRssi_r
 */
META_RESULT  __stdcall META_3Grf_ELNA_ContinuousRssi(unsigned int ms_timeout, URfTestCmdELNARSSI* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_ELNA_ContinuousRssi_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdELNARSSI* req);
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Set_Initial_Cellpower_r
 **/
 
 // pass cell power to UL1 to choose the best initial gain for ICS
META_RESULT  __stdcall META_3Grf_Set_Initial_Cellpower(unsigned int ms_timeout, int confg_cell/*uints:qdbm*/);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Set_Initial_Cellpower_r(const int meta_handle, unsigned int ms_timeout, int confg_cell/*uints:qdbm*/);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_QueryCurrentRxDLnaMode_r
 */
 //R8 get RxD LNA mode
META_RESULT  __stdcall META_3Grf_QueryCurrentRxDLnaMode(unsigned int ms_timeout, unsigned char* mode);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_QueryCurrentRxDLnaMode_r(const int meta_handle, unsigned int ms_timeout, unsigned char* mode);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetCapId_r
 */
META_RESULT  __stdcall META_3Grf_SetCapId(unsigned int ms_timeout, unsigned int capId);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetCapId_r(const int meta_handle, unsigned int ms_timeout, unsigned int capId);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetMaxCapId_r
 */
META_RESULT  __stdcall META_3Grf_GetMaxCapId(unsigned int ms_timeout, unsigned int* capId);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetMaxCapId_r(const int meta_handle, unsigned int ms_timeout, unsigned int* capId);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_AFC_Ex_r
 */
META_RESULT  __stdcall META_3Grf_AFC_Ex(unsigned int ms_timeout, URfTestCmdAFC* req, URfTestResultAFC_Ex* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_AFC_Ex_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdAFC* req, URfTestResultAFC_Ex* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetRxBandwidth_r
 */
META_RESULT __stdcall META_3Grf_SetRxBandwidth(unsigned int ms_timeout, unsigned char is_5mhz);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_SetRxBandwidth_r(const int meta_handle, unsigned int ms_timeout, unsigned char is_5mhz);

/**
 * Starts from R8
 * The RX path splits into two path: main and diversity.
 */
typedef enum
{
    RX_PATH_NONE = 0, /**< none is enabled */
    RX_PATH_MAIN = 1, /**< main path is enabled */
    RX_PATH_DIVERSITY = 2, /**< diversity path is enabled */
    RX_PATH_BOTH = 3 /**< both path are enabled */
} RF_RX_PATH_T;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetRxAntenna_r
 */
META_RESULT __stdcall META_3Grf_SetRxAntenna(unsigned int ms_timeout, RF_RX_PATH_T is_main);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_SetRxAntenna_r(const int meta_handle, unsigned int ms_timeout, RF_RX_PATH_T is_main);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetTxPaDriftCompEnable_r
 */
META_RESULT __stdcall META_3Grf_SetTxPaDriftCompEnable(unsigned int ms_timeout, unsigned char is_PaDrift);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_SetTxPaDriftCompEnable_r(const int meta_handle, unsigned int ms_timeout, unsigned char is_PaDrift);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRfTemperature_r
 */
META_RESULT __stdcall META_3Grf_GetRfTemperature(unsigned int ms_timeout, const unsigned short measureCount, URfTestResultGetRfTempSensor* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_GetRfTemperature_r(const int meta_handle, unsigned int ms_timeout, const unsigned short measureCount, URfTestResultGetRfTempSensor* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRfCapability_r
 */
META_RESULT __stdcall META_3Grf_GetRfCapability(unsigned int ms_timeout, const URfTestCmdGetRfCapabilityReq* req, const unsigned int requestLength, URfTestResultGetRfCapabilityCnf* cnf, const unsigned int responseLength);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_GetRfCapability_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetRfCapabilityReq* req, const unsigned int requestLength, URfTestResultGetRfCapabilityCnf* cnf, const unsigned int responseLength);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetMIPICodeWord_r
 */
META_RESULT __stdcall META_3Grf_SetMIPICodeWord(unsigned int ms_timeout, const URfTestCmdSetMIPICodeWord* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_SetMIPICodeWord_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetMIPICodeWord* req);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetMIPICodeWord_r
 */
META_RESULT __stdcall META_3Grf_GetMIPICodeWord(unsigned int ms_timeout, const unsigned short RfBandIndex, URfTestResultGetMIPICodeWord* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_GetMIPICodeWord_r(const int meta_handle, unsigned int ms_timeout, const unsigned short RfBandIndex, URfTestResultGetMIPICodeWord* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetTemperatureInfo_r
 */
META_RESULT __stdcall META_3Grf_GetTemperatureInfo(const unsigned int ms_timeout, META_3Grf_TemperatureInfo_T* info);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_GetTemperatureInfo_r(const int meta_handle, const unsigned int ms_timeout, META_3Grf_TemperatureInfo_T* info);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_RxGainSweep_r
 */
META_RESULT __stdcall META_3Grf_RxGainSweep(unsigned int ms_timeout, URfTestCmdRxGainSweep* req, URfTestResultRxGainSweep* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_RxGainSweep_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdRxGainSweep* req, URfTestResultRxGainSweep* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_UbinModeSetup_r
 */
META_RESULT __stdcall META_3Grf_UbinModeSetup(unsigned int ms_timeout, const unsigned char ubin_fdd_mode_init);//  1 : UBIN mode Init 3G FDD ,      0 : UBIN mode de-init 3G FDD
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT __stdcall META_3Grf_UbinModeSetup_r(const int meta_handle, unsigned int ms_timeout, const unsigned char ubin_fdd_mode_init);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRfChipIdName_r
 */
const char* __stdcall META_3Grf_GetRfChipIdName(unsigned int id);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
const char* __stdcall META_3Grf_GetRfChipIdName_r(const int meta_handle, unsigned int id);


/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Lpm_Rssi_r
 */
META_RESULT  __stdcall META_3Grf_Lpm_Rssi(unsigned int ms_timeout, URfTestCmdLPMRSSI* req, URfTestResultRSSI* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Lpm_Rssi_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdLPMRSSI* req, URfTestResultRSSI* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Lpm_RxDRssi_r
 */
META_RESULT  __stdcall META_3Grf_Lpm_RxDRssi(unsigned int ms_timeout, URfTestCmdLPMRSSI* req, URfTestResultRSSIRxD* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Lpm_RxDRssi_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdLPMRSSI* req, URfTestResultRSSIRxD* cnf);

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Lpm_ContinuousRX_r
 */
META_RESULT  __stdcall META_3Grf_Lpm_ContinuousRX(unsigned int ms_timeout, URfTestCmdLPMRSSI* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Lpm_ContinuousRX_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdLPMRSSI* req);
/**
 * \ingroup WCDMAStruct
 * 3G TX/RX calbiration data interface.
 */
typedef struct
{
    unsigned char version_number;
} URfTestCmdCalDataProcess;
#define UL1D_RF_LNA_NUM     6
/**
 * \ingroup WCDMAStruct
 * number of temperature compensation division
 */
#define CAL_TEMP_SECTION    8

/**
 * \ingroup WCDMAStruct
 * the maximum allowable number of RX sub-band division
 */
#define CAL_UARFCN_SECTION 15
typedef  struct
{
    unsigned short max_uarfcn;
    char           path_loss_HPM[UL1D_RF_LNA_NUM];
    char           path_loss_LPM[UL1D_RF_LNA_NUM];
} UL1D_RF_LNA_PATHLOSS;
typedef  struct
{
    unsigned char           band;
    unsigned char           rxantpath;
    char                    temper_offset[CAL_TEMP_SECTION];
    UL1D_RF_LNA_PATHLOSS    loss_of_uarfcn[CAL_UARFCN_SECTION];
} URfTestPathlossItem;
typedef union
{
    URfTestPathlossItem     urfPathLoss;
} URfRxCalData;
typedef struct
{
    unsigned char version_number;
    unsigned char is_uplate_to_NVRAM;
    URfRxCalData  rxCalData;
} URfTestCmdSetRxCalData;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Set_RX_CalibrationData_r
 */
META_RESULT  __stdcall META_3Grf_Set_RX_CalibrationData(unsigned int ms_timeout, const URfTestCmdSetRxCalData* req);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Set_RX_CalibrationData_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetRxCalData* req);
typedef struct
{
    unsigned char version_number;
    unsigned char band;
    unsigned char rxantpath;
} URfTestCmdGetRxCalData;
typedef struct
{
    URfRxCalData  rxCalData;
} URfTestResultGetRxCalData;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Get_RX_CalibrationData_r
 */
META_RESULT  __stdcall META_3Grf_Get_RX_CalibrationData(unsigned int ms_timeout, const URfTestCmdGetRxCalData* req, URfTestResultGetRxCalData* cnf);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Get_RX_CalibrationData_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetRxCalData* req, URfTestResultGetRxCalData* cnf);
#define URF_PA_PHASE_COMPENSATION_NUM     3
/**
 * \ingroup WCDMAStruct
 * the maximum allowable number of PA gain mode
 */
#define URF_TX_POWER_DAC_NUM              3
/**
 * \ingroup WCDMAStruct
 * Number of hysteresis region supported by MDSW
 */
#define URF_TX_HYSTERESIS_NUM             2
/**
 * \ingroup WCDMAStruct
 * the maximum allowable number of gears for PA gain calibration
 */
#define URF_PA_SETTING_NUM                8
/**
 * \ingroup WCDMAStruct
 * the maximum allowable number of TX sub-band division
 */
#define URF_CAL_UARFCN_SECTION_NUM       15

/**
 * \ingroup WCDMAStruct
 * the maximum allowable number of detector sub-band division
 */
#define URF_CAL_PWR_DETECTOR_SECTION_NUM 32
/**
 * \ingroup WCDMAStruct
 * only [9] is useful value
 */
#define URF_VGA_DAC_NUM                  10
/**
 * \ingroup WCDMAStruct
 * Number of temperature compensation 1
 */
#define URF_VGA_TEMP_COMPENSATION_1_NUM   8
/**
 * \ingroup WCDMAStruct
 * Number of temperature compensation 2
 */
#define URF_VGA_TEMP_COMPENSATION_2_NUM   2
#define ARX_NORMAL_GAIN_MODE_NUM          6
#define ARX_LPM_GAIN_MODE_OFFSET_NUM      3
#define ARX_CAPABILITY_BIT_FIELD_SHIFT    5
#define UL1TST_CHIP_VERSION               1
#define NVRAM_ACCESS_BY_UL1TST_TXDATA     2
#define NVRAM_ACCESS_BY_UL1TST_RXDATA     6
/**
 * \ingroup WCDMAStruct
 * This structure defines the hystseresis results.
 */
typedef struct
{
    unsigned short start;  /**< the start point of hysteresis */
    unsigned short end;    /**< the end point of hysteresis */
} UL1D_sHYSTERESISDATA;
/**
 * \ingroup WCDMAStruct
 * \details this structure defines the DC to DC value.
 * \deprecated this struct is deprecated. 
 */
typedef struct
{
    unsigned short level_0;   /**< DC to DC level 0 */
    unsigned short level_1;   /**< DC to DC level 1 */
} UL1D_sDC2DC;
/**
 * \ingroup WCDMAStruct
 * Phase-out structure is not used now.
 */
typedef  struct
{
   unsigned short dc2dc_level;
   unsigned short vbias_dac;
   unsigned char  vm1;
   unsigned char  vm2;
}  UL1D_sPADATA;
/**
 * \ingroup WCDMAStruct
 * The structure defines power detector sub-band result
 */
typedef  struct
{
   unsigned short max_uarfcn;        /**< WCDMA UL UARFCN (spec. defined) */
   short          pwr_offset_dB;     /**< sub-band power offset value (in unit of 1/32 dB) */
   short          pwr_offset_txdac;  /**< Phase-out structure is not used now */
}  UL1D_sARFCN_SECTION;
/**
 * \ingroup WCDMAStruct
 * This structure defines Power detector results & PA sub-band results
 */
typedef struct
{
    UL1D_sPADATA         pa_data;                           /**< Phase-out structure is not used now */
    unsigned short       vga_dac[URF_VGA_DAC_NUM];          /**< the power detector value, which is at vga_dac[9] */
    UL1D_sARFCN_SECTION  vga_comp_by_subband[URF_CAL_UARFCN_SECTION_NUM];   /** PA sub-band compensation data */
  /**
   * PA temperature compensation value (in unit of 1/32 dB)\n
   * \note the data in vga_comp_by_temperature[][2] is not used now
   */
    short                vga_comp_by_temperature[URF_VGA_TEMP_COMPENSATION_1_NUM][URF_VGA_TEMP_COMPENSATION_2_NUM];
} UL1D_sTXPOWERDATA;
/**
 * \ingroup WCDMAStruct
 * This structure defines power detector data
 */
typedef struct
{
    unsigned char        pwr_dt_thr;          /**< Phase-out item is not used now */  
    unsigned char        pwr_dt_section;      /**< Phase-out item  is not used now */  
    unsigned short       pwr_dt_dac[URF_CAL_PWR_DETECTOR_SECTION_NUM];       /**< Phase-out item is not used now */  
    short                pwr_dt_value[URF_CAL_PWR_DETECTOR_SECTION_NUM];     /**< Phase-out item is not used now */  
    UL1D_sARFCN_SECTION  pwr_dt_comp_by_subband[URF_CAL_UARFCN_SECTION_NUM]; /**< the power detetor sub-band compensation results */
    short                pwr_dt_comp_by_temperature[URF_VGA_TEMP_COMPENSATION_1_NUM][URF_VGA_TEMP_COMPENSATION_2_NUM]; /**< Phase-out item is not used now */  
}  UL1D_sPWTDTDATA;
/**
 * \ingroup WCDMAStruct
 * This structure contains power detector mid-band & sub-band data, PA sub-band data and hysteresis setting
 */
typedef struct
{
    UL1D_sDC2DC          pa_dc2dc;                               /**< phase-out structure is not used now */
    UL1D_sTXPOWERDATA    power_dac[URF_TX_POWER_DAC_NUM];        /**< the structure of PA sub-band data and power detector value */
    UL1D_sHYSTERESISDATA tx_hysteresis[URF_TX_HYSTERESIS_NUM];   /**< the structure of hysteresis parameter */
    UL1D_sPWTDTDATA      pwr_dt_data;                            /**< the structure of power detector parameters */
} UL1D_sRAMPDATA;

/**
 * \ingroup WCDMAStruct
 * This structure defines PA oct-level parameter
 */
typedef  struct
{
  /** PA operation mode (enumeration):\n
   *   0: PA be operated in high mode\n
   *   1: PA be operated in middle mode\n
   *   2: PA be operated in low mode
   */
    unsigned char   pa_mode;
  /** Target TX power used in PA gain calibration
   */
    char            prf;
  /** PA supply voltage
   */
    unsigned char   dc2dc_lvl;
  /** For BPI PA control (phase out)
  */
    unsigned char   vm1;
  /** For BPI PA control (phase out)
  */
    unsigned char   vm2;
  /** Voltage bias DAC
  */
    unsigned short  vbias_dac;
  /** PA gain values corresponding to pRf for middle-channel
   */
    unsigned short  pa_gain;
} UL1D_sPMULEVHANDLE;
/**
 * \ingroup WCDMAStruct
 * This structure defines oct-level PA setting
 */
typedef struct
{
  /** Number of PA sections to calibration(fixed to 8)
   */
    unsigned char        octlev_num_section;
  /** Phase-out item, not used now
   */
    unsigned char        reserved_byte;
  /** PA phase compensation value
   */
    unsigned int         pa_phase_compensation[URF_PA_PHASE_COMPENSATION_NUM];
  /** The structure of related PA octlev parameter
   */
    UL1D_sPMULEVHANDLE   pmu_level_handle[URF_PA_SETTING_NUM];
  /** PA gain under RF gain fix at 12A (in unit of 1/32 dB)
   */
    unsigned short       pa_gain_g12a;
  /** PA gain under RF gain fix at 12B (in unit of 1/32 dB)
   */
    unsigned short       pa_gain_g12b;
} UL1D_sPAOCTLVLSETTING;

/**
 * \ingroup WCDMAStruct
 * This structure defines TX calibration data
 */
typedef struct
{
    unsigned char      band;                   /**< WCDMA band number(spec. defined) */
    UL1D_sRAMPDATA     txdacData;              /**< the structure contains power detector mid-band & sub-band data, PA sub-band data and hysteresis setting */
    UL1D_sPAOCTLVLSETTING    txPAOCTLevelData; /**< the structure of oct-level PA mid-band data and setting */
}  URfTestTXDataItem;
/**
 * \ingroup WCDMAStruct
 */
typedef union
{
    URfTestTXDataItem     urfTestTxData;
} URfTxCalData;
typedef struct
{
    unsigned char version_number;
    unsigned char is_uplate_to_NVRAM;
    URfTxCalData  txCalData;
} URfTestCmdSetTxCalData;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Set_TX_CalibrationData_r
 */
META_RESULT  __stdcall META_3Grf_Set_TX_CalibrationData(unsigned int ms_timeout, const URfTestCmdSetTxCalData* req);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Set_TX_CalibrationData_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetTxCalData* req);
typedef struct
{
    unsigned char version_number;
    unsigned char band;
} URfTestCmdGetTxCalData;
typedef struct
{
    URfTxCalData  txCalData;
} URfTestResultGetTxCalData;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_Get_TX_CalibrationData_r
 */
META_RESULT  __stdcall META_3Grf_Get_TX_CalibrationData(unsigned int ms_timeout, const URfTestCmdGetTxCalData* req, URfTestResultGetTxCalData* cnf);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_Get_TX_CalibrationData_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetTxCalData* req, URfTestResultGetTxCalData* cnf);
typedef struct
{
    unsigned char fix_pga_gain;
} URfTestCmdTxDPChFixGain;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_TxDpchFixGain_r
 */
META_RESULT  __stdcall META_3Grf_TxDpchFixGain(unsigned int ms_timeout, const URfTestCmdTxDPChFixGain* req);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_TxDpchFixGain_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdTxDPChFixGain* req);
/**
 * \ingroup WCDMAStruct
 * the maximum allowable number of bands for single FHC command
 */
#define UL1TST_WCDMA_BAND_SUPPORT_V3 5
/**
 * \ingroup WCDMAStruct
 * LNA number of LNA HPM mode
 */
#define UL1TST_HPM_POINT_V3          7
/**
 * \ingroup WCDMAStruct
 * LNA number of LNA LPM mode
 */
#define UL1TST_LPM_POINT_V3          4
#define UL1TST_GAIN_MODE_POINT_V3   (UL1TST_HPM_POINT_V3+UL1TST_LPM_POINT_V3)
/**
 * \ingroup WCDMAStruct
 * the maximum allowable number of power step
 */
#define UL1TST_FHC_POINT_V3          13
typedef struct
{
    unsigned char   cal_band_number;
    unsigned char   cal_band[UL1TST_WCDMA_BAND_SUPPORT_V3]; // band 1 = 1
} URfTestCmdGetMdCalInfoV3;
typedef struct
{
    unsigned char   band;
    unsigned char   rx_elna_mode;
    unsigned char   rxd_elna_mode;
    unsigned char   cal_point_hpm;
    unsigned char   cal_point_lpm;
    unsigned char   rx_cal_sequency[UL1TST_GAIN_MODE_POINT_V3];
    unsigned char   rx_elna_bypass[UL1TST_GAIN_MODE_POINT_V3];
    unsigned char   rxd_elna_bypass[UL1TST_GAIN_MODE_POINT_V3];
    short           rx_cal_dl_power_min[UL1TST_GAIN_MODE_POINT_V3];
    short           rx_cal_dl_power_max[UL1TST_GAIN_MODE_POINT_V3];
    short           rx_cal_dl_power[UL1TST_GAIN_MODE_POINT_V3];
} URfCalBandInfoV3;
typedef struct
{
    unsigned short    support_band_number;
    URfCalBandInfoV3  cal_band_info_v3[UL1TST_WCDMA_BAND_SUPPORT_V3];
} URfTestResultGetMdCalInfoV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetCalInfoV3_r
 */
META_RESULT  __stdcall META_3Grf_GetCalInfoV3(unsigned int ms_timeout, const URfTestCmdGetMdCalInfoV3* req, URfTestResultGetMdCalInfoV3* cnf);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetCalInfoV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetMdCalInfoV3* req, URfTestResultGetMdCalInfoV3* cnf);
/**
 * \ingroup WCDMAStruct
 * the maximum allowable LNA gain mode number to be calibrated
 */
#define UL1TST_MAX_RF_LNA_MODE_NUM_V3  7
/**
 * \ingroup WCDMAStruct
 * Number of sub-band division, note that the last field is for end-mark, hence only 14 sub-bands are supported
 */
#define UL1TST_FHC_FREQUENCY_NUMBER   15
/**
 * \ingroup WCDMAStruct
 * This structure defines RX pathloss value
 */
typedef struct
{
  /** DL UARFCN value
   */
    unsigned short     uarfcn;
  /** The pathloss of high power mode
   */
    short              path_loss_HPM[UL1TST_MAX_RF_LNA_MODE_NUM_V3];
  /** The pathloss of low power mode
   */
    short              path_loss_LPM[UL1TST_MAX_RF_LNA_MODE_NUM_V3];
} URfLnaPathlossV3;
/**
 * \ingroup WCDMAStruct
 * This structure defines the RX calibartion data
 */
typedef struct
{
    unsigned char      band;                                 /**< WCDMA band number(spec. defined) */
    unsigned char      rxantpath;                            /**<  the antenna information for RX data (enumeration):\n  1: RXM\n  2: RXD */
    char               temper_offset[CAL_TEMP_SECTION];      /**< the temperature offset value for RX */
    URfLnaPathlossV3   loss_of_uarfcn[CAL_UARFCN_SECTION];   /**< The structure of RX pathloss */
} URfPathlossV3;
/**
 * \ingroup WCDMAStruct
 * This structure defines the details calibration information for one band
 */
typedef struct
{
    unsigned char      band;              /**< WCDMA band number(spec. defined) */
    unsigned char      freq_count;        /**< number of frequency to be calibrated in one band; always setting to be 14 */
    unsigned char      pwr_count;         /**< number of power step to be calibrated in one frequency; always setting to be 13 */
    unsigned char      hpm_cal_point;     /**< number of RX high power mode points to be calibrated in this band */
    unsigned char      lpm_cal_point;     /**< number of RX low power mode points to be calibrated in this band */
    unsigned char      rx_elna_mode;      /**< the eLNA mode for RXM in this band */
    unsigned char      rxd_elna_mode;     /**< the eLNA mode for RXD in this band */
    unsigned char      is_lpm[UL1TST_FHC_POINT_V3];                /**< the LPM information for calibration */
    unsigned char      rx_elna_bypass[UL1TST_FHC_POINT_V3];        /**< the eLNA bypsss information for RXM */
    unsigned char      rxd_elna_bypass[UL1TST_FHC_POINT_V3];       /**< the eLNA bypsss information for RXD */
    unsigned char      rx_cal_sequency[UL1TST_FHC_POINT_V3];       /**< the sequency number information for calibration */
    unsigned char      fix_pga_gain[UL1TST_FHC_POINT_V3];          /**< the PGA-AB information for TX */
    unsigned char      pa_mode[UL1TST_FHC_POINT_V3];               /**< the PA mode information */
    unsigned char      vga_dac_tpc_idx[UL1TST_FHC_POINT_V3];       /**< the VGA DAC informatiom */
    unsigned char      pa_section[UL1TST_FHC_POINT_V3];            /**< the PA section information */
    unsigned short     pa_gain[UL1TST_FHC_POINT_V3];               /**< the PA gain information */
    short                   rx_cal_dl_power[UL1TST_FHC_POINT_V3];  /**< the DL power information for RX calibration */
    unsigned short     dl_uarfcn[UL1TST_FHC_FREQUENCY_NUMBER];     /**< the DL UARFCN information */
    unsigned short     ul_uarfcn[UL1TST_FHC_FREQUENCY_NUMBER];     /**< the UL UARFCN information */
    URfTestTXDataItem  tx_cal_data_info;                           /**< the TX initial settings (almost loaded from *.ini file) */
    URfPathlossV3      rxm_cal_data_info;                          /**< the RXM initial settings (almost loaded from *.ini file) */
    URfPathlossV3      rxd_cal_data_info;                          /**< the RXM initial settings (almost loaded from *.ini file) */ 
} URfFhcBandParamV3;
/**
 * \ingroup WCDMAStruct
 * This structure is used to assign parameters for triggering WCDMA FHC
 */
typedef struct
{
    unsigned char      cal_band_number;  /**< The number of the band which need to calibrate for single FHC command  */
    unsigned char      cal_band[UL1TST_WCDMA_BAND_SUPPORT_V3];  /**< Band information for which band number(spec. defined) to be calibrated */
    /** 
      *  The antenna setting information (enumeration):\n
      *  1: RXM\n
      *  2: RXD\n
      *  3: RXM+RXD
      */
    unsigned char      antenna_setting;
    unsigned char      step_duration;    /**< The time for one power step\n  10: a power step time is 10ms */
    URfFhcBandParamV3  band_param[UL1TST_WCDMA_BAND_SUPPORT_V3];   /**< datailed calibration information for WCDMA */
} URfTestCmdFhcV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_FhcV3_r
 */
META_RESULT  __stdcall META_3Grf_FhcV3(unsigned int ms_timeout, const URfTestCmdFhcV3* req);

/**
 * \ingroup WCDMA
 * \details For triggering the WCDMA FHC flow
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req URfTestCmdFhcV3 structure is for FHC setting 
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retvalMETA_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retvalMETA_FAILED The requested operation was unsuccessful.
 */
META_RESULT  __stdcall META_3Grf_FhcV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdFhcV3* req);

/**
 * \ingroup WCDMAStruct
 * This structure is power detector result
 */
typedef struct
{
 /** The UL UARFCN
  */
    unsigned short     ul_uarfcn;
 /** The power detector result of high mode
  */
    short              pd_value_h;
 /** The power detector result of middle mode
  */
    short              pd_value_m;
 /** The power detector result of low mode
  */
    short              pd_value_l;
} URfFhcPdInfo;
/**
 * \ingroup WCDMAStruct
 * This structure is the RSSI result
 */
typedef struct
{
    unsigned short     dl_uarfcn;      /**< WCDMA DL UARFCN (spec. defined) */
    short              hpm_rssi[UL1TST_HPM_POINT_V3];  /**< The RSSI result of RX high power mode */
    short              lpm_rssi[UL1TST_LPM_POINT_V3];  /**< The RSSI result of RX low power mode */
} URfFhcPathlossInfoV3;
/**
 * \ingroup WCDMAStruct
 * The structure is used to report the calibration result of TX/RX in each band
 */
typedef struct
{
    unsigned char         band;      /**< WCDMA band number(spec. defined) */
    URfFhcPdInfo          pd_result[UL1TST_FHC_FREQUENCY_NUMBER];          /**< The structure of Power Detector result */
    URfFhcPathlossInfoV3  rx_rssi_result[UL1TST_FHC_FREQUENCY_NUMBER];     /**< the structure of RXM RSSI result */
    URfFhcPathlossInfoV3  rxd_rssi_result[UL1TST_FHC_FREQUENCY_NUMBER];    /**< the structure of RXD RSSI result */
} URfFhcBandReportV3;
/**
 * \ingroup WCDMAStruct
 * This structure is used to report the calibration result.
 */
typedef struct
{
    unsigned char         ok;                   /**< the status of calibration; 1:OK, others: Fail */
    unsigned char         band_number;          /**< the number of bands have been calibrated */
    URfFhcBandReportV3    band_report[UL1TST_WCDMA_BAND_SUPPORT_V3];    /**< the structure of calibation result */
} URfTestResultGetFhcReportV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetFhcResultV3_r
 */
META_RESULT  __stdcall META_3Grf_GetFhcResultV3(unsigned int ms_timeout, URfTestResultGetFhcReportV3* cnf);

/**
 * \ingroup WCDMA
 * \details For fetching WCDMA FHC results from target
 *
 * \param [in] meta_handle Context handle to specific target
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] cnf URfTestResultGetFhcReportV3 structure for calibration results
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retvalMETA_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retvalMETA_FAILED The requested operation was unsuccessful.
 */
META_RESULT  __stdcall META_3Grf_GetFhcResultV3_r(const int meta_handle, unsigned int ms_timeout, URfTestResultGetFhcReportV3* cnf);

/**
 * \ingroup WCDMAStruct
 * This structure for user to set the parameter of target and then to get the RSSI
 */
typedef struct
{
  /** 
   * Hardware auto-gain control flag\n
   *  1: Open\n
   *  0: Close
   */
    unsigned char  hwAGC;
    unsigned char  rx_elna_bypass;   /**< target RXM eLNA bypass setting */
    unsigned char  rxd_elna_bypass;  /**< target RXD eLNA bypass setting */
  /**
   * For continuous flag\n
   *  1: Open\n
   *  0: Close
   */
    unsigned char  conti_rssi;
    unsigned char  rx_elna_mode;     /**< target RXM eLNA mode setting */
    unsigned char  rxd_elna_mode;    /**< target RXD eLNA mode setting */
    
  /** 
   * target teperature setting (enumeration):\n
   *  0: force temperature region to be region-0,        Temp < -10 deg-C\n
   *  1: force temperature region to be region-1, -10 <= Temp <   5 deg-C\n
   *  2: force temperature region to be region-2,   5 <= Temp <  20 deg-C\n
   *  3: force temperature region to be region-3,  20 <= Temp <  35 deg-C\n
   *  4: force temperature region to be region-4,  35 <= Temp <  55 deg-C\n
   *  5: force temperature region to be region-5,  55 <= Temp <  70 deg-C\n
   *  6: force temperature region to be region-6,  70 <= Temp <  85 deg-C\n
   *  7: force temperature region to be region-7,  85 <= Temp\n
   *  255: the teperature value decides by hardware measured
   */
    unsigned char  temperature;
  /** 
   * The antenna path setting (enumeration):\n
   *  1:RXM\n
   *  2:RXD\n
   *  3:RXM+XRD
   */
    unsigned char  antenna_path;
    unsigned char  lpm_mode;            /**< LPM mode flag */
    unsigned short uarfcn;              /**< WCDMA DL UARFCN (spec. defined) */
    unsigned short rx_gain;             /**< RXM RF gain setting*/
    unsigned short rxd_gain;            /**< RXD RF gain setting*/
    unsigned short rx_digital_gain;     /**< RXM digital gain setting */
    unsigned short rxd_digital_gain;    /**< RXD digital gain setting */
} URfTestCmdGetRssiV3;
/**
 * \ingroup WCDMAStruct
 * This structure reports RSSI result
 */
typedef struct
{
    unsigned char  ok;               /**< the status of getting RSSI; 1: OK, other values: Fail */
    unsigned char  rx_elna_bypass;   /**< RXM eLNA bypass */
    unsigned char  rxd_elna_bypass;  /**< RXD eLNA bypass */
    unsigned char  rx_lna_mode;      /**< RXM LNA mode */
    unsigned char  rxd_lna_mode;     /**< RXD LNA mode */
    unsigned short uarfcn;           /**< WCDMA DL UARFCN (spec. defined) */
    short          rx_rssi;          /**< the RSSI result of RXM */
    short          rxd_rssi;         /**< the RSSI result of RXD */ 
    unsigned short rx_used_gain;     /**< the used RF gain of RXM */
    unsigned short rxd_used_gain;    /**< the used RF gain of RXD */
} URfTestResultGetRssiV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRssiV3_r
 */
META_RESULT  __stdcall META_3Grf_GetRssiV3(unsigned int ms_timeout, const URfTestCmdGetRssiV3* req, URfTestResultGetRssiV3* cnf);

/**
 * \ingroup WCDMA
 * \details For triggering the WCDMA RX RSSI test
 *
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req setting parameter to get RSSI
 * \param [out] cnf the report of RSSI result
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retvalMETA_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retvalMETA_FAILED The requested operation was unsuccessful.
 */
META_RESULT  __stdcall META_3Grf_GetRssiV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetRssiV3* req, URfTestResultGetRssiV3* cnf);

typedef struct
{
    unsigned char   rx_elna_bypass;
    unsigned char   rxd_elna_bypass;
    unsigned char   antenna_path;
    unsigned char   lpm_mode;
    unsigned char   rx_elna_mode;
    unsigned char   rxd_elna_mode;
    unsigned char   rx_cal_sequency;
    short           rx_dl_power;
} URfTestCmdPwrToGainV3;
typedef struct
{
    unsigned char   ok;
    unsigned short  rx_digital_gain;
    unsigned short  rxd_digital_gain;
    unsigned short  rx_rf_gain;
    unsigned short  rxd_rf_gain;
} URfTestResultPwrToGainV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GainSelectFromPowerV3_r
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromPowerV3(unsigned int ms_timeout, const URfTestCmdPwrToGainV3* req, URfTestResultPwrToGainV3* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromPowerV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdPwrToGainV3* req, URfTestResultPwrToGainV3* cnf);
typedef struct
{
    unsigned char   rx_elna_bypass;
    unsigned char   rxd_elna_bypass;
    unsigned char   band;
    unsigned char   antenna_path;
    unsigned char   lpm_mode;
    unsigned char   rx_lna_mode;
    unsigned char   rxd_lna_mode;
    unsigned char   rx_elna_mode;
    unsigned char   rxd_elna_mode;
} URfTestCmdLnaToGainV3;
typedef struct
{
    unsigned char   ok;
    unsigned short  rx_digital_gain;
    unsigned short  rxd_digital_gain;
    unsigned short  rx_rf_gain;
    unsigned short  rxd_rf_gain;
    short           dl_power;
} URfTestResultLnaToGainV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GainSelectFromLnaModeV3_r
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromLnaModeV3(unsigned int ms_timeout, const URfTestCmdLnaToGainV3* req, URfTestResultLnaToGainV3* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromLnaModeV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdLnaToGainV3* req, URfTestResultLnaToGainV3* cnf);
typedef struct
{
    unsigned char      rxm_band_num;
    unsigned char      rxd_band_num;
    unsigned char      tx_band_num;
    unsigned char      rxm_cal_band[UL1TST_WCDMA_BAND_SUPPORT_V3];
    unsigned char      rxd_cal_band[UL1TST_WCDMA_BAND_SUPPORT_V3];
    unsigned char      tx_cal_band[UL1TST_WCDMA_BAND_SUPPORT_V3];
} URfTestCmdGetRxTxCalDataV3;
/**
 * \ingroup WCDMAStruct
 */
typedef struct
{
    unsigned char      rxm_count;
    unsigned char      rxd_count;
    unsigned char      tx_count;
    URfPathlossV3      rxm_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V3];
    URfPathlossV3      rxd_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V3];
    URfTestTXDataItem  tx_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V3];
} URfTestResultGetRxTxCalDataV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRxTxCalibrationDataV3_r
 */
META_RESULT  __stdcall META_3Grf_GetRxTxCalibrationDataV3(unsigned int ms_timeout, const URfTestCmdGetRxTxCalDataV3* req, URfTestResultGetRxTxCalDataV3* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetRxTxCalibrationDataV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetRxTxCalDataV3* req, URfTestResultGetRxTxCalDataV3* cnf);
/**
 * \ingroup WCDMAStruct
 * This structure contain the TX and RX calibration data and update setting
 */
typedef struct
{
  /** 
   * The flag is for deciding whether the calibration need to update to NVRAM\n
   *  TRUE  : need
   *  FALSE : don't need
   */
    unsigned char      is_uplate_to_NVRAM;
    unsigned char      rxm_count;   /**< the number of bands needing to update RXM calibration data */
    unsigned char      rxd_count;   /**< the number of bands needing to update RXD calibration data */
    unsigned char      tx_count;    /**< the number of bands needing to update TX calibration data */
    URfPathlossV3      rxm_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V3];    /**< the structure of RXM calibration data */
    URfPathlossV3      rxd_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V3];    /**< the structure of RXD calibration data */
    URfTestTXDataItem  tx_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V3];     /**< the structure of TX calibration data */
} URfTestCmdSetRxTxCalDataV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetRxTxCalibrationDataV3_r
 */
META_RESULT  __stdcall META_3Grf_SetRxTxCalibrationDataV3(unsigned int ms_timeout, const URfTestCmdSetRxTxCalDataV3* req);

/**
 * \ingroup WCDMA
 * \details For updating WCDMA calibration results into target
 *
 * \param [in] meta_handle context handle to specific target
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req TX and RX calibration data to be updated to target
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT  __stdcall META_3Grf_SetRxTxCalibrationDataV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetRxTxCalDataV3* req);
#define URfTestResultRscpV3 URfTestResultRSCP
typedef struct
{
    unsigned short  dl_freq;    /**< Specific dl_freq to do cell search. Valid if pscan_before_cell_search=F. */
} URfTestCmdRscpV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_RscpV3_r
 */
META_RESULT  __stdcall META_3Grf_RscpV3(unsigned int ms_timeout, URfTestCmdRscpV3* req, URfTestResultRscpV3* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_RscpV3_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdRscpV3* req, URfTestResultRscpV3* cnf);
#define URfTestResultAfcV3 URfTestResultAFC_Ex
typedef struct
{
    short           dl_freq;    /**< Specific dl_freq to do cell search. Valid if pscan_before_cell_search=F. */
    short           afc_dac;
} URfTestCmdAfcV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_AfcV3_r
 */
META_RESULT  __stdcall META_3Grf_AfcV3(unsigned int ms_timeout, URfTestCmdAfcV3* req, URfTestResultAfcV3* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_AfcV3_r(const int meta_handle, unsigned int ms_timeout, URfTestCmdAfcV3* req, URfTestResultAfcV3* cnf);
typedef enum
{
    URF_FIX_PGA_GAIN_NO_ABILITY  = 0,
    URF_FIX_PGA_GAIN_12B         = 1,
    URF_FIX_PGA_GAIN_12A         = 2,
    URF_FIX_PGA_GAIN_ALGO_ENABLE = 3,
    URF_FIX_PGA_GAIN_INVALID
} URF_FIX_PGA_GAIN_T;
typedef enum
{
   URF_LOW_POWER_CAL_NO_CALIBRATION  = 0,
   URF_LOW_POWER_CAL_CALIBRATION     = 1,
   URF_LOW_POWER_CAL_INVALID         = 2,
} URF_LOW_POWER_CAL_T;
typedef struct
{
    unsigned char fix_pga_gain;
    unsigned char is_calibrated;
} URfTestCmdLowPowerCal;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_LowPowerCalV3_r
 */
META_RESULT  __stdcall META_3Grf_LowPowerCalV3(unsigned int ms_timeout, const URfTestCmdLowPowerCal* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_LowPowerCalV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdLowPowerCal* req);
#define UL1TST_WCDMA_BAND_SUPPORT_V5 8
#define UL1TST_HPM_POINT_V5 7
#define UL1TST_LPM_POINT_V5 7
#define UL1TST_GAIN_MODE_POINT_V5 (UL1TST_HPM_POINT_V5+UL1TST_LPM_POINT_V5)
typedef struct
{
    unsigned char   cal_band_number;
    unsigned char   cal_band[UL1TST_WCDMA_BAND_SUPPORT_V5]; // band 1 = 1
} URfTestCmdGetMdCalInfoV5;
typedef struct
{
    unsigned char   band;
    unsigned char   rx_elna_mode;
    unsigned char   rxd_elna_mode;
    unsigned char   cal_point_hpm;
    unsigned char   cal_point_lpm;
    unsigned char   rx_cal_sequency[UL1TST_GAIN_MODE_POINT_V5];
    unsigned char   rx_elna_bypass[UL1TST_GAIN_MODE_POINT_V5];
    unsigned char   rxd_elna_bypass[UL1TST_GAIN_MODE_POINT_V5];
    short           rx_cal_dl_power_min[UL1TST_GAIN_MODE_POINT_V5];
    short           rx_cal_dl_power_max[UL1TST_GAIN_MODE_POINT_V5];
    short           rx_cal_dl_power[UL1TST_GAIN_MODE_POINT_V5];
    unsigned char   rx_lna_mode[UL1TST_GAIN_MODE_POINT_V5];
    unsigned char   rxd_lna_mode[UL1TST_GAIN_MODE_POINT_V5];
    unsigned char   rx_location_idx[UL1TST_GAIN_MODE_POINT_V5];
    unsigned char   rxd_location_idx[UL1TST_GAIN_MODE_POINT_V5];
    unsigned char   rx_gain_table;     //0:18dB  1:13.5dB
    unsigned char   rxd_gain_table;    //0:18dB  1:13.5dB
} URfCalBandInfoV5;
typedef struct
{
    unsigned short    support_band_number;
    URfCalBandInfoV5  cal_band_info_v5[UL1TST_WCDMA_BAND_SUPPORT_V5];
} URfTestResultGetMdCalInfoV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetCalInfoV5_r
 */
META_RESULT  __stdcall META_3Grf_GetCalInfoV5(unsigned int ms_timeout, const URfTestCmdGetMdCalInfoV5 *req, URfTestResultGetMdCalInfoV5* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetCalInfoV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetMdCalInfoV5 *req, URfTestResultGetMdCalInfoV5* cnf);
#define UL1TST_MAX_RF_LNA_MODE_NUM_V5  (UL1TST_MAX_RF_LNA_MODE_NUM_V3)
#define UL1TST_FHC_POINT_V5 (UL1TST_HPM_POINT_V5+UL1TST_LPM_POINT_V5)
typedef URfLnaPathlossV3 URfLnaPathlossV5;
typedef URfPathlossV3 URfPathlossV5;
typedef struct
{
    unsigned char      band;
    unsigned char      freq_count;
    unsigned char      pwr_count;
    unsigned char      hpm_cal_point;
    unsigned char      lpm_cal_point;
    unsigned char      rx_elna_mode;
    unsigned char      rxd_elna_mode;
    unsigned char      is_lpm[UL1TST_FHC_POINT_V5];
    unsigned char      rx_elna_bypass[UL1TST_FHC_POINT_V5];
    unsigned char      rxd_elna_bypass[UL1TST_FHC_POINT_V5];
    unsigned char      rx_cal_sequency[UL1TST_FHC_POINT_V5];
    unsigned char      pa_mode[UL1TST_FHC_POINT_V5];
    unsigned char      vga_dac_tpc_idx[UL1TST_FHC_POINT_V5];
    unsigned char      pa_section[UL1TST_FHC_POINT_V5];
    unsigned short     pa_gain[UL1TST_FHC_POINT_V5];
    short              rx_cal_dl_power[UL1TST_FHC_POINT_V5];
    unsigned short     dl_uarfcn[UL1TST_FHC_FREQUENCY_NUMBER];
    unsigned short     ul_uarfcn[UL1TST_FHC_FREQUENCY_NUMBER];
    unsigned char      rx_gain_table;     //0:18dB  1:13.5dB
    unsigned char      rxd_gain_table;    //0:18dB  1:13.5dB
    URfTestTXDataItem  tx_cal_data_info;
    URfPathlossV5      rxm_cal_data_info;
    URfPathlossV5      rxd_cal_data_info;
} URfFhcBandParamV5;
typedef struct
{
    unsigned char      cal_band_number;
    unsigned char      cal_band[UL1TST_WCDMA_BAND_SUPPORT_V5];
    unsigned char      antenna_setting;
    unsigned char      step_duration;
    URfFhcBandParamV5  band_param[UL1TST_WCDMA_BAND_SUPPORT_V5];
} URfTestCmdFhcV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_FhcV5_r
 */
META_RESULT  __stdcall META_3Grf_FhcV5(unsigned int ms_timeout, const URfTestCmdFhcV5* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_FhcV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdFhcV5* req);
typedef struct
{
    unsigned short     dl_uarfcn;
    short              hpm_rssi[UL1TST_HPM_POINT_V5];
    short              lpm_rssi[UL1TST_LPM_POINT_V5];
} URfFhcPathlossInfoV5;
typedef struct
{
    unsigned char         band;
    URfFhcPdInfo          pd_result[UL1TST_FHC_FREQUENCY_NUMBER];
    URfFhcPathlossInfoV5  rx_rssi_result[UL1TST_FHC_FREQUENCY_NUMBER];
    URfFhcPathlossInfoV5  rxd_rssi_result[UL1TST_FHC_FREQUENCY_NUMBER];
} URfFhcBandReportV5;
typedef struct
{
    unsigned char         ok;
    unsigned char         band_number;
    URfFhcBandReportV5    band_report[UL1TST_WCDMA_BAND_SUPPORT_V5];
} URfTestResultGetFhcReportV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetFhcResultV5_r
 */
META_RESULT  __stdcall META_3Grf_GetFhcResultV5(unsigned int ms_timeout, URfTestResultGetFhcReportV5* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetFhcResultV5_r(const int meta_handle, unsigned int ms_timeout, URfTestResultGetFhcReportV5* cnf);
typedef struct
{
    unsigned char      rxm_band_num;
    unsigned char      rxd_band_num;
    unsigned char      tx_band_num;
    unsigned char      rxm_cal_band[UL1TST_WCDMA_BAND_SUPPORT_V5];
    unsigned char      rxd_cal_band[UL1TST_WCDMA_BAND_SUPPORT_V5];
    unsigned char      tx_cal_band[UL1TST_WCDMA_BAND_SUPPORT_V5];
} URfTestCmdGetRxTxCalDataV5;
typedef struct
{
    unsigned char      rxm_count;
    unsigned char      rxd_count;
    unsigned char      tx_count;
    URfPathlossV5      rxm_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V5];
    URfPathlossV5      rxd_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V5];
    URfTestTXDataItem  tx_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V5];
} URfTestResultGetRxTxCalDataV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRxTxCalibrationDataV5_r
 */
META_RESULT  __stdcall META_3Grf_GetRxTxCalibrationDataV5(unsigned int ms_timeout, const URfTestCmdGetRxTxCalDataV5* req, URfTestResultGetRxTxCalDataV5* cnf);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetRxTxCalibrationDataV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetRxTxCalDataV5* req, URfTestResultGetRxTxCalDataV5* cnf);
typedef struct
{
    unsigned char      is_uplate_to_NVRAM;
    unsigned char      rxm_count;
    unsigned char      rxd_count;
    unsigned char      tx_count;
    URfPathlossV5      rxm_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V5];
    URfPathlossV5      rxd_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V5];
    URfTestTXDataItem  tx_cal_data[UL1TST_WCDMA_BAND_SUPPORT_V5];
} URfTestCmdSetRxTxCalDataV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetRxTxCalibrationDataV5_r
 */
META_RESULT  __stdcall META_3Grf_SetRxTxCalibrationDataV5(unsigned int ms_timeout, const URfTestCmdSetRxTxCalDataV5* req);
/**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetRxTxCalibrationDataV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetRxTxCalDataV5* req);
typedef struct
{
    unsigned short  enable_iq_dump;  // enable or disable IQ dump mode.
    unsigned short  ant_idx;         // 0=RX main antenna, 1=RX diversity antenna.
} URfTestCmdTriggerIqDumpModeV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_TriggerIqDumpModeV3_r
 */
META_RESULT  __stdcall META_3Grf_TriggerIqDumpModeV3(unsigned int ms_timeout, const URfTestCmdTriggerIqDumpModeV3* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_TriggerIqDumpModeV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdTriggerIqDumpModeV3* req);
typedef struct
{
    short i_data;
    short q_data;
} URfIqRawData;
#define UL1TST_IQ_RAW_DATA_NUM_V3 (20000)
typedef struct
{
    unsigned short iq_data_length;
    URfIqRawData iq_raw_data[UL1TST_IQ_RAW_DATA_NUM_V3];
} URfTestResultGetIqDumpResultV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetIqDumpResultV3_r
 */
META_RESULT  __stdcall META_3Grf_GetIqDumpResultV3(unsigned int ms_timeout, URfTestResultGetIqDumpResultV3* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetIqDumpResultV3_r(const int meta_handle, unsigned int ms_timeout, URfTestResultGetIqDumpResultV3* cnf);
typedef struct
{
    unsigned short  band;                //UMTS band
    unsigned short  subband_idx;         //which sub-band that user want to fill
    unsigned short  max_uarfcn;          //max uarfcn of this subband
    unsigned char   ant_idx;             //which antenna should be write in this command. 0: RX Main, 1:RX Div
    unsigned char   rfeq_enable;         //RFEQ enable or not.
    short           rfeq_coef_real[7];   //RFEQ real part coefficient. 7 taps.
    short           rfeq_coef_imag[7];   //RFEQ image part coefficient. 7 taps.
} URfEqSubbandData;
#define UL1TST_RFEQ_SUBBNAD_DATA_NUM_V3 (UL1TST_WCDMA_BAND_SUPPORT_V3*UL1TST_FHC_FREQUENCY_NUMBER*2)
typedef struct
{
    unsigned short      rfeq_set_num;
    URfEqSubbandData    subbandData[UL1TST_RFEQ_SUBBNAD_DATA_NUM_V3];
} URfTestCmdSetRfEqSubbandResultV3;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetRfEqSubbandResultV3_r
 */
META_RESULT  __stdcall META_3Grf_SetRfEqSubbandResultV3(unsigned int ms_timeout, const URfTestCmdSetRfEqSubbandResultV3* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetRfEqSubbandResultV3_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetRfEqSubbandResultV3* req);
/**
 * \ingroup WCDMAStruct
 * This structure is for user to set the parameter and then get the RSSI result
 */
typedef struct
{
  /**
   * the hardware auto gain control flag\n
   *  1: Open\n
   *  0: Close
   */
    unsigned char  hwAGC;
    unsigned char  rx_elna_bypass;     /**< target RXM eLNA bypass setting */
    unsigned char  rxd_elna_bypass;    /**< target RXD eLNA bypass setting */
  /**
   * the continuous RSSI flag\n
   *  1: Open\n
   *  0: Close
   */
    unsigned char  conti_rssi;
    unsigned char  rx_elna_mode;      /**< target RXM eLNA mode setting */
    unsigned char  rxd_elna_mode;     /**< target RXD eLNA mode setting */
  /** 
   * the target  teperature setting (enumeration):\n
   *  0: force temperature region to be region-0,        Temp < -10 deg-C\n
   *  1: force temperature region to be region-1, -10 <= Temp <   5 deg-C\n
   *  2: force temperature region to be region-2,   5 <= Temp <  20 deg-C\n
   *  3: force temperature region to be region-3,  20 <= Temp <  35 deg-C\n
   *  4: force temperature region to be region-4,  35 <= Temp <  55 deg-C\n
   *  5: force temperature region to be region-5,  55 <= Temp <  70 deg-C\n
   *  6: force temperature region to be region-6,  70 <= Temp <  85 deg-C\n
   *  7: force temperature region to be region-7,  85 <= Temp\n
   *  255: the teperature value decides by hardware measured
   */
    unsigned char  temperature;
  /**
   * the antenna path setting (enumeration):\n
   *  1:RXM\n
   *  2:RXD\n
   *  3:RXM+XRD
   */
    unsigned char  antenna_path;
    unsigned char  lpm_mode;           /**< LPM mode flag */
    unsigned short uarfcn;             /**< WCDMA DL UARFCN(spec. defined) */
    unsigned short rx_gain;            /**< RXM RF gain setting */ 
    unsigned short rxd_gain;           /**< RXD RF gain setting */
    unsigned short rx_digital_gain;    /**< RXM digital gain setting */ 
    unsigned short rxd_digital_gain;   /**< RXD digital gain setting */
    unsigned char rx_gain_table;       /**< RXM gain table indicator; 0:18dB, 1:13.5dB */
    unsigned char rxd_gain_table;      /**< RXD gain table indicator; 0:18dB, 1:13.5dB */
} URfTestCmdGetRssiV5;;
typedef URfTestResultGetRssiV3 URfTestResultGetRssiV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRssiV5_r
 */
META_RESULT  __stdcall META_3Grf_GetRssiV5(unsigned int ms_timeout, const URfTestCmdGetRssiV5* req, URfTestResultGetRssiV5* cnf);

/**
 * \ingroup WCDMA
 * \details For getting the WCDMA RX RSSI test result
 *
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req setting parameter to get RSSI
 * \param [out] cnf the RSSI test result
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT  __stdcall META_3Grf_GetRssiV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetRssiV5* req, URfTestResultGetRssiV5* cnf);

typedef struct
{
    unsigned char   rx_elna_bypass;
    unsigned char   rxd_elna_bypass;
    unsigned char   antenna_path;
    unsigned char   lpm_mode;
    unsigned char   rx_elna_mode;
    unsigned char   rxd_elna_mode;
    unsigned char   rx_cal_sequency;
    short           rx_dl_power;
    unsigned char   rx_gain_table;   //0:18dB  1:13.5dB
    unsigned char   rxd_gain_table;  //0:18dB  1:13.5dB
} URfTestCmdPwrToGainV5;
typedef URfTestResultPwrToGainV3 URfTestResultPwrToGainV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GainSelectFromPowerV5_r
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromPowerV5(unsigned int ms_timeout, const URfTestCmdPwrToGainV5* req, URfTestResultPwrToGainV5* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromPowerV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdPwrToGainV5* req, URfTestResultPwrToGainV5* cnf);
typedef struct
{
    unsigned char   rx_elna_bypass;
    unsigned char   rxd_elna_bypass;
    unsigned char   band;
    unsigned char   antenna_path;
    unsigned char   lpm_mode;
    unsigned char   rx_lna_mode;
    unsigned char   rxd_lna_mode;
    unsigned char   rx_elna_mode;
    unsigned char   rxd_elna_mode;
    unsigned char   rx_gain_table;   //0:18dB  1:13.5dB
    unsigned char   rxd_gain_table;  //0:18dB  1:13.5dB
} URfTestCmdLnaToGainV5;
typedef URfTestResultLnaToGainV3 URfTestResultLnaToGainV5;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GainSelectFromLnaModeV5_r
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromLnaModeV5(unsigned int ms_timeout, const URfTestCmdLnaToGainV5* req, URfTestResultLnaToGainV5* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GainSelectFromLnaModeV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdLnaToGainV5* req, URfTestResultLnaToGainV5* cnf);

typedef struct
{   
     bool          updateToNvram;
     unsigned char  band;
     unsigned short ul_uarfcn;
     short         offset;
} URfTestCmdSetTXpowerOffsetV5;

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetTxPowerOffsetV5_r
 */
META_RESULT  __stdcall META_3Grf_SetTxPowerOffsetV5(unsigned int ms_timeout, const URfTestCmdSetTXpowerOffsetV5* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetTxPowerOffsetV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetTXpowerOffsetV5* req);

typedef struct
{   
    unsigned char band;
} URfTestCmdGetTXpowerOffsetV5;

typedef struct
{   
    unsigned char band;
    short        offset;
} URfTestResultGetTXpowerOffsetV5;

/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetTxPowerOffsetV5_r
 */
META_RESULT  __stdcall META_3Grf_GetTxPowerOffsetV5(unsigned int ms_timeout, const URfTestCmdGetTXpowerOffsetV5* req, URfTestResultGetTXpowerOffsetV5* cnf);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_GetTxPowerOffsetV5_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetTXpowerOffsetV5* req, URfTestResultGetTXpowerOffsetV5* cnf);

//--------------------------------------------------------------------------//
//  RF Testing                                                              //
//--------------------------------------------------------------------------//
//-----------------------------------------------------//
//  RF Testing: data structure definition              //
//-----------------------------------------------------//
/**
  * \ingroup GSMStruct
  * GSM ARFCN
  */
typedef short   ARFCN;

/**
  * \ingroup GSMStruct
  * Gain (in unit of 1/8 dB)
  */
typedef short   Gain;

/**
  * \ingroup GSMStruct
  * BSIC (spec. defined)
  */
typedef char    BSIC;

/**
  * \ingroup GSMStruct
  * Power (in unit of 1/8 dB)
  */
typedef short   Power;

/**
  * \ingroup GSMStruct
  * Timing advance value (in unit of QB)
  */
typedef unsigned char   TimingAdvance;

/**
  * \ingroup GSMStruct
  * Training Sequence Code (spec. defined)
  */
typedef char    TSC;

/**
  * \ingroup GSMStruct
  * Timeslot number (0~7)
  */
typedef char    TimeSlot;

// RF ID
#define  RF_ID_UNKNOWN     0x00000000
#define  RF_ID_BRIGHT2     0x00000001
#define  RF_ID_BRIGHT4     0x00000002
#define  RF_ID_AERO        0x00000004
#define  RF_ID_AERO1PLUS   0x00000008
#define  RF_ID_POLARIS1    0x00000010
#define  RF_ID_POLARIS2    0x00000020
#define  RF_ID_SKY74045    0x00000040
#define  RF_ID_BRIGHT5P    0x00000080
#define  RF_ID_MT6116      0x00000100
#define  RF_ID_MT6119      0x00000200
#define  RF_ID_MT6119C     0x00000400
#define  RF_ID_MT6129A     0x00000800
#define  RF_ID_MT6129B     0x00001000
#define  RF_ID_MT6129C     0x00002000
#define  RF_ID_MT6129D     0x00004000
#define  RF_ID_MT6139B     0x00008000
#define  RF_ID_MT6139C     0x00010000
#define  RF_ID_MT6140A     0x00020000
#define  RF_ID_SKY74117    0x00040000
#define  RF_ID_SKY74400    0x00080000
#define  RF_ID_AERO2       0x00100000
#define  RF_ID_MT6140B     0x00200000
#define  RF_ID_ALICEG2S    0x00400000
#define  RF_ID_MT6139E     0x00800000
#define  RF_ID_SKY74137    0x01000000
#define  RF_ID_MT6140C     0x02000000
#define  RF_ID_GRF6201     0x04000000
#define  RF_ID_IRFS3001    0x08000000
#define  RF_ID_MT6140D     0x10000000
#define  RF_ID_AG2550      0x10000001
#define  RF_ID_AERO2E      0x10000002
#define  RF_ID_AD6548      0x10000005
#define  RF_ID_AD6546      0x10000006
#define  RF_ID_CMOSEDGE    0x10000007
#define  RF_ID_MTKSOC1     0x10000008
#define  RF_ID_MT6256RF    0x10000009
#define  RF_ID_MT6251RF    0x1000000a
#define  RF_ID_MT6252RF    0x1000000c
#define  RF_ID_MT6162      0x1000000d
#define  RF_ID_MT6163      0x1000000e
#define  RF_ID_MT6255RF    0x1000000f
#define  RF_ID_MT6250RF    0x10000010
#define  RF_ID_MT6280RF    0x10000011
#define  RF_ID_MT6167RF    0x10000012
#define  RF_ID_MT6260RF    0x10000013
#define  RF_ID_MT6166RF    0x10000014
#define  RF_ID_MT6169RF    0x10000015
#define  RF_ID_MT6165RF    0x10000016
#define  RF_ID_MT6261RF    0x10000017
#define  RF_ID_MT6580RF    0x10000018
#define  RF_ID_MT6176RF    0x10000019
#define  RF_ID_MT6179RF    0x1000001A
#define  RF_ID_MT6570RF    0x1000001B
#define  RF_ID_MT6177      0x1000001C
#define  RF_ID_MT6177M     0x1000001D
#define  RF_ID_MT6185      0x1000001e 
#define  RF_ID_MT6186      0x1000001f 
/**
  * \ingroup GSMStruct
  * GSM Band
  */
typedef enum
{
    FrequencyBand400 = 0,            ///< GSM 450/480 band
    FrequencyBand850 = 1,            ///< GSM 850 band
    FrequencyBand900 = 2,            ///< GSM 900 band
    FrequencyBand1800 = 3,           ///< DCS 1800 band
    FrequencyBand1900 = 4,           ///< PCS 1900 band

    FrequencyBandCount               ///< count of supported bands
} FrequencyBand;

typedef struct
{
    ARFCN           arfcn;              ///< Absolute radio frequency channel number
    char            sampleNoPerFrame;   ///< number of samples per frame
    Gain            gain;               ///< Gain that should be used in power management
    short           frames;             ///< number of frames
} RfPm_Req;

typedef struct
{
    unsigned char   valid;              // if valid != zero, it means the extra info is meaningful.
    // otherwise, the extra info should be ignore.
    int             iOffset;
    int             qOffset;
    int             validSamples;
} RfPmExtraInfo_T;

/**
 * \ingroup GSMStruct
 * This request structure is used for Power scan specified if flag
 */
typedef struct
{
    /// original power scan request
    RfPm_Req        m_Pm;
    /// if flag used for specifying the if flag in power scan (override the if flag setting)
    char   m_IfFlag;
} RfIfPm_Req;

typedef struct
{
    int             power;              ///< average power
    int             deviation;          ///< deviation of power measurement
    Gain            usedGain;           ///< Gain that is used
    unsigned char   ok;                 ///< status
    RfPmExtraInfo_T extra_info;         ///< extra info
} RfPm_Cnf;

typedef struct
{
    ARFCN           arfcn;              ///< absolute radio frequency channel number
    short           dacValue;           ///< AFC DAC value
    Gain            gain;               ///< gain used for AFC testing
    short           testNumber;         ///< test number
} RfAfc_Req;

typedef struct
{
    short           fcb_ok_number;      ///< successful number of FCB decoded
    int             freqOffset;         ///< average frequency error
    int             deviation;          ///< deviation of frequency error
    unsigned char   ok;                 ///< status
} RfAfc_Cnf;

/**
 * \ingroup GSMStruct
 * This enum defines Tx data pattern
 */
typedef enum
{
    AB_TX_RANDOM_WITH_SYNC_SEQ       ///< access burst random data
    , NB_TX_ALL_ZEROS_WITHOUT_TSC    ///< all zero bit data without trianing sequence (eX.000000....)
    , NB_TX_ALL_ONES_WITHOUT_TSC     ///< all one bit data without trianing sequence (eX.111111....)
    , NB_TX_ALTER_BITS_WITHOUT_TSC   ///< Alter one and zero bit data without trianing sequence (eX.01010101....)
    , NB_TX_RANDOM_WITH_TSC          ///< random data with trianing sequence  (eX. 10110..|TSC|11010..) (data will change per frame)
    , NB_TX_PATTERN_WITHOUT_TSC      ///< manual enter data without trianing sequence in RF Tool
    , NB_TX_FIXED_RANDOM_WITH_TSC     ///< random data with trianing sequence (eX. 00110..|TSC|11010..) (data will fix per frame)
    , NB_TX_FIXED_ALL_ZEROS_WITH_TSC  ///< zero bit data with trianing sequence (eX.00000..|TSC|00000..)
    , NB_TX_FIXED_ALTER_BITS_WITH_TSC  ///< Alter bit data with trianing sequence (eX.010101..|TSC|010101..)
    , NB_TX_FIXED_ALL_ONES_WITH_TSC    ///< zero bit data with trianing sequence (eX.11111..|TSC|11111..)
    , NB_TX_FIXED_OE_PATTERN_WITH_TSC  ///< phase out item for legacy RF chip
} APCTxPattern;

typedef struct
{
    ARFCN           arfcn;              ///< Absolute radio frequency channel number
    BSIC            bsic;               ///< bsic value used in transmission
    Power           power;              ///< Tx power in the unit of PCL
    short           frames;             ///< the number of frames NB should transmit
    short           dacValue;           ///< AFC DAC value
    APCTxPattern    burstTypeNB;
} RfNbtx_Req;

typedef struct
{
    ARFCN           arfcn;              ///< Absolute radio frequency channel number
    Gain            gain;               ///< Gain that should be used
    unsigned char   OnOff;              ///< On or off
} RfCnRx_Req;

typedef enum
{
    CONT_TX_ALL_ZEROS
    , CONT_TX_ALL_ONES
    , CONT_TX_ALTERNATE_BITS
    , CONT_TX_PSEUDO_RANDOM
    , CONT_TX_PATTERN_WITHOUT_TSC
} ContTxPattern;

typedef struct
{
    ARFCN           arfcn;              ///< Absolute radio frequency channel number
    ContTxPattern   pattern;
    unsigned char   OnOff;              ///< On or off
} RfCnTx_Req;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
} RfSetBBTXCfg_Req;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
    char    TxCalbias;
    char    TxIQSwap;
    char    TxCMV;
    char    TxGain;
    char    TxCalrcsel;
} RfBBTXCfg2;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
    char    TxCalbias;
    char    TxIQSwap;
    char    TxCMV;
    char    TxGain;
    char    TxCalrcsel;
    char    TxPhasesel;
} RfBBTXCfg3;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
    char    TxCalbias;
    char    TxIQSwap;
    char    TxCMV;
    char    TxGain;
    char    TxCalrcsel;
    char    TxPhasesel;
    char    TxCoarseI;
    char    TxCoarseQ;

} RfBBTXCfg4; //RfTestCmdSetBBTXCfg4

typedef struct
{
    unsigned char bbtx_common_mode_voltage;
    unsigned char bbtx_gain;
    unsigned char bbtx_calrcsel;
    unsigned char bbtx_trimI;   // need to set
    unsigned char bbtx_trimQ;   // need to set
    unsigned char bbtx_dccoarseI; // need to set
    unsigned char bbtx_dccoarseQ; // need to set
    unsigned char bbtx_offsetI; // need to set
    unsigned char bbtx_offsetQ; // need to set
    unsigned char bbtx_isCalibrated; // need to set
    int           apc_bat_low_voltage;
    int           apc_bat_high_voltage;
    int           apc_bat_low_temperature;
    int           apc_bat_high_temperature;
    unsigned char bbtx_common_mode_voltage_h;
    unsigned char bbtx_gain_h;
    unsigned char bbtx_calrcsel_h;
    unsigned char bbtx_trimI_h;
    unsigned char bbtx_trimQ_h;
    unsigned char bbtx_dccoarseI_h;
    unsigned char bbtx_dccoarseQ_h;

    unsigned char bbtx_offsetI_h;
    unsigned char bbtx_offsetQ_h;
    unsigned char bbtx_phsel;
    unsigned char bbtx_phsel_h;
} BBTXParameters_T;

/**
 * \ingroup GSMStruct
 * This enum defines CodingScheme, CS1~CS4 for GMSK, MCS1~MCS9 for EPSK
 */
typedef enum
{
    CodingSchemeNone = 0,
    CodingSchemeCS1,
    CodingSchemeCS2,
    CodingSchemeCS3,
    CodingSchemeCS4,
    CodingSchemePRACh8,
    CodingSchemePRACh11,
    CodingSchemeMCS1,
    CodingSchemeMCS2,
    CodingSchemeMCS3,
    CodingSchemeMCS4,
    CodingSchemeMCS5,
    CodingSchemeMCS6,
    CodingSchemeMCS7,
    CodingSchemeMCS8,
    CodingSchemeMCS9,
    CodingSchemeCount,
} CodingScheme;

typedef struct
{
    ARFCN           arfcn;          ///< absolute radio frequency channel number
    BSIC            bsic;           ///< training sequence
    char            timeSlotmask;   ///< time slot mask, slot_1: 0x01, slot_2: 0x02, slot_3: 0x04, slot_4: 0x08
    Power           powerLev[4];    ///< power level for each time slot
    CodingScheme    cs[4];          ///< coding scheme for each time slot
    TimingAdvance   ta;             ///< time advance
    int             frames;         ///< the number of frames should transmit
    short           dacValue;       ///< AFC DAC value
} RfMultiSlotTX_Req;

typedef struct
{
    FrequencyBand   rf_band;
    int             power_level;
    int             apc_dac;
} RfSetRampApcLevel_Req;

typedef struct
{
    short           dacValue;       ///< AFC DAC value
} RfSetAfcDacValue_Req;

typedef struct
{
    int             cap_id;
} RfSetCrystalCfg_Req;

typedef struct
{
    ARFCN           arfcn;          ///< absolute radio frequency channel number
    BSIC            bsic;           ///< training sequence
    char            timeSlotmask;   ///< time slot mask, slot_1: 0x01, slot_2: 0x02, slot_3: 0x04, slot_4: 0x08
    Power           powerLev[4];    ///< power level for each time slot
    CodingScheme    cs[4];          ///< coding scheme for each time slot, MCS1~9 is only valid for EPSK function
    TimingAdvance   ta;             ///< time advance
    int             frames;         ///< the number of frames should transmit
    short           dacValue;       ///< AFC DAC value
    APCTxPattern    pattern;        ///< Tx pattern is only valid for EPSK function
    unsigned short  pattern_data;   ///< if NB_TX_PATTERN_WITHOUT_TSC==pattern, user can input any 16bits value as pattern.
} Rf_MultiSlotTXEx_Req;

typedef struct
{
    unsigned int    id;             ///< 2G RF chip ID please refer RF_ID_XXXX
} RFMod_ID;

typedef enum
{
    MS_GSM = 0
             , MS_GPRS
    , MS_EGPRS_RX_ONLY
    , MS_EGPRS_FULL_FUNCTION
} MS_CAPABILITY_E;

typedef struct
{
    unsigned int    GSM400;         ///< Zero: not support, Non-zero: support
    unsigned int    GSM850;
    unsigned int    GSM900;
    unsigned int    DCS1800;
    unsigned int    PCS1900;
} RFBandSupport_S;

typedef struct
{
    MS_CAPABILITY_E     capability;
    RFBandSupport_S     band_support;
} RfMsCapability_S;

typedef struct
{
    unsigned int    GSM: 1;
    unsigned int    GPRS: 1;
    unsigned int    EDGE_RX: 1;
    unsigned int    EDGE_8PSK_TX: 1;
    unsigned int    Calibration_8PM: 1;
} RfMsCapabilityBits;

typedef struct
{
    unsigned int    GSM400: 1;
    unsigned int    GSM850: 1;
    unsigned int    GSM900: 1;
    unsigned int    DCS1800: 1;
    unsigned int    PCS1900: 1;
} RfMsBandSupportBits;

typedef struct
{
    RfMsCapabilityBits      capability;
    RfMsBandSupportBits     band_support;
} RfMsCapabilityEx_S;


typedef struct
{
    unsigned int    GSM: 1;
    unsigned int    GPRS: 1;
    unsigned int    EDGE_RX: 1;
    unsigned int    EDGE_8PSK_TX: 1;
    unsigned int    Calibration_8PM: 1;
    unsigned int    Calibration_FDT: 1;     // new
    unsigned int    Calibration_33Steps: 1; // new
    unsigned int    NSFT: 1; // NSFT
    unsigned int    AFCType: 1; // AFC Type
    unsigned int    GMSKClosedLoopPowerControl: 1;
    unsigned int    OpenLoopPowerControl: 1;
    unsigned int    ClosedLoopPowerControlTemperature: 1;
    unsigned int    EPSKClosedLoopPowerControl: 1;
    unsigned int    MiddleLowLnaCalibration: 1;
    unsigned int    AuxTempADC: 1;
    unsigned int    BsiTempADC: 1;
} RfMsCapabilityBits_2;

typedef struct
{
    RfMsCapabilityBits_2        capability;
    RfMsBandSupportBits     band_support;
} RfMsCapabilityEx2_S;

typedef struct
{
    unsigned short support_gsm: 1;
    unsigned short support_gprs: 1;
    unsigned short support_edge_rx: 1;
    unsigned short support_epsk_tx: 1;
    unsigned short support_8pm: 1;
    unsigned short support_fhc: 1;
    unsigned short support_nsft: 1;
    unsigned short band_gsm400: 1;
    unsigned short band_gsm850: 1;
    unsigned short band_gsm900: 1;
    unsigned short band_dcs1800: 1;
    unsigned short band_pcs1900: 1;
    /**
     * base on the PS edge switch
     * 0: check the EDGE TX power
     * 1: by pass check
     */
    unsigned short ps_unsupport_edge_tx: 1;
    unsigned short reserved1: 2;
} RfCapabilityItem;


/**
 * Description: get the tx_pcl GMSK and EPSK version from the parameter field
 **/
#define TX_PCL_EPSK_VERSION_MASK (0x7F << 7)
#define GET_EPSK_VERSION(x) (((x) & TX_PCL_EPSK_VERSION_MASK) >> 7)
#define GET_GSM_VERSION(x) ((x) & 0x0001)
//Battery Compensate
/**
 * \ingroup GSMStruct
 * When the sw capability for EDGE Battery Compensation is equal to 1, and in 14-bits paramter, LSB of first 7 bits equals 1.
 * unit conversion for EDGE Battery Compensation becomes as dBm, Otherwise, in 14-bits paramter, LSB of first 7 bits equals 0.,
 * unit conversion for EDGE Battery Compensation do not change (still use weighting)
 */
typedef struct
{
    unsigned short is_capable: 1;
    unsigned short is_mandatory: 1;
    unsigned short parameter: 14;
} RfFactoryModeCalItem;
typedef struct
{
    RfFactoryModeCalItem cap_id; /* 0 */
    RfFactoryModeCalItem afc; /* 1 */
    RfFactoryModeCalItem rx_pathloss; /* 2 */
    RfFactoryModeCalItem tx_pcl; /* 3 */
    RfFactoryModeCalItem tx_subband; /* 4 */
    RfFactoryModeCalItem trx_offset; /* 5 */
    RfFactoryModeCalItem tx_iq; /* 6 */
    RfFactoryModeCalItem tx_fb_dac; /* 7 */
    RfFactoryModeCalItem tx_slope_skew; /* 8 */
    RfFactoryModeCalItem w_coef; /* 9 */
    RfFactoryModeCalItem txpc; /* 10 */
    RfFactoryModeCalItem temp_adc; /* 11 */
    RfFactoryModeCalItem remove_32k_xo; /* 12 */
    RfFactoryModeCalItem co_crystal; /* 13 */
    RfFactoryModeCalItem high_lna_sp; /* 14 */
    RfFactoryModeCalItem mid_lna_sp; /* 15 */
    RfFactoryModeCalItem low_lna_sp; /* 16 */
    //Battery Compensate
    /** for EPSK new feature
     * When the sw capability for EDGE Battery Compensation is equal to 1, and in 14-bits paramter, LSB of first 7 bits equals 1.
     * unit conversion for EDGE Battery Compensation becomes as dBm, Otherwise, in 14-bits paramter, LSB of first 7 bits equals 0.,
     * unit conversion for EDGE Battery Compensation do not change (still use weighting)
     */
    RfFactoryModeCalItem bat_temp_comp; /* 17 */
    RfFactoryModeCalItem dts_gain_cmb; /* 18 */
    //---------------------------------------------------------------------------
    // parameter: 0, capable: 1, mandatory: 1 ==> support FHC double-band combine, but only 50 steps (orignal interface)
    // parameter: 1, capable: 1, mandatory: 1 ==> support FHC double-band combine, but only 100 steps (Big interface)
    //---------------------------------------------------------------------------
    RfFactoryModeCalItem uts_band_cmb; /* 19 */
    //---------------------------------------------------------------------------
    // Temp ADC on TDD mode, use the same NVRAM item of 2G temperature ADC("NVRAM_EF_L1_TEMPERATURE_ADC_LID")
    // When the sw capability for co_temp_adc is equal to 1,
    // it means 2G and TDD use the same NVRAM item of 2G temperature ADC
    // (TDD: "NVRAM_EF_AST_TL1_TEMP_DAC_LID")
    //---------------------------------------------------------------------------
    RfFactoryModeCalItem co_temp_adc; /* 20 */
    //------------------------------------------------------
    // Fill middle/low mode of LNA path loss by high mode result
    //-----------------------------------------------------
    RfFactoryModeCalItem adjustable_lna_mode_pathloss; /* 21 */
    //------------------------------------------------------
    // Indicate the EDGE TX should calibrated by gain rf mechanism
    // parameter: 0, capable: 1, mandatory: 1
    //-----------------------------------------------------
    RfFactoryModeCalItem gain_rf_cal; /* 22 */
    /**
     * Indicate the AP/MD NVRAM check is required or not
     * is_capable: 0: check AP/MD NVRAM, 1: bypass AP/MD NVRAM check
     * is_mandatory: don't care
     * parameter: check capability when is_capable equal to 0
     *      1: GPS co-clock configure correct. Do GPS co-clock.
     *      Others: Error => check WMT.CFG
     **/
    RfFactoryModeCalItem bypass_check_fixafc; /* 23 */
    /**
     * Bit map used to indicate the TADC calibration data can be shared between different RAT
     * the bitmap is defined in parameter part and starts from LSB to MSB
     * new RAT can be extended upto 14 RATs;bits: (0|0|C|Lf|Lt|T|W|G)
     */
    RfFactoryModeCalItem multi_rat_tadc_bitmap; /* 24 */
    /**
     * Bit map used to indicate the AFC calibration data can be shared between different RAT
     * the bitmap is defined in parameter part and starts from LSB to MSB
     * new RAT can be extended upto 14 RATs;bits: (0|0|C|Lf|Lt|T|W|G)
     */
    RfFactoryModeCalItem multi_rat_afc_bitmap; /* 25 */
    /**
     * unsigned short    cal_lna_mode    :4;     // LNA mode(s) need to be calibrated (Bitwise)
     * unsigned short    dup_lna_src     :4;     // Duplicated LNA mode From (Bitwise)
     * unsigned short    dup_lna_dest    :4;     // Duplicated LNA mode To (Bitwise)
     * unsigned short    reserved        :2;
     **/
    RfFactoryModeCalItem reduce_rx_lna_cal; /* 26 */
    /**
     * Indicate the Get temperature info. API is available on the target
     * is_capable: 0: not supported, 1: supported
     * is_mandatory: don't care
     * parameter: don't care
     **/
    RfFactoryModeCalItem temperature_info; /* 27 */
    /**
     * Indicate the Get temperature info. API is available on the target
     * is_capable: 0: not supported, 1: supported
     * is_mandatory: don't care
     * parameter: the band support bit-map from of GSM850, GSM900, DCS1800, PCS1900 (from LSB to MSB)
     **/
    RfFactoryModeCalItem dt_coexistence_info; /* 28 */
    /**
     * Indicate the external temp sensor support.
     * is_capable: 0: not supported, 1: supported
     * is_mandatory: don't care
     * parameter: 0:internal sensor 2:external sensor
     **/
    RfFactoryModeCalItem thermal_sensor_type; /* 29 */
    /**
     * Indicate support list mode NSFT or not.
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: don't care
     **/
    RfFactoryModeCalItem list_mode_nsft; /* 30 */
    /**
     * Indicate world mode id
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: bits: 0|0|Lf|Lt|W|C|T|G
     **/
    RfFactoryModeCalItem worldmode_id_info; /* 31 */
    /**
     * Indicate 32k less afc dac selection
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: bits: don't care
     **/
    RfFactoryModeCalItem crystal_on_pmic_enable; /* 32 */
    /**
     * Indicate subband low weighting calibration
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: bits: [6:0] for LB, [13:7] for HB
     **/
    RfFactoryModeCalItem low_pcl_subband_cal; /* 33 */
    /**
     * Indicate enable extra fb for RX sync
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: don't care
     **/
    RfFactoryModeCalItem fhc_dts_extra_fb_enable; /* 34 */
    /**
     * Indicate set DSP point parameter for sawless mid gain
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     **/
    RfFactoryModeCalItem  sawless_lna_sp; /* 35 */
    /**
     * Indicate L1 nvram access command
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: |...|...|Not define yet|Rx path loss|
     **/
    RfFactoryModeCalItem nvram_access_interface; /* 36 */
    /**
     * Indicate eLNA support band
     * parameter: 0, capable: 0, mandatory: 0 ==> not support eLNA
     * parameter: 0, capable: 1, mandatory: 1 ==> support eLNA
     * parameter: |...|PSC1900 |DSC1800|GSM900|GSM850|GSM400|
     **/
    RfFactoryModeCalItem elna_support_band_bitmap; /* 37 */
    RfFactoryModeCalItem elna_high_sp; /* 38 */
    RfFactoryModeCalItem elna_mid_sp;  /* 39 */
    RfFactoryModeCalItem elna_low_sp;  /* 40 */
    RfFactoryModeCalItem elna_w_coef_sp; /* 41 */
    RfFactoryModeCalItem elna_mid_sawless_sp; /* 42 */
    RfFactoryModeCalItem elna_high_sensitivity_sp; /* 43 */
    RfFactoryModeCalItem elna_bypass_low_maxpin_sp; /* 44 */
    RfFactoryModeCalItem elna_bypass_gain_threshold; /* 45 */
    RfFactoryModeCalItem elna_bypass_support_band_bitmap; /* 46 */
    RfFactoryModeCalItem sinwave_afc_get_temp_freq; /* 47 */
    RfFactoryModeCalItem wcoef_setget_cmd_support; /* 48 */
    RfFactoryModeCalItem tx_setget_cmd_support; /* 49 */
    /**
     * Indicate nsft adjust tx power offset feature support
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: don't care
     **/
    RfFactoryModeCalItem nsft_adjust_tpo_support; /* 50 */
    RfFactoryModeCalItem rxd_v5_cmd_support; /* 51 */
    RfFactoryModeCalItem rxd_support_band_bitmap; /* 52 */
    RfFactoryModeCalItem mlna_type_v7; /* 53 */
    /**
     * Indicate nsft adjust tx power offset feature support
     * parameter: 0, capable: 1, mandatory: 1 ==> support
     * parameter: 0, capable: 0, mandatory: 0 ==> not support
     * parameter: RSSI_RESOLUTION_BITS, indicate support 0,1,2,3(1,1/2,1/4,1/8)dB
     **/
    RfFactoryModeCalItem rxlev_precision_extend; /* 54 */
} RfCalibrationItem;
typedef struct
{
    int                  valid;
    int                  status;
    RfCapabilityItem     capabilityItems;
    RfCalibrationItem    calibrationItems;
} RfMsCapabilityEx3_S;

typedef enum
{
    AFC_SINWAVE_OFF = 0,
    AFC_SINWAVE_ON
} AFC_SINWAVE_DETECTION_E;

typedef struct
{
    ARFCN           arfcn;              ///< Absolute radio frequency channel number
    ContTxPattern   pattern;
    unsigned short  pattern_data;
    unsigned char   OnOff;              ///< On or off
    unsigned short  modtype;            ///< modulation type: 0->GMSK, 1->EPSK
} RfCnTxEx_Req;

typedef struct
{
    ARFCN           arfcn;              ///< Absolute radio frequency channel number
    ContTxPattern   pattern;
    unsigned short  pattern_data;
    unsigned char   OnOff;              ///< On or off
    unsigned short  modtype;            ///< modulation type: 0->GMSK, 1->EPSK
    Power           powerLev;           ///< power level
} RfCnTxEx2_Req;

typedef struct
{
    short           dacValue;       ///< AFC DAC value
} RfGetAfcDacValueAtRTXOffsetCal;

//----------  FDT related structure -----------------------

#define MAX_STEP_CNT   50

/**
 * \ingroup GSMStruct
 * This structure defines parameter for AFC Calibration
 */
typedef struct
{
    FrequencyBand      band;         ///< GSM Band
    ARFCN              arfcn;        ///< GSM arfcn
    short              dac_value[33];   ///< AFC DAC Value for calibration flow, now we only use dac_value[0] & dac_value[1]
    Gain               gain;         ///< AFC used gain (in unit of 1/8 dB)
    short              repeat_cnt;   ///< repetitive test counts (frames) for each AFC DAC value
    bool               capid_cal;    ///< capid calibration ctrl
    bool               linear_cal;   ///< 33 stages calibration ctrl
    int                capid_min;    ///< min value for capid range when capid_cal is True; capid when capid_cal is False
    int                capid_max;    ///< max value for capid range

} Rf_DSSAFC_T;

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Path loss Calibration
 */
typedef struct
{
    FrequencyBand       band;        ///< GSM Band
    ARFCN               arfcn;       ///< GSM arfcn
    Gain                gain[6];     ///< gain for rx slot 0/1/2/3/4/5 (in unit of 1/8 dB)
    short               repeat_cnt;  ///< repetitive test counts (frames) for each ARFCN value
} Rf_DSSPL_T;

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Downlink Test Sequence Calibration (include AFC and Pathloss)
 */
typedef struct
{
    bool                afc_cal;     ///< Control whether AFC calibration is needed or not
    bool                pl_cal;      ///< Control whether Path loss calibration is needed or not
    char                sync_sb_num; ///< the SB frame numbers needed for sync process before path loss calibration
    short               power;       ///< the power dBm (in unit of 1/8 dB) expected to measure when sync process
    Rf_DSSAFC_T         AfcDSS;      ///< parameter for AFC Calibration
    char                step_cnt;    ///< step count for Path Loss Calibration
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_CNT - 2]; ///< parameter for Path Loss Calibration, because sync process will need 2 steps,  MAX_STEP_CNT = 50
} Rf_DTS_REQ_T;

/**
 * \ingroup GSMStruct
 * This structure defines parameter for each step in Uplink Test Sequence Calibration
 */
typedef struct
{
    FrequencyBand        band;        ///< GSM Band
    ARFCN                arfcn;       ///< GSM arfcn
    char                 timeslot_per_frame;       ///< Time Slot Number Per Frame, timeslot_per_frame<=4 (timeslot_per_frame always use 1 in calibration flow)
    char                 apc_dac_pcl_sel;          ///< 1: apc_dac, 0: apc_pcl, apc_dac_pcl_sel will define apc_dac_pcl_value[4] these value be apc_dac or apc_pcl
    short                apc_dac_pcl_value[4];    ///< apc_dac_pcl_sel=1(APC DAC Range will be 0~1023), apc_dac_pcl_sel=0(PCL=5~19 for Low Band, PCL=0~15 for High Band) ([0~3] for this array, we only use [0] for uplink calibration now)
    unsigned char        pa_vbias_val[4];     ///< this array has phase out (It use in IS_TX_GAIN_RF_CALIBRATION_SUPPORT)
    unsigned char        is_low_pcl[4];      ///< this array has phase out (Use in RF MT6140D)

    CodingScheme         cs[4];          ///< coding scheme for 4 slots, GMSK use CodingSchemeCS1, EPSK use CodingSchemeMCS5
    int                  repeat_cnt;     ///< repeat_cnt is used slot number per frame, now we often use repeat_cnt=1
    short                afc_dac_value;  ///< afc dac value used in uplink calibration
    char                 tsc;           ///< Training Sequence Code used in uplink calibration,  FHC will use tsc=5
    APCTxPattern         pattern;       ///< Tx Data Pattern used in uplink calibration, FHC will use NB_TX_FIXED_ALTER_BITS_WITH_TSC
    unsigned short       pattern_data;  ///< manual enter Tx data, used when pattern = NB_TX_PATTERN_WITHOUT_TSC in RF Tool
} Rf_USSAPC_T;

/**
 * \ingroup GSMStruct
 * This structure defines parameter REQ for Uplink Test Sequence Calibration
 */
typedef struct
{
    char                step_cnt;        ///< Tx step count number
    short               high_apc_dcoffset[FrequencyBandCount];   ///< High APC DC Offset for all band setting
    Rf_USSAPC_T         ApcUSS[MAX_STEP_CNT];        ///< UTS Calibration Parameter for each Tx step
} Rf_UTS_REQ_T;

/**
 * \ingroup GSMStruct
 * This structure defines result parameter for Pathloss Calibration, MAX_STEP_CNT=50
 */
typedef struct
{
    int      power[MAX_STEP_CNT - 2];         ///< receive power (in unit of 1/8 dB), because sync process will need 2 steps
    short    valid_sample[MAX_STEP_CNT - 2];  ///< whether receive power is valid sample or not
    bool     ok;                              ///< whether if pathloss result is complete or not
} Rf_DSSPL_RESULT_T;

/**
 * \ingroup GSMStruct
 * This structure defines result parameter for AFC Calibration
 */
typedef struct
{
    int      freq_offset[33];    ///< only valid in [0]&[1] when two stage linear calibration, [0~32] only use when 33 stage calibration is ON
    int      deviation[33];      ///< only valid in [0]&[1] when two stage linear calibration, [0~32] only use when 33 stage calibration is ON
    short    fcb_ok_number[33];  ///< only valid in [0]&[1] when two stage linear calibration, [0~32] only use when 33 stage calibration is ON
    int      capid;              ///< only valid when capid calibration is ON
    short    init_dac_value;     ///< only valid when 33 stage calibration is OFF
    int      slope;              ///< only valid when 33 stage calibration is OFF
    bool     ok;                 ///< whether if afc result is complete or not
} Rf_DSSAFC_RESULT_T;



#define FHC_PRE_CAPID_SEARCH_NUM   9
#define FHC_MAX_CAPID_SEARCH_NUM   (7 + FHC_PRE_CAPID_SEARCH_NUM)

/**
 * \ingroup GSMStruct
 * This structure defines the parameter for Pathloss or AFC Calibration Result, and show on cal log for debug
 */
typedef struct
{
    int               path_loss_cnt;          ///< total pathloss used frame
    int               freq_offset;            ///< frequency offset for using best AFC DAC and best Capid
    int               capid_freq_offset_min;  ///< frequency offset for using best Capid
    int               capid_freq_offset[FHC_MAX_CAPID_SEARCH_NUM];   ///< frequency offset capid calibration flow, 20 is the possible max value for FHC_MAX_CAPID_SEARCH_NUM=16 in target side
    int               capid_search_order[FHC_MAX_CAPID_SEARCH_NUM];  ///< capid value in capid calibration flow, 20 is the possible max value for FHC_MAX_CAPID_SEARCH_NUM=16 in target side
    int               capid;                  ///< temporary capid setting value in capid calibration flow
    int               capid_high;             ///< temporary higher capid value in capid calibration flow binary search
    int               capid_low;              ///< temporary lower capid value in capid calibration flow binary search
    int               capid_best;             ///< best capid value
    short             afc_dac;                ///< best afc dac value
    short             arfcn;                  ///< Used GSM arfcn when doing AFC Calibration
    short             capid_cnt;              ///< Caculate how many count of capid need used before capid calibration, it will be different from capid range
    short             repeat_index;           ///< average number for the same AFC DAC
    char              state;                  ///< DTSM_STATUS, 0:DTSM_START, 1:DTSM_CAPID_CAL, 2:DTSM_CAPID_CAL_DELAY, 3:DTSM_AFC_DAC_CAL, 4:DTSM_AFC_DAC_CAL_DELAY, 5:DTSM_DCXO_LPM_SYNC, 6:DTSM_DCXO_LPM_CAL, 7:DTSM_SYNC_PROC_FB, 8:DTSM_SYNC_PROC_SB, 9:DTSM_PATH_LOSS_CAL, 10:DTSM_STOP
    char              capid_index;            ///< total used count of capid after capid calibration done
    char              capid_okay_cnt;         ///< how many times of FB receive success in different Capid
    char              afc_dac_index;          ///< how many times of AFC Calibration for different AFC DAC (Linear AFC Calibration will be 2)
    char              sb_okay_cnt;            ///< numbr of SB receive success
    unsigned char     sb_fail_cnt;            ///< numbr of SB receive fail
    unsigned char     fb_fail_cnt;            ///< numbr of FB receive fail
    bool              pl_started;             ///< Whether if doing Pathloss calibration
    bool              pre_capid_cal_ok[FHC_PRE_CAPID_SEARCH_NUM];  ///< results for these capid_search_order[0~15], 1:PASS, 0:FAIL
} Rf_FHC_DTSM_INFO_T;

/**
 * \ingroup GSMStruct
 * This enum defines downlink test sequence Result Status, Tool can judge whether L1 result is rady or not bt this value
 */
typedef enum
{
    DTS_RESULT_READY = 0,       ///< DTS results is ready to get back
    DTS_RESULT_NOT_READY,       ///< DTS result is still in progress and not ready to get back
    DTS_RESULT_NOT_REQUESTED    ///< Haven't called the META_Rf_StartFdtDL(void) in advance.
} RF_DTS_GET_RESULT_STATUS;
typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;
    Rf_DSSPL_RESULT_T      PLResult;
    Rf_DSSAFC_RESULT_T     AfcResult;
    Rf_FHC_DTSM_INFO_T     DtsmInfo;
} Rf_DTS_CNF_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetFdtDL_r
 */
META_RESULT  __stdcall META_Rf_GetFdtDL(unsigned int ms_timeout, Rf_DTS_CNF_T* fdt_dl_get_result_cnf);

/**
 * \details For fetching GSM RX results (RSSI or AFC) from DUT, it is result for META_Rf_StartFdtDLNotWaitResult_Lpm_512p_r
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] result, it is parameter for RX Calibration Result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_r(const int meta_handle, unsigned int ms_timeout, Rf_DTS_CNF_T* fdt_dl_get_result_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLNotWaitResult_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult(unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req);

/**
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC), MaxStep=50, Without Lpm Calibration, Need META_Rf_GetFdtDL_r to get result
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req, it is input parameter for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req);

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Downlink Test Sequence Calibration with LPM Calibration (use in AFC Calibration now)
 */
typedef struct
{
    bool                afc_cal;     ///< Control whether AFC calibration is needed or not
    bool                pl_cal;      ///< Control whether Path loss calibration is needed or not
    char                sync_sb_num; ///< the SB frame numbers needed for sync process before path loss calibration
    short               power;       ///< the power dBm (in unit of 1/8 dB) expected to measure when sync process
    Rf_DSSAFC_T         AfcDSS;      ///< parameter for AFC Calibration
    char                step_cnt;    ///< step count for Path Loss Calibration
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_CNT - 2]; ///< parameter for Path Loss Calibration, because sync process will need 2 steps,  MAX_STEP_CNT = 50
    short               lpm_sb_num;  ///< SB frame numbers for lpm calibration
} RF_DTS_REQ_EX_T;
/**
 * \ingroup GSMStruct
 * This structure defines parameter for LPM Calibration Result
 */
typedef struct
{
    int           cload_freq_offset;  ///< calibration result for cload value
    unsigned char ok;                 ///< to check LPM calibration done or not
    unsigned char is_perform_cal;     ///< whether perform LPM calibration or not
} RF_DSSLPM_RESULT_T;
/**
 * \ingroup GSMStruct
 * This structure defines parameter for Pathloss or AFC Calibration Result
 */
typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;  ///< downlink test sequence Result Status
    Rf_DSSPL_RESULT_T      PLResult;      ///< Pathloss Calibration Result (RSSI)
    Rf_DSSAFC_RESULT_T     AfcResult;     ///< AFC Calibration Result (afc dac and capid)
    Rf_FHC_DTSM_INFO_T     DtsmInfo;      ///< downlink test sequence Result for debug trace using
    RF_DSSLPM_RESULT_T     LpmResult;     ///< LPM Calibration Result (Cload)
} RF_DTS_CNF_EX_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLNotWaitResult_Ex_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Ex(unsigned int ms_timeout, const RF_DTS_REQ_EX_T* fdt_dl_req);
/**
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) (Still Use in AFC Calibration), MaxStep=50, With Lpm Calibration, Need META_Rf_GetFdtDL_Ex_r to get result
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req it is input parameter for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Ex_r(const int meta_handle, unsigned int ms_timeout, const RF_DTS_REQ_EX_T* fdt_dl_req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetFdtDL_Ex_r
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Ex(unsigned int ms_timeout, RF_DTS_CNF_EX_T* result);

/**
 * \details For fetching GSM RX results (RSSI or AFC) from DUT, it is result for META_Rf_StartFdtDLNotWaitResult_Ex_r
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] result it is parameter for RX Calibration Result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Ex_r(const int meta_handle, unsigned int ms_timeout, RF_DTS_CNF_EX_T* result);

//-----------------------------------------------------//
//  FHC DTS & UTS gain mode and band combine           //
//-----------------------------------------------------//
/**
 * Description:
 *  Extenstion DTS interface for gain mode combine
 **/
#define MAX_STEP_EX_CNT   100
typedef struct
{
    bool                afc_cal;     ///< Control whether AFC calibration is needed or not
    bool                pl_cal;      ///< Control whether Path loss calibration is needed or not
    char                sync_sb_num; ///< the SB frame numbers needed for sync process before path loss calibration
    short               power;       ///< the power dBm (in unit of 1/8 dB) expected to measure when sync process
    Rf_DSSAFC_T         AfcDSS;      ///< parameter for AFC Calibration
    char                step_cnt;    ///< step count for Path Loss Calibration
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_EX_CNT - 2]; ///< parameter for Path Loss Calibration, because sync process will need 2 steps,  MAX_STEP_EX_CNT = 100
} Rf_DTS_REQ_BIG_T;

typedef struct
{
    int      power[MAX_STEP_EX_CNT - 2]; ///< because sync process will need 2 steps
    short    valid_sample[MAX_STEP_EX_CNT - 2];
    bool     ok;
} Rf_DSSPL_RESULT_BIG_T;

typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;
    Rf_DSSPL_RESULT_BIG_T        PLResult;
    Rf_DSSAFC_RESULT_T           AfcResult;
    Rf_FHC_DTSM_INFO_T           DtsmInfo;
} Rf_DTS_CNF_BIG_T;

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Downlink Test Sequence Calibration with LPM Calibration before M30
 */
typedef struct
{
    bool                afc_cal;     ///< Control whether AFC calibration is needed or not
    bool                pl_cal;      ///< Control whether Path loss calibration is needed or not
    char                sync_sb_num; ///< the SB frame numbers needed for sync process before path loss calibration
    short               power;       ///< the power dBm (in unit of 1/8 dB) expected to measure when sync process
    Rf_DSSAFC_T         AfcDSS;      ///< parameter for AFC Calibration
    char                step_cnt;    ///< step count for Path Loss Calibration
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_EX_CNT - 2];  ///< parameter for Path Loss Calibration, because sync process will need 2 steps,  MAX_STEP_EX_CNT = 100
    short               lpm_sb_num;  ///< SB frame numbers for lpm calibration
} RF_DTS_REQ_EX_BIG_T;

typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;
    Rf_DSSPL_RESULT_BIG_T        PLResult;
    Rf_DSSAFC_RESULT_T           AfcResult;
    Rf_FHC_DTSM_INFO_T           DtsmInfo;
    RF_DSSLPM_RESULT_T           LpmResult;
} RF_DTS_CNF_EX_BIG_T;

/**
 * \ingroup GSMStruct
 * \brief Extenstion UTS interface for middel chanenl tx pcl calibration band combine
 */
typedef struct
{
    char                step_cnt;
    short               high_apc_dcoffset[FrequencyBandCount];
    Rf_USSAPC_T         ApcUSS[MAX_STEP_EX_CNT];
} Rf_UTS_REQ_BIG_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetFdtDL_Big_r
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Big(unsigned int ms_timeout, Rf_DTS_CNF_BIG_T* fdt_dl_get_result_cnf);

/**
 * Extension interface for the target *not* supported LPM
 * \details For fetching GSM RX results (RSSI or AFC) from DUT, it is result for META_Rf_StartFdtDLNotWaitResult_Big_r
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] result, it is parameter for RX Calibration Result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Big_r(const int meta_handle, unsigned int ms_timeout, Rf_DTS_CNF_BIG_T* fdt_dl_get_result_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDL_Big_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDL_Big(unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req,  Rf_DTS_CNF_BIG_T* fdt_dl_cnf);
/**
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC), MaxStep=100, Without Lpm Calibration, Result is fdt_dl_cnf
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req, it is input parameter for RX Calibration
 * \param [out] fdt_dl_cnf, it is result for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDL_Big_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req,  Rf_DTS_CNF_BIG_T* fdt_dl_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLNotWaitResult_Big_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big(unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req);
/**
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) before M30, MaxStep=100, Without Lpm Calibration, Need META_Rf_GetFdtDL_Big_r to get result
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req, it is input parameter for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLNotWaitResult_Big_Ex_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big_Ex(unsigned int ms_timeout, const RF_DTS_REQ_EX_BIG_T* fdt_dl_req);
/**
 * \brief Extension interface for the target *supported* LPM
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) before M30, MaxStep=100, With Lpm Calibration, Need META_Rf_GetFdtDL_Big_Ex_r to get result
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req, it is input parameter for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big_Ex_r(const int meta_handle, unsigned int ms_timeout, const RF_DTS_REQ_EX_BIG_T* fdt_dl_req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetFdtDL_Big_Ex_r
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Big_Ex(unsigned int ms_timeout, RF_DTS_CNF_EX_BIG_T* result);
/**
 * \details For fetching GSM RX results (RSSI or AFC) from DUT, it is result for META_Rf_StartFdtDLNotWaitResult_Big_Ex_r
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] result, it is parameter for RX Calibration Result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Big_Ex_r(const int meta_handle, unsigned int ms_timeout, RF_DTS_CNF_EX_BIG_T* result);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtUL_Big_r 
 */
META_RESULT  __stdcall META_Rf_StartFdtUL_Big(unsigned int ms_timeout, const Rf_UTS_REQ_BIG_T*  fdt_ul_req);
 //brief Extension interface for the TX quad band combine
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_StartFdtUL_Big_r(const int meta_handle, unsigned int ms_timeout, const Rf_UTS_REQ_BIG_T*  fdt_ul_req);

#define MAX_STEP_EX_512P_CNT   512

typedef enum
{
    GSM_LNA_NULL = 0,
    GSM_LNA_HIGH,
    GSM_LNA_MID,
    GSM_LNA_LOW,
    GSM_LNA_W_COEF,
    GSM_LNA_SAWLESS_MID,
    GSM_ELNA_HIGH_SENSITIVITY,
    GSM_ELNA_BYPASS_LOW_MAXPIN,
    GSM_LNA_END
} GSM_LNA_Cal_Type;

typedef struct
{
    FrequencyBand       band;        ///< GSM Band
    ARFCN               arfcn;       ///< GSM ARFCN
    Gain                gain[6];     ///< gain for rx slot 0/1/2/3/4/5
    short               repeat_cnt;  ///< repetitive test counts (frames) for each ARFCN value
    GSM_LNA_Cal_Type    gsm_lna_mode;
} Rf_DSSPL_WITH_LNAMODE_T;

//Gen92 --> M30
//Gen93 --> M50-CAT7
//Gen95 --> M50

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Downlink Test Sequence Calibration in M30 with LPM Calibration
 */
typedef struct
{
    bool                afc_cal;      ///< Control whether AFC calibration is needed or not
    bool                pl_cal;       ///< Control whether Path loss calibration is needed or not
    char                sync_sb_num;  ///< the SB frame numbers needed for sync process before path loss calibration
    short               power;        ///< the power dBm (in unit of 1/8 dB) expected to measure when sync process
    Rf_DSSAFC_T         AfcDSS;       ///< parameter for AFC Calibration
    unsigned short      step_cnt;     ///< step count for Path Loss Calibration, due to 512 step, type of step_cnt changes to unsigned short
    Rf_DSSPL_WITH_LNAMODE_T   PathLossDSS[MAX_STEP_EX_512P_CNT - 2];   ///< parameter for Path Loss Calibration, because sync process will need 2 steps, MAX_STEP_EX_512P_CNT = 512
    short               lpm_sb_num;   ///< SB frame numbers for lpm calibration
} RF_DTS_REQ_LPM_512P_T;

/**
 * \ingroup GSMStruct
 * This structure defines result parameter for Pathloss Calibration, MAX_STEP_EX_512P_CNT=512
 */
typedef struct
{
    int      power[MAX_STEP_EX_512P_CNT - 2]; ///< because sync process will need 2 steps
    short    valid_sample[MAX_STEP_EX_512P_CNT - 2];
    bool     ok;
} Rf_DSSPL_RESULT_512P_T;
/**
 * \ingroup GSMStruct
 * This structure defines parameter for Pathloss or AFC Calibration Result in M30 & M50-CAT7
 */
typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;     ///< downlink test sequence Result Status
    Rf_DSSPL_RESULT_512P_T       PLResult;   ///< Pathloss Calibration Result (RSSI)
    Rf_DSSAFC_RESULT_T           AfcResult;  ///< AFC Calibration Result (afc dac and capid)
    Rf_FHC_DTSM_INFO_T           DtsmInfo;   ///< downlink test sequence Result for debug trace using
    RF_DSSLPM_RESULT_T           LpmResult;  ///< LPM Calibration Result (Cload)
} RF_DTS_CNF_LPM_512P_T;
/**
 * \ingroup GSMStruct
 * This structure defines parameter REQ for Uplink Test Sequence Calibration
 */
typedef struct
{
    unsigned short      step_cnt;        ///< Tx step count number
    short               high_apc_dcoffset[FrequencyBandCount];   ///< High APC DC Offset setting for all band
    Rf_USSAPC_T         ApcUSS[MAX_STEP_EX_512P_CNT];   ///< UTS Calibration Parameter for each Tx step
} Rf_UTS_REQ_512P_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLNotWaitResult_Lpm_512p_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Lpm_512p(unsigned int ms_timeout, const RF_DTS_REQ_LPM_512P_T* fdt_dl_req);

/**
 * Extension interface for Extension of test point
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) in M30, MaxStep=512, With Lpm Calibration, Need META_Rf_GetFdtDL_Lpm_512p_r to get result
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req, it is input parameter for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Lpm_512p_r(const int meta_handle, unsigned int ms_timeout, const RF_DTS_REQ_LPM_512P_T* fdt_dl_req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetFdtDL_Lpm_512p_r
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Lpm_512p(unsigned int ms_timeout, RF_DTS_CNF_LPM_512P_T* result);
/**
 * \details For fetching GSM RX results (RSSI or AFC) from DUT in M30, it is result for META_Rf_StartFdtDLNotWaitResult_Lpm_512p_r
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] result, it is parameter for RX Calibration Result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Lpm_512p_r(const int meta_handle, unsigned int ms_timeout, RF_DTS_CNF_LPM_512P_T* result);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDL_Lpm_512p_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDL_Lpm_512p(unsigned int ms_timeout, const RF_DTS_REQ_LPM_512P_T* fdt_dl_req, RF_DTS_CNF_LPM_512P_T* fdt_dl_cnf);

/**
 * \internal
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) in M30, MaxStep=512, With Lpm Calibration, Result is fdt_dl_cnf
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req, it is input parameter for RX Calibration
 * \param [out] fdt_dl_cnf, it is result for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDL_Lpm_512p_r(const int meta_handle, unsigned int ms_timeout, const RF_DTS_REQ_LPM_512P_T* fdt_dl_req, RF_DTS_CNF_LPM_512P_T* fdt_dl_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtUL_512p_r
 */
META_RESULT  __stdcall META_Rf_StartFdtUL_512p(unsigned int ms_timeout, const Rf_UTS_REQ_512P_T*  fdt_ul_req);

/**
 * \details For triggering GSM TX FHC
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_ul_req it is parameter for TX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtUL_512p_r(const int meta_handle, unsigned int ms_timeout, const Rf_UTS_REQ_512P_T*  fdt_ul_req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetFdtDL_Lpm_512p_V3_r
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Lpm_512p_V3(unsigned int ms_timeout, RF_DTS_CNF_LPM_512P_T* result);

/**
 * \details For fetching GSM RX results (RSSI or AFC) from DUT in M50-CAT7, it is result for META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V3_r
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] result it is parameter for RX Calibration Result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Lpm_512p_V3_r(const int meta_handle, unsigned int ms_timeout, RF_DTS_CNF_LPM_512P_T* result);

/**
 * \ingroup GSMStruct
 */
typedef enum
{
    GSM_LNA_NULL_V3 = 0,
    GSM_LNA_HIGH_V3,
    GSM_LNA_MID_V3,
    GSM_LNA_LOW_V3,
    GSM_LNA_W_COEF_V3,
    GSM_LNA_SAWLESS_MID_V3,
    GSM_ELNA_HIGH_SENSITIVITY_V3,
    GSM_ELNA_BYPASS_LOW_MAXPIN_V3,
    GSM_LNA_END_V3
} GSM_LNA_Cal_Type_V3;

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Pathloss per Step in M50-CAT7
 */
typedef struct
{
    FrequencyBand       band;        ///< GSM Band
    ARFCN               arfcn;       ///< GSM ARFCN
    Gain                gain[6];     ///< gain for rx slot 0/1/2/3/4/5
    short               repeat_cnt;  ///< repetitive test counts (frames) for each ARFCN value
    GSM_LNA_Cal_Type_V3 gsm_lna_mode;
} Rf_DSSPL_WITH_LNAMODE_V3_T;

//Gen92 --> M30
//Gen93 --> M50-CAT7
//Gen95 --> M50

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Downlink Test Sequence Calibration in M50-CAT7 with LPM Calibration
 */
typedef struct
{
    bool                afc_cal;      ///< Control whether AFC calibration is needed or not
    bool                pl_cal;       ///< Control whether Path loss calibration is needed or not
    char                sync_sb_num;  ///< the SB frame numbers needed for sync process before path loss calibration
    short               power;        ///< the power dBm (in unit of 1/8 dB) expected to measure when sync process
    Rf_DSSAFC_T         AfcDSS;       ///< parameter for AFC Calibration
    unsigned short      step_cnt;     ///< step count for Path Loss Calibration, due to 512 step, type of step_cnt changes to unsigned short
    Rf_DSSPL_WITH_LNAMODE_V3_T   PathLossDSS[MAX_STEP_EX_512P_CNT - 2];  ///< parameter for Path Loss Calibration, because sync process will need 2 steps, MAX_STEP_EX_512P_CNT=512
    short               lpm_sb_num;   ///< SB frame numbers for lpm calibration
} RF_DTS_REQ_LPM_512P_V3_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V3_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V3(unsigned int ms_timeout, const RF_DTS_REQ_LPM_512P_V3_T* fdt_dl_req);

/**
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) in M50-CAT7, MaxStep=512, With Lpm Calibration, Need META_Rf_GetFdtDL_Lpm_512p_V3_r to get result
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req it is input parameter for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V3_r(const int meta_handle, unsigned int ms_timeout, const RF_DTS_REQ_LPM_512P_V3_T* fdt_dl_req);

//-----------------------------------------------------//
//  TX Ramping Table                                   //
//-----------------------------------------------------//
/**
 * \ingroup GSMStruct
 * Number of TX profile, which is the same as PCL numbers
 */
#define PROFILE_NUM             16
/**
 * \ingroup GSMStruct
 * Number of TX sub-band, note that "end-mark" would occupy one entry also
 */
#define ARFCN_SECTION_NUM       12
#define ARFCN_SECTION_NUM_Ex       64

/**
 * \ingroup GSMStruct
 * Ramp profile
 */
typedef  struct
{
   /**
    * Ramp profile (in unit of APC DAC)
    * - point[0][x] is for ramp-up, where x is in unit of QB prior to slot boundary
    * - point[1][x] is for ramp-down, where x is in unit of QB after the slot boundary
    */
    unsigned char   point[2][16];    ///< ramp up/down profile

} sRAMPAREADATA;

/**
 * \ingroup GSMStruct
 * Compensation weighting for each sub-band
 */
typedef  struct
{
   /**
    * sub-band boundary
    */
    short            max_arfcn;
   /**
    * PCL thershold for applying high or low weighting
    */
    unsigned short   mid_level;
   /**
    * Weighting factor for PCLs higher than mid_level
    */
    unsigned short   hi_weight;
   /**
    * Weighting factor for PCLs lower than mid_level
    */
    unsigned short   low_weight;

} sARFCN_SECTION;

/**
 * \ingroup GSMStruct
 * APC ramp profile
 */
 typedef  struct
{
   /**
    * The pedestal voltage settings of the indicated band
    * - [ 7: 0] pedestal threshold (in unit of dBm)
    * - [17: 8] pedestal for PCL with power higher than pedestal threshold (in unit of APC DAC)
    * - [31:18] pedestal for PCL with power lower than pedestal threshold (in unit of APC DAC)
    */
    int              lowest_power;
   /**
    * APC DAC value for each power level
    * - In low band: power[0] is APC DAC for PCL19, [1] is for PCL18, etc.
    * - In high band: power[0] is APC DAC for PCL15, [1] is for PCL14, etc.
    */
    unsigned short   power[16];
   /**
    * Ramp profile for each PCL
    */
    sRAMPAREADATA    ramp[ PROFILE_NUM ];
   /**
    * Compensation weighting for each sub-band
    */
    sARFCN_SECTION   arfcn_weight[ ARFCN_SECTION_NUM ];
   /**
    * Compensatione wighting for battery-voltage and temperature
    */
    unsigned short   battery_compensate[3][3];
   /**
    * Phase-out field, not used now
    */
    short            tx_afc_offset;
} sRAMPDATA;

typedef struct
{
    int              lowest_power;                       ///< The lower apc power of the indicated band
    unsigned short   power[16];                          ///< The mapping of power level to apc dac value
    sRAMPAREADATA    ramp[ PROFILE_NUM ];                ///< ramp profile
    sARFCN_SECTION   arfcn_weight[ ARFCN_SECTION_NUM_Ex ];   ///< profile of weighting power level by PCL and sub-band
    unsigned short   battery_compensate[3][3];           ///< [volt][temp]
    short            tx_afc_offset;
} sRAMPDATA_Ex;

typedef  struct
{
    int              lowest_power;                       ///< The lower apc power of the indicated band
    unsigned short   power[16];                          ///< The mapping of power level to apc dac value
    sRAMPAREADATA    ramp[ PROFILE_NUM ];                ///< ramp profile
    sARFCN_SECTION   arfcn_weight[ ARFCN_SECTION_NUM ];  ///< profile of weighting power level by PCL and sub-band
    unsigned short   battery_compensate[3][3];           ///< [volt][temp]
    short            tx_afc_offset;
    unsigned char    vbias[16];
} sRAMPDATA_Ex2;

/**
 * \ingroup GSMStruct
 * TX calibration data
 */
typedef struct
{
   /**
    * APC ramp profile
    */
    sRAMPDATA          rampData;
} l1cal_rampTable_T;

// useless: Ex and Ex2
typedef struct
{
    sRAMPDATA_Ex          rampData;                          ///< apc ramp profile of all bands
} l1cal_rampTable_T_Ex;

typedef struct
{
    sRAMPDATA_Ex2          rampData;                         ///< apc ramp profile of all bands
} l1cal_rampTable_T_Ex2;


//-----------------------------------------------------//
//  TX Inter Ramping Table                             //
//-----------------------------------------------------//

// interRampData
typedef struct
{
    unsigned char   interRampData[16];
} l1cal_interRampData_T;

// EPSK interRampData
typedef struct
{
    unsigned char   EPSK_interRampData[4][16];
} l1cal_EPSK_interRampData_T;
#define  CAL_UARFCN_SECTION       15
#define  U_ARFCN_SECTION_NUM      15
#define  CAL_TEMP_SECTION          8
#define  CAL_PWR_DETECTOR_SECTION 32
typedef  struct
{
    unsigned short  max_uarfcn;
    char   path_loss_H;//loss;
    char   path_loss_M;//gain_diff_HM;
    char   path_loss_L;//gain_diff_HL;
    char   path_loss_LPM_offset;
}  U_sAGCGAINOFFSET;
typedef  struct
{
    U_sAGCGAINOFFSET  gain_of_uarfcn[CAL_UARFCN_SECTION];
}  U_sTEMPAGCOFFSET;
typedef  struct
{
    unsigned short dc2dc_dac;
    unsigned short vbias_dac;
    unsigned char vm1;
    unsigned char vm2;
}  U_sPADATA;
typedef  struct
{
    unsigned short  max_uarfcn;
    short           pwr_offset;
    short           pwr_slope;
} U_sARFCN_SECTION;
typedef struct
{
    unsigned short max_uarfcn;
    short          pwr_offset_dB; /* unit: 1/32 dB, range: -8 ~ +7 dB */
    short          pwr_offset_txdac;
} U_sARFCN_SECTION_B; // for MT6268B later
typedef  struct
{
    U_sPADATA          pa_data;
    unsigned short     vga_dac[90];
    U_sARFCN_SECTION   vga_comp_by_subband[CAL_UARFCN_SECTION];
    short              vga_comp_by_temperature[8][2];  //[0]:slope, [1]:offset
} U_sTXPOWERDATA;
typedef  struct
{
    U_sPADATA           pa_data;
    unsigned short      vga_dac[96];   // number: 96/10
    U_sARFCN_SECTION_B  vga_comp_by_subband[ CAL_UARFCN_SECTION ];
    short               vga_comp_by_temperature[8][2];  //[0]:offset in dB (unit: 1/32 dB), [1]:offset in txdac
} U_sTXPOWERDATA_B;
typedef  struct
{
    unsigned short start;
    unsigned short end;
} U_sHYSTERESISDATA;
typedef  struct
{
    unsigned char     pwr_dt_thr;
    unsigned char     pwr_dt_section;   // can not be larger than CAL_PWR_DETECTOR_SECTION
    unsigned short    pwr_dt_dac[CAL_PWR_DETECTOR_SECTION];
    short             pwr_dt_value[CAL_PWR_DETECTOR_SECTION]; //bit0~4 is used for fractions
    U_sARFCN_SECTION  pwr_dt_comp_by_subband[CAL_UARFCN_SECTION];   // for compensation, no need calibration, after test, will auto-store
    short             pwr_dt_comp_by_temperature[8][2];  //[0]:slope, [1]:offset
}  U_sPWTDTDATA;
typedef  struct
{
    unsigned char       pwr_dt_thr;
    unsigned char       pwr_dt_section;
    unsigned short      pwr_dt_dac[ CAL_PWR_DETECTOR_SECTION ];
    short               pwr_dt_value[ CAL_PWR_DETECTOR_SECTION ]; //bit0~4 is used for fractions
    U_sARFCN_SECTION_B  pwr_dt_comp_by_subband[ CAL_UARFCN_SECTION ];
    short               pwr_dt_comp_by_temperature[8][2];  //[0]:offset in dB (unit: 1/32 dB), [1]:offset in txdac
}  U_sPWTDTDATA_B;   // for MT6268B later
typedef  struct
{
    unsigned short level_0;
    unsigned short level_1;
} U_sDC2DC;

typedef struct
{
    unsigned char level[8];
} U_sDC2DCOCTLVL;

typedef struct
{
    unsigned char   pa_mode;
    char            prf;
    unsigned char   dc2dc_lvl;
    unsigned char   vm1;
    unsigned char   vm2;
    unsigned short  vbias_dac;
    unsigned short  pa_gain;
} U_sPMULEVHANDLE;

typedef  struct
{
    /* These two control parameters belong to BB TX HW funtionality
     * and all related to PA, though PA phase compensation only has
     * three modes. PD coupler loss by PA modes stored in power_dac[]->vga_dac[9].
     */
    unsigned char     octlev_num_section;
    unsigned int      pa_phase_compensation[3]; // 0: PA high mode, 1: PA mid mode
    U_sPMULEVHANDLE   pmu_level_handle[8];
} U_sPAOCTLVLSETTING;

typedef  struct
{
    U_sDC2DC          pa_dc2dc;       // 2009,Nov add, need to check DB to compose/decompose it automatically
    U_sTXPOWERDATA    power_dac[3];   //0:PA high mode, 1:PA mid mode, 2:PA low mode (use 0&1 if only 2 mode)
    U_sHYSTERESISDATA tx_hysteresis[2];
    U_sPWTDTDATA      pwr_dt_data;
} U_sRAMPDATA;
typedef  struct
{
    U_sDC2DC              pa_dc2dc;       //need to check DB to compose/decompose it automatically
    U_sTXPOWERDATA_B      power_dac[3];   //0:PA high mode, 1:PA mid mode, 2:PA low mode (use 0&1 if only 2 mode)
    U_sHYSTERESISDATA     tx_hysteresis[2];
    U_sPWTDTDATA_B        pwr_dt_data;
} U_sRAMPDATA_B;   // for MT6268B later
typedef struct
{
    unsigned short tempdacData[8];
} ul1cal_tempdacData_T;
typedef struct
{
    U_sTEMPAGCOFFSET  pathlossData[CAL_TEMP_SECTION];
} ul1cal_pathlossData_T;
typedef struct
{
    U_sRAMPDATA txdacData;
} ul1cal_txdacData_T;
typedef struct
{
    U_sRAMPDATA_B txdacData;
} ul1cal_txdacData_T_B;  // for MT6268B or later
typedef struct
{
    U_sPAOCTLVLSETTING txPaOctLevData;
} ul1cal_txPaOctLevData_T;
typedef struct
{
    unsigned char band;
    ul1cal_txdacData_T_B txdacData;
} ul1cal_txdacData_T_B_ByBand;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetTxDacData_B_r
 */
META_RESULT  __stdcall META_3Grf_SetTxDacData_B(unsigned int ms_timeout, const ul1cal_txdacData_T_B_ByBand* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetTxDacData_B_r(const int meta_handle, unsigned int ms_timeout, const ul1cal_txdacData_T_B_ByBand* req);

typedef struct
{
    /// band indicator (in local parameter)
    unsigned char band;
    /// PA Oct level data (in peer buffer)
    ul1cal_txPaOctLevData_T txPaOctLevData;
} URfTestCmdSetTxPaOctLevData;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetTxPaOctLevData_r
 */
META_RESULT  __stdcall META_3Grf_SetTxPaOctLevData(unsigned int ms_timeout, const URfTestCmdSetTxPaOctLevData* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetTxPaOctLevData_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetTxPaOctLevData* req);

typedef struct
{
    /// band indicator (in local parameter)
    unsigned char           band;
    /// pa mode (in local parameter)
    unsigned char           pa_mode;
    /// tx dac data (only the power_dac is composed into peer buffer)
    ul1cal_txdacData_T_B    txdacData;
} URfTestCmdSetTxDacPowerDac;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetTxDacPowerDac_r
 */
META_RESULT  __stdcall META_3Grf_SetTxDacPowerDac(unsigned int ms_timeout, const URfTestCmdSetTxDacPowerDac* req);
 /**
 * \ingroup WCDMA
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_3Grf_SetTxDacPowerDac_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetTxDacPowerDac* req);

typedef struct
{
    char temper_offset[CAL_TEMP_SECTION];
    U_sAGCGAINOFFSET gain_of_uarfcn[CAL_UARFCN_SECTION];
} U_sAGCOFFSETRXD;
typedef struct
{
    U_sAGCOFFSETRXD pathlossData;
} ul1cal_pathlossRxdData_T;
/**
 * for 3G URF NVRAM-Access via interface directly
 */
typedef enum
{
    NVRAM_ACCESS_FOR_RX_PATH_LOSS  = 1,
    NVRAM_ACCESS_FOR_RXD_PATH_LOSS = (1 << 1),
    NVRAM_ACCESS_FOR_TX_CAL_DATA   = (1 << 2),
    NVRAM_ACCESS_FOR_RX_CAL_DATA   = (1 << 6)
} NVRAM_ACCESS_INTERFACE_SUPPORT;

typedef enum
{
    TX_DATA_STRUCTURE_FOR_6HPM6LPM = 0x04,
    RX_DATA_STRUCTURE_FOR_6HPM6LPM = 0x40
} TRX_DATA_STRUCTURE_TYPE;

typedef enum
{
    CNF_SUCCESS  = 0, /**< URF access NVRAM successfully  */
    CNF_GENREAL_FAIL  = 1, /**< URF access NVRAM general error  */
    CNF_NVRAM_ACCESS_FAIL  = 2, /**< URF access NVRAM, NVRAM return failed */
    CNF_FREQ_INVALID  = 3 /**< Error arfcn parameter for band*/
} URF_NVRAM_ACCESS_RESULT;

typedef  struct
{
    char temper_offset[CAL_TEMP_SECTION];
    U_sAGCGAINOFFSET  gain_of_uarfcn[CAL_UARFCN_SECTION];
} U_sTEMPAGCOFFSETEX;
typedef struct
{
    char band;
    char rxAntPath; /**< 1 for main Rx path, 2 for diversity Rx path*/
    U_sTEMPAGCOFFSETEX pathlossDataEx;
} URfTestCmdSetRxPathLoss;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_SetRxPathLoss_r
 */
META_RESULT __stdcall META_3Grf_SetRxPathLoss (const unsigned int ms_timeout, const URfTestCmdSetRxPathLoss* req);
/**
 * \ingroup WCDMA
 * \details the write API for WCDMA RX/RXD path loss NVRAM item 
 * \param [in] meta_handle context handle to specific DUT
 * \param [in ]ms_timeout API transaction timeout value in milliseconds
 * \param [in] req the pointer to a memory space which is stored the RX/RXD path loss data for writing to target.
 * \retva META_SUCCESS The operation completed successfully. 
 * \retva META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retva META_FAILED The requested operation was unsuccessful.
 **/
META_RESULT __stdcall META_3Grf_SetRxPathLoss_r (const int meta_handle, const unsigned int ms_timeout, const URfTestCmdSetRxPathLoss* req);

typedef struct
{
    char band;
    char rxAntPath;
} URfTestCmdGetRxPathLoss;

typedef struct
{
    U_sTEMPAGCOFFSETEX pathlossDataEx;
} URfTestResultGetRxPathLoss;
/**
 * \ingroup WCDMA
 * \sa non-reentrant version of META_3Grf_GetRxPathLoss_r
 */
META_RESULT __stdcall META_3Grf_GetRxPathLoss (const unsigned int ms_timeout, const URfTestCmdGetRxPathLoss* req, URfTestResultGetRxPathLoss* cnf );
/**
 * \ingroup WCDMA
 * \details Wcdma Rx/Rxd path loss NVRAM item read API
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
  * \param req get path loss command to target
 * \param cnf the pointer to a memory space for storing the result of path loss
 *           NVRAM item acquired from target.
 * \sa URF_TEST_CMD_GET_RX_PATH_LOSS
 * \retval META_SUCCESS successful
 **/
META_RESULT __stdcall META_3Grf_GetRxPathLoss_r (const int meta_handle, const unsigned int ms_timeout, const URfTestCmdGetRxPathLoss*  req, URfTestResultGetRxPathLoss* cnf );


//-----------------------------------------------------//
//  RF Module Special Coef                             //
//-----------------------------------------------------//

//mt6140D
typedef struct
{
    short        pcl_index;
    unsigned char pa_vbias1;
} pa_vbias;

typedef struct
{
    pa_vbias GSM850_pa_vbias[8];
    pa_vbias GSM900_pa_vbias[8];
    pa_vbias DCS1800_pa_vbias[8];
    pa_vbias PCS1900_pa_vbias[8];
} mt6140tx_pa_vbias;

typedef struct
{
    mt6140tx_pa_vbias data;
} mt6140tx;
// Skyworks
typedef struct
{
    unsigned int        icorrection;
    unsigned int        qcorrection;
} RF_SKY74045_IP2_Coef;

typedef struct
{
    RF_SKY74045_IP2_Coef    coef[5/*band*/];
} RF_SKY74045_RX_Coef;

typedef struct
{
    RF_SKY74045_RX_Coef     rx;
} RF_SKY74045_Coef_T;

typedef struct
{
    unsigned int            ipol;
    unsigned int            qpol;
} RF_SKY74117_IP2_Pol;

typedef struct
{
    RF_SKY74045_IP2_Coef    coef[5/*band*/];
    RF_SKY74117_IP2_Pol     pol[5/*band*/];
} RF_SKY74117_RX_Coef;

typedef struct
{
    RF_SKY74117_RX_Coef     rx;
} RF_SKY74117_Coef_T;

// MT6139B
typedef struct
{
    unsigned int        acode;
    unsigned int        amcode;
} RF_MT6139B_IP2_Coef;

typedef struct
{
    RF_MT6139B_IP2_Coef     coef[5/*band*/];
    unsigned int            rxamcalmode;
} RF_MT6139B_RX_Coef;

typedef struct
{
    RF_MT6139B_RX_Coef      rx;
} RF_MT6139B_Coef_T;

// Bright5P
typedef struct
{
    unsigned int        word6_4_0;
    unsigned int        word6_5_0;
    unsigned int        word6_6_0;
    unsigned int        word6_7_0;
    unsigned int        bvmode;
    unsigned int        c3mode;
    unsigned int        wordC3;
} RF_BRIGHT5P_TX_Coef;

typedef struct
{
    RF_BRIGHT5P_TX_Coef     tx;
} RF_BRIGHT5P_Coef_T;


typedef struct
{
    unsigned char REFDET_SLOPE_SKEW;
    unsigned char AM_FB_DAC;
} ad6546txcoef;

typedef struct
{
    char MID_GAMA_THRESHOLD;
    char LOW_GAMA_THRESHOLD;
    char MID_DELTA_SLOPE_SKEW;
    char LOW_DELTA_SLOPE_SKEW;
    char MID_DELTA_APC_CAP;
    char LOW_DELTA_APC_CAP;
} ad6546tx_reg8_highband_delta;

typedef struct
{
    unsigned long Address           : 7;
    unsigned long POLAR_APC_CAP     : 5;
    unsigned long VGA_SLOPE         : 4;
    unsigned long REFDET_SLOPE_SKEW : 4;
    unsigned long AM_FB_DAC         : 4;
    unsigned long reserved          : 8;
} AM_LOOP;
typedef union
{
    AM_LOOP AMLoop;
    unsigned long RegData;
} ad6546tx_reg8;

typedef  struct
{
    ad6546txcoef   CalData[4];
    ad6546tx_reg8  Reg8_default[4];
} ad6546tx;

typedef struct
{
    //int rf_band;
    short afc_offset[FrequencyBandCount];

} RF_SET_AFC_DAC_OFFSET_REQ_T;

typedef struct
{
    short afc_offset[FrequencyBandCount];

} RF_GET_AFC_DAC_OFFSET_CNF_T;


//-----------------------------------------------------//
//  RF Testing: callback function definition           //
//-----------------------------------------------------//
typedef void (__stdcall* META_RF_PM_CNF)(const RfPm_Cnf* cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_AFC_CNF)(const RfAfc_Cnf* cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_NB_TX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_CONT_RX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_CONT_TX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SETBBTX_CFG_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SELBAND_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_STOP_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_MULTISLOT_TX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SET_RAMPAPCLEVEL_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SET_AFCDACVALUE_CNF)(const unsigned char cnf, const short token, void* usrData);

//-----------------------------------------------------//
//  RF Testing: exported function definition           //
//-----------------------------------------------------//
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_PM_r
 */
META_RESULT  __stdcall META_Rf_PM(const RfPm_Req* req, const META_RF_PM_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_PM_r(const int meta_handle, const RfPm_Req* req, const META_RF_PM_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_PmEx_r
 */
META_RESULT  __stdcall META_Rf_PmEx(unsigned int ms_timeout, const RfPm_Req* req, RfPm_Cnf* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_PmEx_r(const int meta_handle, unsigned int ms_timeout, const RfPm_Req* req, RfPm_Cnf* cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_IfPm_r
 */
META_RESULT  __stdcall META_Rf_IfPm(unsigned int ms_timeout, const RfIfPm_Req* req, RfPm_Cnf* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_IfPm_r(const int meta_handle, unsigned int ms_timeout, const RfIfPm_Req* req, RfPm_Cnf* cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_Sawless_Pm_r
 */
META_RESULT  __stdcall META_Rf_Sawless_Pm(const unsigned int ms_timeout, const RfPm_Req* req, RfPm_Cnf* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_Sawless_Pm_r(const int meta_handle, const unsigned int ms_timeout, const RfPm_Req* req, RfPm_Cnf* cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_AFC_r
 */
META_RESULT  __stdcall META_Rf_AFC(const RfAfc_Req* req, const META_RF_AFC_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_AFC_r(const int meta_handle, const RfAfc_Req* req, const META_RF_AFC_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NB_TX_r
 */
META_RESULT  __stdcall META_Rf_NB_TX(const RfNbtx_Req* req, const META_RF_NB_TX_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_NB_TX_r(const int meta_handle, const RfNbtx_Req* req, const META_RF_NB_TX_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_CONTINUE_RX_r
 */
META_RESULT  __stdcall META_Rf_CONTINUE_RX(const RfCnRx_Req* req, const META_RF_CONT_RX_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_CONTINUE_RX_r(const int meta_handle, const RfCnRx_Req* req, const META_RF_CONT_RX_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_CONTINUE_TX_r
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX(const RfCnTx_Req* req, const META_RF_CONT_TX_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX_r(const int meta_handle, const RfCnTx_Req* req, const META_RF_CONT_TX_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetBBTXCfg_r
 */
META_RESULT  __stdcall META_Rf_SetBBTXCfg(const RfSetBBTXCfg_Req* req, const META_RF_SETBBTX_CFG_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetBBTXCfg_r(const int meta_handle, const RfSetBBTXCfg_Req* req, const META_RF_SETBBTX_CFG_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SelectFrequencyBand1900_r
 */
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900(const unsigned char selectPCS1900, const META_RF_SELBAND_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900_r(const int meta_handle, const unsigned char selectPCS1900, const META_RF_SELBAND_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_Stop_r
 */
META_RESULT  __stdcall META_Rf_Stop(const META_RF_STOP_CNF cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_Stop_r(const int meta_handle, const META_RF_STOP_CNF cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_MultiSlot_TX_r
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX(const RfMultiSlotTX_Req* req, const META_RF_MULTISLOT_TX_CNF  cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX_r(const int meta_handle, const RfMultiSlotTX_Req* req, const META_RF_MULTISLOT_TX_CNF  cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetAfcDacValue_r
 */
META_RESULT  __stdcall META_Rf_SetAfcDacValue(const RfSetAfcDacValue_Req* req, const META_RF_SET_AFCDACVALUE_CNF  cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetAfcDacValue_r(const int meta_handle, const RfSetAfcDacValue_Req* req, const META_RF_SET_AFCDACVALUE_CNF  cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetBBTxCfg2_r
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg2(unsigned int ms_timeout, const RfBBTXCfg2*  tx_cfg_req, RfBBTXCfg2*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg2_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg2*  tx_cfg_req, RfBBTXCfg2*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetBBTxCfg2_r
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg2(unsigned int ms_timeout, RfBBTXCfg2*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg2_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg2*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetCrystalCapId_r
 */
META_RESULT  __stdcall META_Rf_SetCrystalCapId(unsigned int ms_timeout, const RfSetCrystalCfg_Req*  req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetCrystalCapId_r(const int meta_handle, unsigned int ms_timeout, const RfSetCrystalCfg_Req*  req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_BBTXAutoCal_r
 */
META_RESULT  __stdcall META_Rf_BBTXAutoCal(unsigned int ms_timeout);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_BBTXAutoCal_r(const int meta_handle, unsigned int ms_timeout);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryMSCapability_r
 */
META_RESULT  __stdcall META_Rf_QueryMSCapability(unsigned int ms_timeout, RfMsCapability_S*  p_type);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_QueryMSCapability_r(const int meta_handle, unsigned int ms_timeout, RfMsCapability_S*  p_type);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryMSCapabilityEx_r
 */
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx(unsigned int ms_timeout, RfMsCapabilityEx_S*  p_ms_cap);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx_r(const int meta_handle, unsigned int ms_timeout, RfMsCapabilityEx_S*  p_ms_cap);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetAfcSinWaveDetection_r
 */
META_RESULT  __stdcall META_Rf_SetAfcSinWaveDetection(unsigned int ms_timeout, AFC_SINWAVE_DETECTION_E  bIsAfcSinWaveOn);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetAfcSinWaveDetection_r(const int meta_handle, unsigned int ms_timeout, AFC_SINWAVE_DETECTION_E  bIsAfcSinWaveOn);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryIfTwoApcDCOffsetSupport_r
 */
META_RESULT  __stdcall META_Rf_QueryIfTwoApcDCOffsetSupport(unsigned int ms_timeout);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_QueryIfTwoApcDCOffsetSupport_r(const int meta_handle, unsigned int ms_timeout);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_MultiSlot_TX_Ex_r
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex(unsigned int ms_timeout, const Rf_MultiSlotTXEx_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const Rf_MultiSlotTXEx_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetRFID_r
 */
META_RESULT  __stdcall META_Rf_GetRFID(unsigned int ms_timeout, RFMod_ID* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetRFID_r(const int meta_handle, unsigned int ms_timeout, RFMod_ID* cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_CONTINUE_TX_Ex_r
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex(unsigned int ms_timeout, const RfCnTxEx_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfCnTxEx_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetBBTxCfg3_r
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg3(unsigned int ms_timeout, const RfBBTXCfg3*  tx_cfg_req, RfBBTXCfg3*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg3_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg3*  tx_cfg_req, RfBBTXCfg3*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetBBTxCfg3_r
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg3(unsigned int ms_timeout, RfBBTXCfg3*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg3_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg3*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_CONTINUE_TX_Ex2_r
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex2(unsigned int ms_timeout, const RfCnTxEx2_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex2_r(const int meta_handle, unsigned int ms_timeout, const RfCnTxEx2_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetAfcDacValueAtRTXOffsetCal_r
 */
META_RESULT  __stdcall META_Rf_GetAfcDacValueAtRTXOffsetCal(unsigned int ms_timeout, RfGetAfcDacValueAtRTXOffsetCal* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetAfcDacValueAtRTXOffsetCal_r(const int meta_handle, unsigned int ms_timeout, RfGetAfcDacValueAtRTXOffsetCal* cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetBBTxCfg4_r
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg4(unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg4_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetBBTxCfg4_r
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg4(unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg4_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetBBTxCfg5_r
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg5(unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg5_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetBBTxCfg5_r
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg5(unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg5_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetBBTxCfg6_r
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg6(unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetBBTxCfg6_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetBBTxCfg6_r
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg6(unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetBBTxCfg6_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);



//-----------------------------------------------------//
//  RunTime Setting Functions Without Update NVRAM     //
//-----------------------------------------------------//
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRampTable_r
 */
META_RESULT  __stdcall META_Rf_SetRampTable(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetRampTable_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRampApcLevel_r
 */
META_RESULT  __stdcall META_Rf_SetRampApcLevel(const RfSetRampApcLevel_Req* req, const META_RF_SET_RAMPAPCLEVEL_CNF  cb, short* token, void* usrData);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetRampApcLevel_r(const int meta_handle, const RfSetRampApcLevel_Req* req, const META_RF_SET_RAMPAPCLEVEL_CNF  cb, short* token, void* usrData);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_EPSK_SetRampTable_r
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_EPSK_SetRampTable_Ex_r
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_EPSK_SetRampTable_Ex2_r
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex2(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex2_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);

/**
 * \ingroup GSMStruct
 * The maximum allowable number of GSM RX sub-band division, note that "end-mark" would occupy one entry also
 */
#define  PLTABLE_SIZE  13

typedef struct
{
    short    max_arfcn;
    char     path_loss_H;
    char     path_loss_M;
    char     path_loss_M_Sawless;
    char     path_loss_L;
} RfPathLossOffset;

typedef struct
{
    RfPathLossOffset    rx_pathloss[FrequencyBandCount][PLTABLE_SIZE];
} RfTestCmdSetGetRxPathLoss;

typedef struct
{
    char is_uplate_to_NVRAM;
    RfTestCmdSetGetRxPathLoss    set_rx_pathloss;
} RfTestCmdSetRxPathLoss;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRxPathLoss_r
 */
META_RESULT __stdcall  META_Rf_SetRxPathLoss(const unsigned int ms_timeout, const RfTestCmdSetRxPathLoss* req);
/**
 * \ingroup GSM
 * \details set rx path loss by L1 command
 * \param meta_handle meta handle
 * \param ms_timeout time out (ms)
 * \param req the request structure of set rx path loss
 */

META_RESULT __stdcall  META_Rf_SetRxPathLoss_r(const int meta_handle, const unsigned int ms_timeout, const RfTestCmdSetRxPathLoss* req);
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetRxPathLoss_r
 */
META_RESULT __stdcall  META_Rf_GetRxPathLoss(const unsigned int ms_timeout, RfTestCmdSetGetRxPathLoss* cnf);
/**
 * \ingroup GSM
 * \details get rx path loss by L1 command
 * \param meta_handle meta handle
 * \param ms_timeout time out (ms)
 * \param cnf the confirm structure of get rx path loss
 */
META_RESULT __stdcall  META_Rf_GetRxPathLoss_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetGetRxPathLoss* cnf);

/**
 * \ingroup GSMStruct
 * This structure defines RX pathloss calibration data of a sub-band
 */
typedef struct
{
   /**
    * Sub-band ARFCN
    * \sa ARFCN
    */
    short    max_arfcn;
   /**
    * Pathloss for LNA high mode
    */
    char     path_loss_H;
   /**
    * Pathloss for LNA middle mode
    */
    char     path_loss_M;
   /**
    * Pathloss for LNA middle mode with saw-less
    * - Mid Gain for remove saw filter and add TLF filter
    */
    char     path_loss_M_Sawless;
   /**
    * Pathloss for LNA low mode
    */
    char     path_loss_L;
   /**
    * Pathloss for LNA high mode (for mode operating in DL power near sensitivity level)
    * - Ultra High Gain used when DL Power is very small, use this gain to get more sensitivity
    */
    char     path_loss_H_sensitivity;
   /**
    * Pathloss for LNA low mode (for mode operating in high DL power)
    * - Bypass Low Gain for eLNA with bypass mode, and used when user is close to eNB and close elna to let DL Power will not saturate
    */
    char     path_loss_L_maxpin;
} RfPathLossOffsetV3;

/**
 * \ingroup GSMStruct
 * This structure defines RX pathloss calibration data
 */
typedef struct
{
   /**
    * RX pathloss calibration data
    */
    RfPathLossOffsetV3    rx_pathloss[FrequencyBandCount][PLTABLE_SIZE];
} RfTestCmdSetGetRxPathLossV3;
/**
 * \ingroup GSMStruct
 * This structure defines parameter for updating RX pathloss calibration data to DUT
 */
typedef struct
{
   /**
    * Indicator to notify L1 driver whether the data needs to update to NVRAM or not
    */
    char is_uplate_to_NVRAM;
   /**
    * RX pathloss calibration data
    */
    RfTestCmdSetGetRxPathLossV3    set_rx_pathloss;
} RfTestCmdSetRxPathLossV3;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRxPathLossV3_r
 */
META_RESULT __stdcall  META_Rf_SetRxPathLossV3(const unsigned int ms_timeout, const RfTestCmdSetRxPathLossV3* req);

/**
 * \details For updating GSM RX calibration results to DUT
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req RX pathloss calibration data to be updated to DUT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall  META_Rf_SetRxPathLossV3_r(const int meta_handle, const unsigned int ms_timeout, const RfTestCmdSetRxPathLossV3* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetRxPathLossV3_r
 */
META_RESULT __stdcall  META_Rf_GetRxPathLossV3(const unsigned int ms_timeout, RfTestCmdSetGetRxPathLossV3* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_GetRxPathLossV3_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetGetRxPathLossV3* cnf);

typedef struct
{
    FrequencyBand eFreqBand; ///< band indicator
    char          cTxAdc_State; ///< 0: normal mode, 1: cal TXADC, 2:cal subband
    char          is_EPSK; ///< 1: EPSK, 0: GMSK
} MEAT_RF_RESET_PD_DATA_T;
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_TXPC_CL_ResetPdData_r
 */
META_RESULT  __stdcall META_Rf_TXPC_CL_ResetPdData(unsigned int ms_timeout, const MEAT_RF_RESET_PD_DATA_T* pTxPc_ResetPD);
/**
 * \ingroup GSM
 * \details reset pd value and let L1D knowing that currently
 *              is calibrating normal mode, TXADC, or subband.
 *
 * \param meta_handle meta handle
 * \param ms_timeout time out (ms)
 * \param pTxPc_ResetPD the request structure of reset PD data
 *
 */
META_RESULT  __stdcall META_Rf_TXPC_CL_ResetPdData_r(const int meta_handle, unsigned int ms_timeout, const MEAT_RF_RESET_PD_DATA_T* pTxPc_ResetPD);
//===================================

/**
 * \ingroup GSMStruct
 * Numbers of PCL in GSM
 */
#define  PA_OCT_16_LEVEL 16
typedef struct
{
    short          pcl_index;
    unsigned char  pa_vbias;
    unsigned short pa_gain;
} epsk_pa_vbias;

typedef struct
{
    epsk_pa_vbias GSM850_8pa_vbias[PA_OCT_16_LEVEL];
    epsk_pa_vbias GSM900_8pa_vbias[PA_OCT_16_LEVEL];
    epsk_pa_vbias DCS1800_8pa_vbias[PA_OCT_16_LEVEL];
    epsk_pa_vbias PCS1900_8pa_vbias[PA_OCT_16_LEVEL];
} EPSK_8PA_VBIAS;

typedef struct
{
    EPSK_8PA_VBIAS data;
} RF_EPSK_8PA_TX_Coef;

typedef struct
{
    RF_EPSK_8PA_TX_Coef  tx;
} RF_EPSK_8PA_SPECIAL_Coef_T;

/**
 * \ingroup GSMStruct
 * This structure defines the parameter of PA Vbias settings
 */
typedef struct
{
    /**
     * band indicator
     */
    unsigned char band;

    /**
     * PA Oct level data (in peer buffer)
     */
    unsigned short pa_gain[PA_OCT_16_LEVEL];
} RfEpskSetTxPaOctLevData;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_EPSK_SetTxPaOctLevData_Ex_r
 */
META_RESULT  __stdcall META_Rf_EPSK_SetTxPaOctLevData_Ex(unsigned int ms_timeout, const RfEpskSetTxPaOctLevData*  p_pa_oct_data);
/**
 * \details For updating GSM TX cal results of PA Vbias to DUT
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] p_pa_oct_data Parameters of PA Vbias settings to update to DUT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_EPSK_SetTxPaOctLevData_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfEpskSetTxPaOctLevData*  p_pa_oct_data);

/**
  * \ingroup NVRAM
  * \sa non-reentrant version of META_NVRAM_Compose_EPSKtxPaOctLevData_r
  */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_EPSKtxPaOctLevData(const RF_EPSK_8PA_SPECIAL_Coef_T* epsk_specialCoef, char* buf, const int buf_len);
/**
  * \ingroup NVRAM
  */
META_RESULT  __stdcall META_NVRAM_Compose_EPSKtxPaOctLevData_r(const int meta_handle, const RF_EPSK_8PA_SPECIAL_Coef_T* epsk_specialCoef, char* buf, const int buf_len);
/**
  * \ingroup NVRAM
  * \sa non-reentrant version of META_NVRAM_DeCompose_EPSKtxPaOctLevData_r
  */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_DeCompose_EPSKtxPaOctLevData(RF_EPSK_8PA_SPECIAL_Coef_T* epsk_specialCoef, const char* buf, const int buf_len);
/**
  * \ingroup NVRAM
  */
META_RESULT  __stdcall META_NVRAM_DeCompose_EPSKtxPaOctLevData_r(const int meta_handle, RF_EPSK_8PA_SPECIAL_Coef_T* epsk_specialCoef, const char* buf, const int buf_len);
//===================================

typedef struct
{
    ARFCN           arfcn;          ///< absolute radio frequency channel number
    BSIC            bsic;            ///< training sequence
    CodingScheme    cs;     ///< coding scheme for each time slot, MCS1~9 is only valid for EPSK function
    TimingAdvance   ta;       ///< time advance
    int             frames;        ///< the number of frames should transmit
    short           dacValue;    ///< AFC DAC value
    APCTxPattern    pattern;            ///< Tx pattern is only valid for EPSK function
    unsigned short  pattern_data;   ///< if NB_TX_PATTERN_WITHOUT_TSC==pattern, user can input any 16bits value as pattern.
    unsigned short  pa_gain;           ///< pa gain from ini file
    unsigned short  pa_vbias;         ///< pa vbias from ini file
    unsigned char   rf_gain_index; ///< gain rf index
} Rf_GainRfTx_Req;
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GainRf_TX_r
 */
META_RESULT  __stdcall META_Rf_GainRf_TX(unsigned int ms_timeout, const Rf_GainRfTx_Req* req);
/**
 * \details start EDGE TX signal indicated by gain index
  * \ingroup GSM
 * \param meta_handle meta handler
 * \param ms_timeout time out (ms)
 * \param req Rf_GainRfTx_Req
 **/
 
META_RESULT  __stdcall META_Rf_GainRf_TX_r(const int meta_handle, unsigned int ms_timeout, const Rf_GainRfTx_Req* req);
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryNumOfGainRf_r
 */
META_RESULT  __stdcall META_Rf_QueryNumOfGainRf(unsigned int ms_timeout, unsigned char* ucNumOfGainRf);
/**
 * \details RF gain number query API
 * \ingroup GSM
 * \param meta_handle meta handler
 * \param ms_timeout time out (ms)
 * \param ucNumOfGainRf the space to store result
 **/
META_RESULT  __stdcall META_Rf_QueryNumOfGainRf_r(const int meta_handle, unsigned int ms_timeout, unsigned char* ucNumOfGainRf);
#define MAX_GAIN_RF_NUM 64
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryBBPowerList_r
 */
META_RESULT  __stdcall META_Rf_QueryBBPowerList(unsigned int ms_timeout, short* sBBPowerArrary, unsigned char ucArraySize);
/**
 * \details Gain power array query function
 * \ingroup GSM
 * \param meta_handle meta handler
 * \param ms_timeout time out (ms)
 * \param sBBPowerArrary the space to store the gain power array
 * \param ucArraySize the size of the storing space
 **/
META_RESULT  __stdcall META_Rf_QueryBBPowerList_r(const int meta_handle, unsigned int ms_timeout, short* sBBPowerArrary, unsigned char ucArraySize);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_EPSK_SetRampApcLevel_r
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampApcLevel(unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_EPSK_SetRampApcLevel_r(const int meta_handle, unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRFImmediateBSI_r
 */
META_RESULT  __stdcall META_Rf_SetRFImmediateBSI(unsigned int ms_timeout, const unsigned int bsi_data);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetRFImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, const unsigned int bsi_data);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetRFImmediateBSI_r
 */
META_RESULT  __stdcall META_Rf_GetRFImmediateBSI(unsigned int ms_timeout, unsigned int bsi_addr, unsigned int* p_bsi_data);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetRFImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, unsigned int bsi_addr, unsigned int* p_bsi_data);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRampTable_Ex_r
 */
META_RESULT  __stdcall META_Rf_SetRampTable_Ex(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetRampTable_Ex_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRampTable_Ex2_r
 */
META_RESULT  __stdcall META_Rf_SetRampTable_Ex2(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetRampTable_Ex2_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);

// Skyworks
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SKY74045_SetSpecialCoef_r
 */
META_RESULT  __stdcall META_Rf_SKY74045_SetSpecialCoef(unsigned int ms_timeout, const RF_SKY74045_Coef_T* rf_mod_coef);
/**
 * \ingroup GSM
 */
META_RESULT  __stdcall META_Rf_SKY74045_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_SKY74045_Coef_T* rf_mod_coef);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SKY74117_SetSpecialCoef_r
 */
META_RESULT  __stdcall META_Rf_SKY74117_SetSpecialCoef(unsigned int ms_timeout, const RF_SKY74117_Coef_T* rf_mod_coef);
/**
 * \ingroup GSM
 */
META_RESULT  __stdcall META_Rf_SKY74117_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_SKY74117_Coef_T* rf_mod_coef);

// MT6139B

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_MT6139B_SetSpecialCoef_r
 */
META_RESULT  __stdcall META_Rf_MT6139B_SetSpecialCoef(unsigned int ms_timeout, const RF_MT6139B_Coef_T* rf_mod_coef);
/**
 * \ingroup GSM
 */
META_RESULT  __stdcall META_Rf_MT6139B_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_MT6139B_Coef_T* rf_mod_coef);

// Renesas Bright5P

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_BRIGHT5P_SetSpecialCoef_r
 */
META_RESULT  __stdcall META_Rf_BRIGHT5P_SetSpecialCoef(unsigned int ms_timeout, const RF_BRIGHT5P_Coef_T* rf_mod_coef);
/**
 * \ingroup GSM
 */
META_RESULT  __stdcall META_Rf_BRIGHT5P_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_BRIGHT5P_Coef_T* rf_mod_coef);

//---------------------------------------------------------------------------------------------------
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_32kCalibration_r
 */
META_RESULT  __stdcall META_Rf_32kCalibration(unsigned int ms_timeout, int* p_result);
/**
 * \ingroup GSM
 */
META_RESULT  __stdcall META_Rf_32kCalibration_r(const int meta_handle, unsigned int ms_timeout, int* p_result);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_AD6546_SetSpecialCoef_r
 */
META_RESULT  __stdcall META_Rf_AD6546_SetSpecialCoef(unsigned int ms_timeout, const ad6546tx* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_AD6546_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const ad6546tx* rf_mod_coef, const char* buf, const int buf_len);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDL_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDL(unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req,  Rf_DTS_CNF_T* fdt_dl_cnf);
/**
 * \ingroup GSM
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) before M30, MaxStep=50, Without Lpm Calibration, Result is fdt_dl_cnf
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] fdt_dl_req, it is input parameter for RX Calibration
 * \param [out] fdt_dl_cnf, it is result for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDL_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req,  Rf_DTS_CNF_T* fdt_dl_cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtUL_r
 */
META_RESULT  __stdcall META_Rf_StartFdtUL(unsigned int ms_timeout, const Rf_UTS_REQ_T*  fdt_ul_req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_StartFdtUL_r(const int meta_handle, unsigned int ms_timeout, const Rf_UTS_REQ_T*  fdt_ul_req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryMSCapabilityEx2_r
 */
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx2(unsigned int ms_timeout, RfMsCapabilityEx2_S*  p_ms_cap);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx2_r(const int meta_handle, unsigned int ms_timeout, RfMsCapabilityEx2_S*  p_ms_cap);

typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} RfMsCapabilityEx3_REQ_S;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryMSCapabilityEx3_r
 */
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx3(unsigned int ms_timeout, const RfMsCapabilityEx3_REQ_S* req, RfMsCapabilityEx3_S* ms_cap);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx3_r(const int meta_handle, unsigned int ms_timeout, const RfMsCapabilityEx3_REQ_S* req, RfMsCapabilityEx3_S* ms_cap);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetAFCDacTRxOffset_r
 */
META_RESULT  __stdcall META_Rf_GetAFCDacTRxOffset(unsigned int ms_timeout, //const int rf_band_req,
        RF_GET_AFC_DAC_OFFSET_CNF_T* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetAFCDacTRxOffset_r(const int meta_handle,
        unsigned int ms_timeout,
        RF_GET_AFC_DAC_OFFSET_CNF_T* cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetAFCDacTRxOffset_r
 */
META_RESULT  __stdcall META_Rf_SetAFCDacTRxOffset(unsigned int ms_timeout, const RF_SET_AFC_DAC_OFFSET_REQ_T* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetAFCDacTRxOffset_r(const int meta_handle,
        unsigned int ms_timeout,
        const RF_SET_AFC_DAC_OFFSET_REQ_T* req);


//--------------------------------------------------------------------------//
//  BER NSFT (Bit Error Rate in Non-signaling Final Test) : not release     //
//--------------------------------------------------------------------------//
typedef struct
{
    FrequencyBand   band;
    ARFCN           BCH_ARFCN;
    ARFCN           TCH_ARFCN;
    Gain            BCH_gain;
    Gain            TCH_gain;
    TSC             tsc;
    TimeSlot        TCH_slot;
    Power           tx_power_level;
    bool            is_EPSK_tx;
    CodingScheme    epsk_cs;
} Rf_NSFT_REQ_T;

typedef struct
{
    Power tx_power_level;
} Rf_NSFT_TX_POWERE_REQ_T;

typedef struct
{
    Power           tx_power_level;
    CodingScheme    epsk_cs;
    TimeSlot        TCH_slot;
} Rf_NSFT_EPSK_MOD_CHANGE_REQ_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_Start_r
 */
META_RESULT  __stdcall META_Rf_NSFT_Start(unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 * Start the BER NSFT process
 */
META_RESULT  __stdcall META_Rf_NSFT_Start_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_ChangeSettings_r
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings(unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 * In NSFT process, change the frequency channel
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_Stop_r
 */
META_RESULT  __stdcall META_Rf_NSFT_Stop(unsigned int ms_timeout);
/**
 * \ingroup GSM
 * \brief ToBeDo
 * Stop the BER NSFT porcess
 */
META_RESULT  __stdcall META_Rf_NSFT_Stop_r(const int meta_handle, unsigned int ms_timeout);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_ChangePower_r
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangePower(unsigned int ms_timeout, const Rf_NSFT_TX_POWERE_REQ_T* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 * In NSFT TX performance test, change different tx power.
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangePower_r(const int meta_handle, unsigned int ms_timeout, const Rf_NSFT_TX_POWERE_REQ_T* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_ChangeToEPSK_r
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangeToEPSK(unsigned int ms_timeout, const Rf_NSFT_EPSK_MOD_CHANGE_REQ_T* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 * In NSFT TX performance test, change to EPSK mode and set tx power.
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangeToEPSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_NSFT_EPSK_MOD_CHANGE_REQ_T* req);

//--------------------------------------------------------------------------//
//  2G List Mode NSFT                                                               //
//--------------------------------------------------------------------------//
/**
 * \ingroup GSMStruct
 */
typedef enum
{
    NSFT_LM_MCS_TYPE_GMSK = 0,
    NSFT_LM_MCS_TYPE_QPSK = 1,
    NSFT_LM_MCS_TYPE_MAX  = 0xFFFF
} NsftListModType;

/**
 * \ingroup GSMStruct
 * GSM list-mode NSFT command type
 */
typedef enum
{
    NSFT_LM_CMD_NULL    = 0,   ///< Null
    NSFT_LM_CMD_SYNC    = 1,   ///< Sync-process
    NSFT_LM_CMD_TRIGGER = 2,   ///< Trigger-instrument-process
    NSFT_LM_CMD_CHMEAS  = 3,   ///< Test-process
    NSFT_LM_CMD_STOP    = 4,   ///< Stop-process
    NSFT_LM_CMD_END     = 0xFF ///< not used
} NsftListCmdType;

/**
 * \ingroup GSMStruct
 */
typedef enum
{
    NSFT_LM_EXECUTION_NULL    = 0,
    NSFT_LM_EXECUTION_INIT    = 1,
    NSFT_LM_EXECUTION_START   = 2,
    NSFT_LM_EXECUTION_DONE    = 3,
    NSFT_LM_EXECUTION_FAIL    = 4,
    NSFT_LM_EXECUTION_STA_MAX = 0xFFFF
} NsftListCmdStatus;

/**
 * \ingroup GSMStruct
 * GSM list-mode NSFT common parameter
 */
typedef struct
{
   /**
    * NSFT command type
    * \sa NsftListCmdType
    */
    unsigned char cmd_type;
} Rf_LIST_MODE_NSFT_COMMON_REQ;

/**
 * \ingroup GSMStruct
 * Parameters for list-mode NSFT command element: sync-process
 */
typedef struct
{
   /**
    * GSM list-mode NSFT common parameter
    */
    Rf_LIST_MODE_NSFT_COMMON_REQ common;
   /**
    * GSM Band
    * \sa FrequencyBand
    */
    unsigned char              rf_band;
   /**
    * GSM ARFCN
    * \sa ARFCN
    */
    unsigned short             sync_arfcn;
   /**
    * DL power level for sync signal (cell power), in unit of 1/8 dB
    * \sa Power
    */
    short                     sync_power;
   /**
    * Frame boundary (in unit of slot) between sync-signal to test-process, namely, DUT would adjust frame boundary by this setting after sync to instrument
    */
    unsigned char              sync_slot_offset;
} Rf_LIST_MODE_NSFT_SYNC_REQ;

/**
 * \ingroup GSMStruct
 * Parameters for list-mode NSFT command element: trigger-instrument-process
 */
typedef struct
{
   /**
    * GSM list-mode NSFT common parameter
    */
    Rf_LIST_MODE_NSFT_COMMON_REQ common;
   /**
    * GSM Band
    * \sa FrequencyBand
    */
    unsigned char              rf_band;
   /**
    * GSM ARFCN
    * \sa ARFCN
    */
    unsigned short             arfcn;
   /**
    * Training Sequence Code (spec. defined)
    * \sa TSC
    */
    unsigned char              tsc;
   /**
    * UL signal type (0: GMSK, 1: EPSK)
    */
    unsigned char              rtx_types;
   /**
    * UL PCL setting (for triggering instrument)
    */
    short                      tx_pcl;
} Rf_LIST_MODE_NSFT_TRIGGER_REQ;

/**
 * \ingroup GSMStruct
 * Maximum number of PCL to be test within one NSFT test case
 */
#define RF_MAX_LIST_MODE_TX_MEAS_COUNT 8

/**
 * \ingroup GSMStruct
 * Parameters for list-mode NSFT command element: test-process
 */
typedef struct
{
   /**
    * GSM list-mode NSFT common parameter
    */
    Rf_LIST_MODE_NSFT_COMMON_REQ common;
   /**
    * GSM Band
    * \sa FrequencyBand
    */
    unsigned char              rf_band;
   /**
    * GSM ARFCN
    * \sa ARFCN
    */
    unsigned short             arfcn;
   /**
    * Training Sequence Code (spec. defined)
    * \sa TSC
    */
    unsigned char              tsc;
   /**
    * UL signal type (0: GMSK, 1: EPSK)
    */
    unsigned char              rtx_types;
   /**
    * PCL to be test within one NSFT test case
    */
    char                      tx_pcl[RF_MAX_LIST_MODE_TX_MEAS_COUNT];
   /**
    * DL power level for BER test (in unit of 1/8 dB)
    * \sa Power
    */
    short                     rx_power;
   /**
    * Repeat count (in unit of GSM block) of each PCL
    */
    char                      repeat_count[RF_MAX_LIST_MODE_TX_MEAS_COUNT];
} Rf_LIST_MODE_NSFT_CHMEAS_REQ;

/**
 * \ingroup GSMStruct
 * Union of request parameters for list-mode NSFT
 */
typedef union
{
   /**
    * Parameters for list-mode NSFT command element: sync-process
    */
    Rf_LIST_MODE_NSFT_SYNC_REQ    sync;
   /**
    * Parameters for list-mode NSFT command element: trigger-instrument-process
    */
    Rf_LIST_MODE_NSFT_TRIGGER_REQ trigger;
   /**
    * Parameters for list-mode NSFT command element: test-process
    */
    Rf_LIST_MODE_NSFT_CHMEAS_REQ  test;
} Rf_LIST_MODE_NSFT_COMMAND_T;

/**
 * \ingroup GSMStruct
 * Maximum step counts for NSFT sync-process in single list-mode NSFT command
 */
#define RF_MAX_LIST_MODE_SYNC_COUNT 5
/**
 * \ingroup GSMStruct
 * Maximum step counts for NSFT trigger-instrument-process in single list-mode NSFT command
 */
#define RF_MAX_LIST_MODE_TRIGGER_COUNT 5
/**
 * \ingroup GSMStruct
 * Maximum step counts for NSFT test-process in single list-mode NSFT command
 */
#define RF_MAX_LIST_MODE_CH_COUNT 50
/**
 * \ingroup GSMStruct
 * Maximum sub-command counts for single list-mode command
 */
#define RF_MAX_LIST_MODE_COMMAND_COUNT (RF_MAX_LIST_MODE_CH_COUNT + RF_MAX_LIST_MODE_SYNC_COUNT + RF_MAX_LIST_MODE_TRIGGER_COUNT)

/**
 * \ingroup GSMStruct
 * Request parameters for triggering list-mode NSFT
 */
typedef struct
{
   /**
    * List-mode command count
    */
    unsigned char               ucCmdCount;
   /**
    * Parameters for List-mode NSFT
    */
    Rf_LIST_MODE_NSFT_COMMAND_T   command[RF_MAX_LIST_MODE_COMMAND_COUNT];
} Rf_LIST_MODE_NSFT_REQ_T;

/**
 * \ingroup GSMStruct
 * GSM list-mode NSFT common confirm parameter
 */
typedef struct
{
   /**
    * NSFT command type
    * \sa NsftListCmdType
    */
    unsigned char         cmd_type;
   /**
    * Command execution status (enumerator)\n
    * - 0: NULL state
    * - 1: Initial state
    * - 2: Start state
    * - 3: Done state
    * - 4: Fail state
    */
    unsigned short        status;
} Rf_LIST_MODE_NSFT_COMMON_CNF;

/**
 * \ingroup GSMStruct
 * Confirm message for list-mode NSFT command element: sync-process
 */
typedef struct
{
   /**
    * GSM list-mode NSFT common confirm message
    */
    Rf_LIST_MODE_NSFT_COMMON_CNF   common;
   /**
    * Sync-process retry count (before sync to instrument scuessfully)
    */
    unsigned short               retry_count;
   /**
    * Used AFC DAC value
    */
    short                       afc_dac;
   /**
    * Detected FoE during sync-process
    */
    int                         detected_foe;
} Rf_LIST_MODE_NSFT_SYNC_CNF;

/**
 * \ingroup GSMStruct
 * Confirm message for list-mode NSFT command element: trigger-instrument-process
 */
typedef struct
{
   /**
    * GSM list-mode NSFT common confirm message
    */
    Rf_LIST_MODE_NSFT_COMMON_CNF common;
} Rf_LIST_MODE_NSFT_TRIGGER_CNF;

/**
 * \ingroup GSMStruct
 * Confirm message for list-mode NSFT command element: test-process
 */
typedef struct
{
   /**
    * GSM list-mode NSFT common confirm message
    */
    Rf_LIST_MODE_NSFT_COMMON_CNF common;
   /**
    * Measured RSSI in RX_LEV format (spec. defined)
    */
    unsigned short             rx_level;
   /**
    * Detected error bit sum (in unit of error_bits * 1000 / 114)
    */    unsigned int               BER_sum;
   /**
    * BER measurement duration (in unit of TDMA frame)
    */    unsigned int               BER_frame_count;
} Rf_LIST_MODE_NSFT_CHMEAS_CNF;

/**
 * \ingroup GSMStruct
 * Union of confirm message for list-mode NSFT
 */
typedef union
{
   /**
    * Confirm message for list-mode NSFT command element: sync-process
    */
    Rf_LIST_MODE_NSFT_SYNC_CNF    sync;
   /**
    * Confirm message for list-mode NSFT command element: trigger-instrument-process
    */
    Rf_LIST_MODE_NSFT_TRIGGER_CNF trigger;
   /**
    * Confirm message for list-mode NSFT command element: test-process
    */
    Rf_LIST_MODE_NSFT_CHMEAS_CNF  test;
} Rf_LIST_MODE_NSFT_RPT_T;
/**
 * \ingroup GSMStruct
 * Confirm of list-mode NSFT
 */
typedef struct
{
   /**
    * List-mode confirm count
    */
    unsigned char               ucCnfCount;
   /**
    * Confirm of List-mode NSFT
    */
    Rf_LIST_MODE_NSFT_RPT_T      report[RF_MAX_LIST_MODE_COMMAND_COUNT];
} Rf_LIST_MODE_NSFT_RPT_CNF_T;

// Start the LIst Mode NSFT process
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_List_Mode_NSFT_Start_r
 */
META_RESULT  __stdcall META_Rf_List_Mode_NSFT_Start(unsigned int ms_timeout, const  Rf_LIST_MODE_NSFT_REQ_T* req, Rf_LIST_MODE_NSFT_RPT_CNF_T* cnf);

/**
 * \details For triggering GSM TX NSFT and BER test
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Request parameters for triggering GSM TX NSFT and BER test
 * \param [out] cnf Confirm message of list mode NSFT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_List_Mode_NSFT_Start_r(const int meta_handle, unsigned int ms_timeout, const  Rf_LIST_MODE_NSFT_REQ_T* req, Rf_LIST_MODE_NSFT_RPT_CNF_T* cnf);

/**
 * \ingroup GSM
 * \brief query OE PATTERN ready (NO OP function, just for query)
 */
META_RESULT  __stdcall META_Rf_OE_Pattern_Ready(void);

/**
 * \ingroup GSM
 * \brief query OE PATTERN ready (NO OP function, just for query)
 */
META_RESULT  __stdcall META_Rf_AFC_Type_Query_Ready(void);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_PowerOn_r
 */
META_RESULT  __stdcall META_Rf_PowerOn(unsigned int ms_timeout);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_PowerOn_r(const int meta_handle, unsigned int ms_timeout);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_PowerOff_r
 */
META_RESULT  __stdcall META_Rf_PowerOff(unsigned int ms_timeout);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_PowerOff_r(const int meta_handle, unsigned int ms_timeout);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_QueryPowerState_r
 */
META_RESULT  __stdcall META_Rf_QueryPowerState(unsigned int ms_timeout, char* pRfPwrState);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_QueryPowerState_r(const int meta_handle, unsigned int ms_timeout,  char* pRfPwrState);

typedef struct
{
    char rollback_2t;
    char rollback_3t;
    char rollback_4t;
    char rollback_5t;
} sTX_POWERROLLBACK;

typedef struct
{
    int band;
    sTX_POWERROLLBACK PowerRollbackTable;
} Rf_TX_ROLLBACK_REQ_T;

typedef struct
{
    sTX_POWERROLLBACK   rollback_data[FrequencyBandCount];
} l1cal_tx_power_rollback_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTXPowerRollbackGMSK_r
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackGMSK(unsigned int ms_timeout, Rf_TX_ROLLBACK_REQ_T* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackGMSK_r(const int meta_handle, unsigned int ms_timeout,  Rf_TX_ROLLBACK_REQ_T* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTXPowerRollbackEPSK_r
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackEPSK(unsigned int ms_timeout, Rf_TX_ROLLBACK_REQ_T* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackEPSK_r(const int meta_handle, unsigned int ms_timeout,  Rf_TX_ROLLBACK_REQ_T* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTXPowerRollbackTableGMSK_r
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableGMSK(unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableGMSK_r(const int meta_handle, unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTXPowerRollbackTableEPSK_r
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableEPSK(unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableEPSK_r(const int meta_handle, unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);

typedef struct
{
    unsigned short data[16];
} sTXPC_ADCDATA;

typedef struct
{
    unsigned short data[8];
} sTXPC_TEMPDATA;

typedef struct
{
    char           is_calibrated;
    sTXPC_ADCDATA  adc[FrequencyBandCount];
    short          temperature;
    sTXPC_TEMPDATA temp[FrequencyBandCount];
} sTXPC_L1CAL;

typedef sTXPC_L1CAL l1cal_txpc_T;

typedef struct
{
    unsigned char  band;
    short pcl;
} Rf_GET_TXPC_PD_REQ_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCDetectorValueByPCLGMSK_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLGMSK(unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLGMSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCDetectorValueByPCLEPSK_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLEPSK(unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLEPSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCDetectorValueGMSK_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueGMSK(unsigned int ms_timeout, l1cal_txpc_T* table);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueGMSK_r(const int meta_handle, unsigned int ms_timeout, l1cal_txpc_T* table);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCDetectorValueEPSK_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueEPSK(unsigned int ms_timeout, l1cal_txpc_T* table);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueEPSK_r(const int meta_handle, unsigned int ms_timeout, l1cal_txpc_T* table);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCSubbandCompensationGMSK_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSK(unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSK_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCSubbandCompensationEPSK_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSK(unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSK_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);
typedef struct
{
    short data[11];
} txpc_subband_comp_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCSubbandCompensationGMSKEx_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSKEx(unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSKEx_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCSubbandCompensationEPSKEx_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSKEx(unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSKEx_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTXPCTemperature_r
 */
META_RESULT  __stdcall META_Rf_GetTXPCTemperature(unsigned int ms_timeout, unsigned short* temperature);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetTXPCTemperature_r(const int meta_handle, unsigned int ms_timeout, unsigned short* temperature);
typedef struct
{
    short w_re[19];
    short w_im[19];
} RF_AvgW_Coef_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetSpecialCoef_r
 */
META_RESULT  __stdcall META_Rf_GetSpecialCoef(unsigned int ms_timeout, unsigned int rfid, void* coef_struct);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_GetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, unsigned int rfid, void* coef_struct);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_ConfigSBER_r
 */
META_RESULT  __stdcall META_Rf_NSFT_ConfigSBER(unsigned int ms_timeout, const unsigned int test_frame_count);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_NSFT_ConfigSBER_r(const int meta_handle, unsigned int ms_timeout, const unsigned int test_frame_count);
typedef struct
{
    unsigned int m_u4NSFTSBERSum;
    unsigned int m_u4NSFTSBERCurrentCount;
} RF_NSFT_SBERResult_T;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_GetSBER_r
 */
META_RESULT  __stdcall META_Rf_NSFT_GetSBER(unsigned int ms_timeout, RF_NSFT_SBERResult_T* sber_result);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_NSFT_GetSBER_r(const int meta_handle, unsigned int ms_timeout, RF_NSFT_SBERResult_T* sber_result);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_StartRxLevel_r
 */
META_RESULT  __stdcall META_Rf_NSFT_StartRxLevel(unsigned int ms_timeout);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_NSFT_StartRxLevel_r(const int meta_handle, unsigned int ms_timeout);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_GetRxLevel_r
 */
META_RESULT  __stdcall META_Rf_NSFT_GetRxLevel(unsigned int ms_timeout, unsigned short* rx_level);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_NSFT_GetRxLevel_r(const int meta_handle, unsigned int ms_timeout, unsigned short* rx_level);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_GetRxQual_r
 */
META_RESULT  __stdcall META_Rf_NSFT_GetRxQual(unsigned int ms_timeout, const unsigned short ber_decile, unsigned char* rx_qual);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_NSFT_GetRxQual_r(const int meta_handle, unsigned int ms_timeout, const unsigned short ber_decile, unsigned char* rx_qual);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_AFC_Ex_r
 */
META_RESULT  __stdcall META_Rf_AFC_Ex(unsigned int ms_timeout, const RfAfc_Req* req, RfAfc_Cnf* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_AFC_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfAfc_Req* req, RfAfc_Cnf* cnf);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NB_TX_Ex_r
 */
META_RESULT  __stdcall META_Rf_NB_TX_Ex(unsigned int ms_timeout, const RfNbtx_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_NB_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfNbtx_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_CONTINUE_RX_Ex_r
 */
META_RESULT  __stdcall META_Rf_CONTINUE_RX_Ex(unsigned int ms_timeout, const RfCnRx_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_CONTINUE_RX_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfCnRx_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_CONTINUE_TX_Ex1_r
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex1(unsigned int ms_timeout, const RfCnTx_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex1_r(const int meta_handle, unsigned int ms_timeout, const RfCnTx_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetBBTXCfg_Ex_r
 */
META_RESULT  __stdcall META_Rf_SetBBTXCfg_Ex(unsigned int ms_timeout, const RfSetBBTXCfg_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetBBTXCfg_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfSetBBTXCfg_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SelectFrequencyBand1900_Ex_r
 */
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900_Ex(unsigned int ms_timeout, unsigned char selectPCS1900);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900_Ex_r(const int meta_handle, unsigned int ms_timeout, unsigned char selectPCS1900);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_Stop_Ex_r
 */
META_RESULT  __stdcall META_Rf_Stop_Ex(unsigned int ms_timeout);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_Stop_Ex_r(const int meta_handle, unsigned int ms_timeout);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_MultiSlot_TX_Ex1_r
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex1(unsigned int ms_timeout, const RfMultiSlotTX_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex1_r(const int meta_handle, unsigned int ms_timeout, const RfMultiSlotTX_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetAfcDacValue_Ex_r
 */
META_RESULT  __stdcall META_Rf_SetAfcDacValue_Ex(unsigned int ms_timeout, const RfSetAfcDacValue_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetAfcDacValue_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfSetAfcDacValue_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRampApcLevel_Ex_r
 */
META_RESULT  __stdcall META_Rf_SetRampApcLevel_Ex(unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetRampApcLevel_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetDcxoPowerMode_r
 */
META_RESULT  __stdcall META_Rf_SetDcxoPowerMode(unsigned int ms_timeout, unsigned char mode);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_SetDcxoPowerMode_r(const int meta_handle, unsigned int ms_timeout, unsigned char mode);

/********************************
 * CO TSX
 ********************************/
 /**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_MultiSlot_TX_Ex_AuxADCRead_r
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex_AuxADCRead(unsigned int ms_timeout, const RfMultiSlotTX_Req* req, unsigned short* piTemp);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex_AuxADCRead_r(const int meta_handle, unsigned int ms_timeout, const RfMultiSlotTX_Req* req, unsigned short* piTemp);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTemperatureInfo_r
 */
META_RESULT __stdcall META_Rf_GetTemperatureInfo(const unsigned int ms_timeout, META_Rf_TemperatureInfo_T* info);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall META_Rf_GetTemperatureInfo_r(const int meta_handle, const unsigned int ms_timeout, META_Rf_TemperatureInfo_T* info);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetDtPathFlag_r
 */
META_RESULT __stdcall META_Rf_SetDtPathFlag(const unsigned int ms_timeout, unsigned char path_flag);
/**
 * \ingroup GSM
 * \details Set GSM path to other path
 *          the path will be restored to default path (first path) after RF stop
 * \param meta_handle meta handle
 * \param ms_timeout time out (ms)
 * \param path_flag 0: first path 1: second path
 */
META_RESULT __stdcall META_Rf_SetDtPathFlag_r(const int meta_handle, const unsigned int ms_timeout, unsigned char path_flag);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetRfChipIdName_r
 */
const char* __stdcall META_Rf_GetRfChipIdName(unsigned int id);
/**
 * \ingroup GSM
 * \details get the RF chip ID name by given RF chip ID
 * \param id RF chip ID
 * \return constant pointer to the RF chip ID name
 */
const char* __stdcall META_Rf_GetRfChipIdName_r(const int meta_handle, unsigned int id);
/**
 * \ingroup GSMStruct
 * Data length of W-coefficient
 */
#define WCOEF_DATA_LENGTH    19
/**
 * \ingroup GSMStruct
 */
typedef struct
{
    short              w_re;
    short              w_im;
} RfTestWCoef;
/**
 * \ingroup GSMStruct
 *  This structure defines the W-coefficient calibration results
 */
typedef struct
{
   /**
    * W-coefficient calibration results
    */
    RfTestWCoef        w_data[WCOEF_DATA_LENGTH];
} RfTestWCoefData;
/**
 * \ingroup GSMStruct
 *  This structure defines the data of W-coefficient
 */
typedef struct
{
   /**
    * Indicator to notify L1 driver whether the data needs to update to NVRAM or not
    */
    bool               is_uplate_to_NVRAM;
   /**
    * Calibration results of W-coefficient
    */
    RfTestWCoefData    w_coef_data;
} RfTestCmdSetWCoef;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetWCoef_r
 */
META_RESULT __stdcall  META_Rf_SetWCoef(const unsigned int ms_timeout, RfTestCmdSetWCoef* req);

/**
 * \details For updating GSM W-coefficient calibration results to DUT
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req W-coefficient calibration results to be updated to DUT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall  META_Rf_SetWCoef_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetWCoef* req);

typedef struct
{
    RfTestWCoefData    w_coef_data;
} RfTestResultGetWCoef;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetWCoef_r
 */
META_RESULT __stdcall  META_Rf_GetWCoef(const unsigned int ms_timeout, RfTestResultGetWCoef* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_GetWCoef_r(const int meta_handle, const unsigned int ms_timeout, RfTestResultGetWCoef* cnf);
/**
 * \ingroup GSMStruct
 * Number of GMSK TX calibration data
 */
#define MAX_RF_TX_DATA_CMD_GMSK_BAND_NUM 4
/**
 * \ingroup GSMStruct
 * Number of EPSK TX calibration data
 */
 #define MAX_RF_TX_DATA_CMD_EPSK_BAND_NUM 4
/**
 * \ingroup GSMStruct
 * Number of TX calibration data
 */
 #define MAX_RF_TX_DATA_CMD_BAND_NUM (MAX_RF_TX_DATA_CMD_GMSK_BAND_NUM + MAX_RF_TX_DATA_CMD_EPSK_BAND_NUM)
/**
 * \ingroup GSMStruct
 * TX calibration data
 */
typedef l1cal_rampTable_T RfRamptableParam;
/**
 * \ingroup GSMStruct
 * Indicator of ramp_table[x]
 */
typedef struct
{
   /**
    * Indicate GMSK TX calibration data is in PDU to be updated to DUT or not
    * - 0: means ramp_table[x] for GMSK850  is enabled
    * - 1: means ramp_table[x] for GMSK900  is enabled
    * - 2: means ramp_table[x] for GMSK1800 is enabled
    * - 3: means ramp_table[x] for GMSK1900 is enabled
    */
    bool  gmsk_band_enabled[MAX_RF_TX_DATA_CMD_GMSK_BAND_NUM];
   /**
    * Indicate GMSK TX calibration data is in PDU to be updated to DUT or not
    * - 0: means ramp_table[x] for EPSK850  is enabled
    * - 1: means ramp_table[x] for EPSK900  is enabled
    * - 2: means ramp_table[x] for EPSK1800 is enabled
    * - 3: means ramp_table[x] for EPSK1900 is enabled
    */
    bool  epsk_band_enabled[MAX_RF_TX_DATA_CMD_EPSK_BAND_NUM];
} RfRamptableBandEnabled;
/**
 * \ingroup GSMStruct
 * GMSK and EPSK TX calibration data
 */
typedef struct
{
   /**
    * Indicator to notify L1 of what the data within ramp_table[x] is
    */
    RfRamptableBandEnabled  ramp_table_band_map;
   /**
    * GMSK and EPSK TX calibration data
    */
    RfRamptableParam        ramp_table[MAX_RF_TX_DATA_CMD_BAND_NUM];
} RfRamptableData;
typedef l1cal_EPSK_interRampData_T RfEpskInterRamptableParam;
/**
 * \ingroup GSMStruct
 */
typedef struct
{
    bool  epsk_band_enabled[MAX_RF_TX_DATA_CMD_EPSK_BAND_NUM]; // EPSK850|EPSK900|EPSK1800|EPSK1900
} RfEpskInterRamptableBandEnabled;
/**
 * \ingroup GSMStruct
 */
typedef struct
{
    RfEpskInterRamptableBandEnabled  epsk_inter_ramp_table_band_map;
    RfEpskInterRamptableParam        epsk_inter_ramp_table[MAX_RF_TX_DATA_CMD_EPSK_BAND_NUM]; // EPSK850|EPSK900|EPSK1800|EPSK1900
} RfEpskInterRamptableData;
/**
 * \ingroup GSMStruct
 * Indicator to notify L1 driver whether GMSK and EPSK data are requied to update or not
 */
typedef struct
{
   /**
    * Enable/disable of GMSK data
    */
    bool  gmsk_enabled;
   /**
    * Enable/disable of EPSK data
    */
    bool  epsk_enabled;
} RfTxpcEnabled;
/**
 * \ingroup GSMStruct
 * TXPC parameter element for temperature compensation
 */
typedef struct
{
   /**
    * flag of "is calibrated", would be updated by tool
    */
   char    is_calibrated;
   /**
    * Room temperature sampled during GMSK TX calibration
    */
   short   temperature;
} RfTxpcParam;
/**
 * \ingroup GSMStruct
 * TXPC parameter for temperature compensation
 */
typedef struct
{
   /**
    * \ingroup GSMStruct
    * Total catgory number (GMSK and EPSK)
    */
#define MAX_RF_TX_DATA_CMD_CATGORY_NUM 2
   /**
    * Indicator to notify L1 driver whether GMSK and EPSK data are requied to update or not
    */
    RfTxpcEnabled  txpc_cat_map;
   /**
    * GMSK/EPSK TXPC parameter for temperature compensation
    */
    RfTxpcParam    txpc[MAX_RF_TX_DATA_CMD_CATGORY_NUM];
} RfTxpcData;
/**
 * \ingroup GSMStruct
 * EPSK PA parameter in one PCL (include PA Vbias and PA Gain for different PCL)
 */
typedef struct
{
   /**
    * EPSK Power Control Level, PCL=5~19 for Low Band, PCL=0~15 for High Band
    */
    short           pcl_index;

   /**
    * PA VBias for EPSK, this value will be setting by ini file when calibraiton
    */
    unsigned char   pa_vbias;

   /**
    * EPSK PA Gain, this value will effect accuracy of EPSK Tx Power
    */
    unsigned short  pa_gain;
} RfPaVbias;
/**
 * \ingroup GSMStruct
 * struct defined for PA Gain and PA VBias in GSM all support band, XXXX_pa_vbias[0~15] is differt PCL result
 */
typedef struct
{
    RfPaVbias  GSM850_pa_vbias[PA_OCT_16_LEVEL];
    RfPaVbias  GSM900_pa_vbias[PA_OCT_16_LEVEL];
    RfPaVbias  DCS1800_pa_vbias[PA_OCT_16_LEVEL];
    RfPaVbias  PCS1900_pa_vbias[PA_OCT_16_LEVEL];
} RfEpskPaParam;
/**
 * \ingroup GSMStruct
 * EPSK PA Gain data
 */
typedef struct
{
    /**
    * to know which band of PA setting should be used
    */
    bool           epsk_pa_enabled;
    /**
    * EPSK PA parameter related data
    */
    RfEpskPaParam  epsk_pa;
} RfEpskPaData;
/**
 * \ingroup GSMStruct
 * This structure defines parameter for updating TX calibration data to DUT
 */
typedef struct
{
   /**
    * Indicator to notify L1 driver whether the data needs to update to NVRAM or not
    */
    bool                       is_uplate_to_NVRAM;
   /**
    * GMSK and EPSK TX calibration data
    */
    RfRamptableData            ramp_table_data;
   /**
    * EPSK TX calibration data (inter-slot ramp profile)
    */
    RfEpskInterRamptableData   epsk_inter_ramp_table_data;
   /**
    * TXPC parameter for temperature compensation
    */
    RfTxpcData                 txpc_data;
   /**
    * EPSK calibration results (PA Vbias)
    */
    RfEpskPaData               epsk_pa_data;
} RfTestCmdSetTxData;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTxData_r
 */
META_RESULT __stdcall  META_Rf_SetTxData(const unsigned int ms_timeout, RfTestCmdSetTxData* req);

/**
 * \details For updating GSM TX calibration results to DUT
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req TX calibration data to be update to DUT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall  META_Rf_SetTxData_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetTxData* req);

typedef struct
{
    RfRamptableBandEnabled           ramp_table_band_map;
    RfEpskInterRamptableBandEnabled  epsk_inter_ramp_table_band_map;
    RfTxpcEnabled                    txpc_cat_map;
    bool                             epsk_pa_enabled;
} RfTestCmdGetTxData;
typedef struct
{
    RfRamptableData            ramp_table_data;
    RfEpskInterRamptableData   epsk_inter_ramp_table_data;
    RfTxpcData                 txpc_data;
    RfEpskPaData               epsk_pa_data;
} RfTestResultGetTxData;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTxData_r
 */
META_RESULT __stdcall  META_Rf_GetTxData(const unsigned int ms_timeout, RfTestCmdGetTxData* req, RfTestResultGetTxData* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_GetTxData_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdGetTxData* req, RfTestResultGetTxData* cnf);


#define RF_MAX_PEER_BUF_CNF_BYTE_SIZE   (51200)
#define RF_MAX_PEER_BUF_CNF_WORD_SIZE   (RF_MAX_PEER_BUF_CNF_BYTE_SIZE >> 2)
#define GSM_RF_MAX_RX_ANT_NUM_V5        (2)
#define RF_MAX_RX_GAIN_NUM_V5           (6)
#define MAX_RF_RX_DATA_CMD_BAND_NUM_V5  (4)

// META_Rf_SetTxDataV5 REQ

typedef struct
{
    unsigned short  count;  /**< count of data block  */
    unsigned short  offset; /**< An offset which used to point to a start point of data block in peer buffer */
    unsigned short  bitmap; /**< GSM band bitmap (1: RX Main Band850, 2: RX Main Band900, 4: RX Main Band1800, 8: RX Main Band1900, 256: RX Diversity Band850, 512: RX Diversity Band900, 1024: RX Diversity Band1800, 2048: RX Diversity Band1900)  */
    unsigned short  zero_padding;
} RfTestParamDynamicEntryElm;

typedef struct
{
    unsigned short              is_uplate_to_NVRAM; /**< update NVRAM data or not (0: update runtime data, 1: update NVRAM data)  */
    RfTestParamDynamicEntryElm  type1_rxpathloss_param;
    RfTestParamDynamicEntryElm  type2_wcoef_param;
} RfTestCmdSetRxDataReqParamV5;

typedef struct
{
    RfPathLossOffsetV3  rx_pathloss_entry[PLTABLE_SIZE];
} SetGetRxPathLossEntryType1;

typedef struct
{
    SetGetRxPathLossEntryType1  type1_pathloss_pdu[GSM_RF_MAX_RX_ANT_NUM_V5][FrequencyBandCount];
    RfTestWCoefData             type2_wcoef_pdu[GSM_RF_MAX_RX_ANT_NUM_V5];
} RfTestCmdSetRxDataReqPeerV5;

typedef struct
{
    RfTestCmdSetRxDataReqParamV5 reqParam;
    RfTestCmdSetRxDataReqPeerV5 reqPeer;
} RfTestCmdSetRxDataReqV5;

// META_Rf_SetTxDataV5 CNF

typedef enum
{
    RF_TEST_SET_RX_DATA_CNF_STATUS_INVALID     = 0,
    RF_TEST_SET_RX_DATA_CNF_STATUS_OK          = 1,
    RF_TEST_SET_RX_DATA_TYPE2_OFFSET_ERROR     = 2,  // Type-2 count/offset mismatch
    RF_TEST_SET_RX_DATA_TYPE3_OFFSET_ERROR     = 3,  // Type-3 count/offset mismatch
    RF_TEST_SET_RX_DATA_TYPE4_OFFSET_ERROR     = 4,  // Type-4 count/offset mismatch
    RF_TEST_SET_RX_DATA_EXCESS_REQ_PDU_LENGTH  = 5,
    RF_TEST_SET_RX_DATA_CNF_CHECK_OFFSET_PASS  = 6,
    RF_TEST_SET_RX_DATA_BITMAP_COUNT_MISMATCH  = 7,
    RF_TEST_SET_RX_DATA_NULL_PEER_BUF          = 8,
    RF_TEST_SET_RX_DATA_RECORD_SET_FAIL        = 9,
    RF_TEST_SET_RX_DATA_CNF_STATUS_MAX         = 0xFFFF
} RfTestSetRxDataCnfStatus;

typedef struct
{
    unsigned short  count;
    unsigned short  bitmap;   //add bitmap for tool team debug
} RfTestSetRxDataCnfParamEntry;

typedef enum
{
    RF_TEST_SET_RX_RUNTIME_DATA_STATUS_INVALID           = 0,
    RF_TEST_SET_RX_RUNTIME_DATA_STATUS_OK                = 1,  // set runtime success
    RF_TEST_SET_RX_RUNTIME_DATA_STATUS_BAND_NOT_SUPPORT  = 2,  // band mismatch with route
    RF_TEST_SET_RX_RUNTIME_DATA_STATUS_MAX,
} RfTestSetRxDataRunTimeStatus;

typedef struct
{
    RfTestSetRxDataCnfStatus        set_rxdata_cnf_status;
    RfTestSetRxDataCnfParamEntry    type1_result;
    RfTestSetRxDataCnfParamEntry    type2_result;
    RfTestSetRxDataRunTimeStatus    type1_rxpathloss_result[GSM_RF_MAX_RX_ANT_NUM_V5 * FrequencyBand1900];
    RfTestSetRxDataRunTimeStatus    type2_wcoef_result[GSM_RF_MAX_RX_ANT_NUM_V5];
} RfTestResultSetRxDataCnfParamV5;

typedef struct
{
    RfTestResultSetRxDataCnfParamV5 reqParam;
} RfTestResultSetRxDataCnfV5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetRxDataV5_r
 */
META_RESULT __stdcall  META_Rf_SetRxDataV5(const unsigned int ms_timeout, RfTestCmdSetRxDataReqV5* req);
/**
 * \ingroup GSM
 * \details For setting RX pathloss data
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req RfTestCmdSetRxDataReqV5 
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT __stdcall  META_Rf_SetRxDataV5_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetRxDataReqV5* req);


// META_Rf_GetRxDataV5 REQ

typedef struct
{
    unsigned short  type1_rxpathloss_count; /**< count of pathloss data block  */
    unsigned short  type2_wcoef_count;  /**< count of w coefficient data block  */
    unsigned short  type1_rxpathloss_bitmap;    /**< GSM band bitmap for pathloss that want to get (1: RX Main Band850, 2: RX Main Band900, 4: RX Main Band1800, 8: RX Main Band1900, 256: RX Diversity Band850, 512: RX Diversity Band900, 1024: RX Diversity Band1800, 2048: RX Diversity Band1900)  */
    unsigned short  type2_wcoef_bitmap; /**< GSM band bitmap for w coefficient that want to get (1: RX Main Band850, 2: RX Main Band900, 4: RX Main Band1800, 8: RX Main Band1900, 256: RX Diversity Band850, 512: RX Diversity Band900, 1024: RX Diversity Band1800, 2048: RX Diversity Band1900)  */
} RfTestCmdGetRxDataReqParamV5;

typedef struct
{
    RfTestCmdGetRxDataReqParamV5 reqParam;
} RfTestCmdGetRxDataReqV5;

/**
  * \ingroup GSMStruct
  * Status of getting RX pathloss data (1: OK, 2: BITMAP COUNT MISMATCH, 3: OFFSET MISMATCH, 4: NULL PEER BUF, 5: PEER BUF SIZE OVERFLOW)
  */
typedef enum
{
    RF_TEST_GET_RX_DATA_CNF_STATUS_INVALID         = 0,
    RF_TEST_GET_RX_DATA_CNF_STATUS_OK              = 1,
    RF_TEST_GET_RX_DATA_BITMAP_COUNT_MISMATCH      = 2,
    RF_TEST_GET_RX_DATA_OFFSET_MISMATCH            = 3,
    RF_TEST_GET_RX_DATA_NULL_PEER_BUF              = 4,
    RF_TEST_GET_RX_DATA_PEER_BUF_SIZE_OVERFLOW     = 5,
    RF_TEST_GET_RX_DATA_CNF_STATUS_MAX             = 0xFFFF
} RfTestGetRxDataCnfStatus;

/**
  * \ingroup GSMStruct
  * Runtime status of getting RX pathloss data (1: OK, 2: BAND NOT SUPPORT)
  */
typedef enum
{
    RF_TEST_GET_RX_RUNTIME_DATA_STATUS_INVALID           = 0,
    RF_TEST_GET_RX_RUNTIME_DATA_STATUS_OK                = 1,  // set runtime success
    RF_TEST_GET_RX_RUNTIME_DATA_STATUS_BAND_NOT_SUPPORT  = 2,  // band mismatch with route
    RF_TEST_GET_RX_RUNTIME_DATA_STATUS_MAX,
} RfTestGetRxDataRunTimeStatus;

typedef struct
{
    RfTestGetRxDataCnfStatus        get_rxdata_cnf_status;
    RfTestParamDynamicEntryElm      type1_rxpathloss_data;
    RfTestParamDynamicEntryElm      type2_wcoef_data;
    RfTestGetRxDataRunTimeStatus    type1_rxpathloss_result[8];
    RfTestGetRxDataRunTimeStatus    type2_wcoef_result[2];
} RfTestResultGetRxDataCnfParamV5;

typedef struct
{
    SetGetRxPathLossEntryType1  type1_pathloss_pdu[GSM_RF_MAX_RX_ANT_NUM_V5][FrequencyBandCount];
    RfTestWCoefData             type2_wcoef_pdu[GSM_RF_MAX_RX_ANT_NUM_V5];
} RfTestResultGetRxDataCnfPeerV5;

typedef struct
{
    RfTestResultGetRxDataCnfParamV5 reqParam;
    RfTestResultGetRxDataCnfPeerV5 reqPeer;
} RfTestResultGetRxDataCnfV5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetRxDataV5_r
 */
META_RESULT __stdcall  META_Rf_GetRxDataV5(const unsigned int ms_timeout, const RfTestCmdGetRxDataReqV5* req, RfTestResultGetRxDataCnfV5* cnf);
/**
 * \ingroup GSM
 * \details For getting RX pathloss data
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req RfTestCmdGetRxDataReqV5
 * \param [out] cnf RfTestResultGetRxDataCnfV5 
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT __stdcall  META_Rf_GetRxDataV5_r(const int meta_handle, const unsigned int ms_timeout, const RfTestCmdGetRxDataReqV5* req, RfTestResultGetRxDataCnfV5* cnf);


// META_Rf_GetCalibrationInfoV5 CNF

typedef struct
{

    unsigned char   seq_num;    /**< calibration sequence step  */
    short           dlpow_default[RF_MAX_RX_GAIN_NUM_V5];   /**< default downlink power for rx path loss calibration */
    short           dlpow_lbound [RF_MAX_RX_GAIN_NUM_V5];   /**< lower boundary of downlink power for rx path loss calibration */
    short           dlpow_hbound [RF_MAX_RX_GAIN_NUM_V5];   /**< upper boundary of downlink power for rx path loss calibration */
    unsigned char   lna_enum_type[GSM_RF_MAX_RX_ANT_NUM_V5][RF_MAX_RX_GAIN_NUM_V5]; /**< DUT supported LNA mode*/
    unsigned char   antenna_enable[GSM_RF_MAX_RX_ANT_NUM_V5][RF_MAX_RX_GAIN_NUM_V5]; /**< Antenna enable status for each LNA mode */
    short           dlpow_wcoef_default;    /**< default downlink power for instrument for w coefficient calibration */    
    short           dlpow_wcoef_lbound;     /**< lower boundary of downlink power for w coefficient calibration */
    short           dlpow_wcoef_hbound;     /**< upper boundary of downlink power for w coefficient calibration */
    short           wcoef_arfcn[8]; /**< Subband channel for w coefficient calibration */
    short           gain_default [GSM_RF_MAX_RX_ANT_NUM_V5][RF_MAX_RX_GAIN_NUM_V5]; /**< lower boundary of gain for rx path loss calibration */
    short           wcoef_gain_default[GSM_RF_MAX_RX_ANT_NUM_V5];   /**< lower boundary of gain for w coefficient calibration */ 
    unsigned char   elna_type[GSM_RF_MAX_RX_ANT_NUM_V5];    /**< eLNA type */
    short           gain_hbound[GSM_RF_MAX_RX_ANT_NUM_V5][RF_MAX_RX_GAIN_NUM_V5]; /**< lower boundary of gain */
    short           gain_lbound[GSM_RF_MAX_RX_ANT_NUM_V5][RF_MAX_RX_GAIN_NUM_V5]; /**< upper boundary of gain */
} RfTestResultCalInfoV5;

typedef struct
{
    RfTestResultCalInfoV5  GSM_Band_Info[FrequencyBandCount - 1];  
} RfTestResultGetCalInfoCnfPeerV5;

typedef struct
{
    RfTestResultGetCalInfoCnfPeerV5    cnfPeer;
} RfTestResultGetCalInfoCnfV5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetCalInfoV5_r
 */
META_RESULT __stdcall  META_Rf_GetCalInfoV5(const unsigned int ms_timeout, RfTestResultGetCalInfoCnfV5* cnf);
/**
 * \ingroup GSM
 * \details For getting calibration information
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] cnf RfTestResultGetCalInfoCnfV5 
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT __stdcall  META_Rf_GetCalInfoV5_r(const int meta_handle, const unsigned int ms_timeout, RfTestResultGetCalInfoCnfV5* cnf);


// META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V5 REQ

typedef enum
{
    RX_CAL_SEQ_V5_NULL = 0,
    RX_CAL_SEQ_V5_UTRA_HIGH = 1,
    RX_CAL_SEQ_V5_HIGH = 2,
    RX_CAL_SEQ_V5_MID = 3,
    RX_CAL_SEQ_V5_MID_SAWLESS = 4,
    RX_CAL_SEQ_V5_LOW = 5,
    RX_CAL_SEQ_V5_BYPASS_LOW = 6,
    RX_CAL_SEQ_V5_WCOEF = 7,
    RX_CAL_SEQ_V5_COUNT
} RfTestRxCalSeqV5;

typedef struct
{
    FrequencyBand       band;      ///< GSM Band
    ARFCN               arfcn;     ///< GSM ARFCN
    short               repeat_cnt; ///< repetitive test counts (frames) for each ARFCN value
    short               dl_power;  ///< it is DL Power for each frame
    RfTestRxCalSeqV5    gsm_lna_mode[GSM_RF_MAX_RX_ANT_NUM_V5]; ///< DUT supported LNA mode
} RFTestCmdDSSPLV5;

//Gen92 --> M30
//Gen93 --> M50-CAT7
//Gen95 --> M50

/**
 * \ingroup GSMStruct
 * This structure defines parameter for Downlink Test Sequence Calibration in M50 with LPM Calibration
 */
typedef struct
{
    bool                    afc_cal;     ///< Control whether AFC calibration is needed or not
    bool                    pl_cal;      ///< Control whether Path loss calibration is needed or not
    char                    sync_sb_num; ///< the SB frame numbers needed for sync process before path loss calibration
    short                   power;       ///< the power dBm (in unit of 1/8 dB) expected to measure when sync process
    Rf_DSSAFC_T             AfcDSS;      ///< parameter for AFC Calibration
    unsigned short          step_cnt;    ///< step count for Path Loss Calibration
    RFTestCmdDSSPLV5        PathLossDSS[510];  ///< parameter for Path Loss Calibration
    short                   lpm_sb_num;  ///< SB frame numbers for lpm calibration
    unsigned char           Antenna;     ///< Antenna mask
} RFTestCmdDTSLpm512PV5;

typedef struct
{
    RFTestCmdDTSLpm512PV5  reqPeer;
} RfTestCmdStartFdtDLNotWaitResultReqV5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V5_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V5(unsigned int ms_timeout, const RfTestCmdStartFdtDLNotWaitResultReqV5* req);

/**
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) in M50, MaxStep=512, With Lpm Calibration, Need META_Rf_GetFdtDL_Lpm_512p_V5_r to get result
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req, it is input parameter for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V5_r(const int meta_handle, unsigned int ms_timeout, const RfTestCmdStartFdtDLNotWaitResultReqV5* req);


// META_Rf_StartFdtDLWaitResult_Lpm_512p_V5 REQ

typedef struct
{
    RFTestCmdDTSLpm512PV5  reqPeer;
} RfTestCmdStartFdtDLWaitResultReqV5;

// META_Rf_StartFdtDLWaitResult_Lpm_512p_V5 CNF

typedef struct
{
    RF_DTS_GET_RESULT_STATUS    dts_get_result_status;
} RfTestResultGetFdtDLCnfParamV5;

typedef struct
{
    int     power[GSM_RF_MAX_RX_ANT_NUM_V5][MAX_STEP_EX_512P_CNT-2];        ///< receive power (in unit of 1/8 dB), because sync process will need 2 steps
    short   valid_sample[GSM_RF_MAX_RX_ANT_NUM_V5][MAX_STEP_EX_512P_CNT-2]; ///< whether receive power is valid sample or not
    bool    ok;                                                             ///< whether if pathloss result is complete or not
} RfTestResultDSSPL512PV5;

typedef struct
{
    RfTestResultDSSPL512PV5     PLResult;
    Rf_DSSAFC_RESULT_T          AfcResult;
    Rf_FHC_DTSM_INFO_T          DtsmInfo;
    /* crystal low power mode calibration result (for 32k removal) */
    RF_DSSLPM_RESULT_T          LpmResult;
} RfTestResultDTSLpm512PV5;

typedef struct
{
    RfTestResultGetFdtDLCnfParamV5  cnfParam;
    RfTestResultDTSLpm512PV5        cnfPeer;
} RfTestCmdStartFdtDLWaitResultCnfV5, RfTestCmdGetFdtDLCnfV5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_StartFdtDLWaitResult_Lpm_512p_V5_r
 */
META_RESULT  __stdcall META_Rf_StartFdtDLWaitResult_Lpm_512p_V5(unsigned int ms_timeout, const RfTestCmdStartFdtDLWaitResultReqV5* req, RfTestCmdStartFdtDLWaitResultCnfV5* cnf);

/**
 * \details For trigger DUT to do GSM RX calibration (RSSI or AFC) in M50, MaxStep=512, With Lpm Calibration, Result is cnf
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req, it is input parameter for RX Calibration
 * \param [out] cnf, it is result for RX Calibration
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_StartFdtDLWaitResult_Lpm_512p_V5_r(const int meta_handle, unsigned int ms_timeout, const RfTestCmdStartFdtDLWaitResultReqV5* req, RfTestCmdStartFdtDLWaitResultCnfV5* cnf);


// META_Rf_GetFdtDL_Lpm_512p_V5 CNF
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetFdtDL_Lpm_512p_V5_r
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Lpm_512p_V5(unsigned int ms_timeout, RfTestCmdGetFdtDLCnfV5* cnf);

/**
 * \details For fetching GSM RX results (RSSI or AFC) from DUT in M50, it is result for META_Rf_StartFdtDLNotWaitResult_Lpm_512p_V5_r
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] result, it is parameter for RX Calibration Result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_GetFdtDL_Lpm_512p_V5_r(const int meta_handle, unsigned int ms_timeout, RfTestCmdGetFdtDLCnfV5* cnf);


typedef struct
{
    Rf_LIST_MODE_NSFT_COMMON_REQ    common; /**< GSM list-mode NSFT common parameter  */
    /**
    * GSM Band
    * \sa FrequencyBand
    */
    unsigned char                   rf_band;
    /**
    * GSM ARFCN
    * \sa ARFCN
    */
    unsigned short                  arfcn;
    /**
    * DL power level for sync signal (cell power), in unit of 1/8 dB
    * \sa Power
    */
    short                           sync_power;
    /**
    * Frame boundary (in unit of slot) between sync-signal to test-process, namely, DUT would adjust frame boundary by this setting after sync to instrument
    */
    unsigned char                   sync_slot_offset;
    unsigned char                   trx_type;   /**< Modulation (0: GMSK, 1: EPSK, 2: GMSK + EPSK)  */
} Rf_LIST_MODE_NSFT_SYNC_REQ_V5;

/**
  * \ingroup GSMStruct
  * Antenna mask (1: Main, 2: Diversity, 3: Both)
  */
typedef enum
{
    GSM_ANT_MASK_NULL= 0x0, 
    GSM_ANT_MASK_RXM = 0x1, 
    GSM_ANT_MASK_RXD = 0x2, 
    GSM_ANT_MASK_BOTH = 0x3 
} GSM_AntDimension;

typedef union
{
    Rf_LIST_MODE_NSFT_SYNC_REQ_V5   sync;   /**< Parameters for list-mode NSFT command element: sync-process  */
    Rf_LIST_MODE_NSFT_TRIGGER_REQ   trigger;    /**< Parameters for list-mode NSFT command element: trigger-instrument-process */  
    Rf_LIST_MODE_NSFT_CHMEAS_REQ    test;   /**< Parameters for list-mode NSFT command element: test-process */
} Rf_LIST_MODE_NSFT_COMMAND_V5_T;

typedef struct
{
    unsigned char                   ucCmdCount; /**< calibration sequence step  */
    unsigned char                   Antenna; /**< Antenna mask (1: Main, 2: Diversity, 3: Both) */
    Rf_LIST_MODE_NSFT_COMMAND_V5_T  command[RF_MAX_LIST_MODE_COMMAND_COUNT]; /**< Parameter for List-mode NSFT */
} Rf_LIST_MODE_NSFT_REQ_V5_T;

typedef struct
{
    /**
    * GSM list-mode NSFT common confirm message
    */
    Rf_LIST_MODE_NSFT_COMMON_CNF common;
    /**
    * Measured RSSI in RX_LEV format (spec. defined)
    */
    unsigned short             rx_level[GSM_RF_MAX_RX_ANT_NUM_V5];
    /**
    * Detected error bit sum (in unit of error_bits * 1000 / 114)
    */
    unsigned int               BER_sum;
    /**
    * BER measurement duration (in unit of TDMA frame)
    */
    unsigned int               BER_frame_count;
} Rf_LIST_MODE_NSFT_CHMEAS_CNF_V5;

/**
 * \ingroup GSMStruct
 * Union of confirm message for list-mode NSFT
 */
typedef union
{
    /**
    * Confirm message for list-mode NSFT command element: sync-process
    */
    Rf_LIST_MODE_NSFT_SYNC_CNF      sync;
    /**
    * Confirm message for list-mode NSFT command element: trigger-instrument-process
    */
    Rf_LIST_MODE_NSFT_TRIGGER_CNF   trigger;
    /**
    * Confirm message for list-mode NSFT command element: test-process
    */
    Rf_LIST_MODE_NSFT_CHMEAS_CNF_V5 test;
} Rf_LIST_MODE_NSFT_RPT_V5_T;

typedef struct
{
    /**
    * List-mode confirm count
    */
    unsigned char                   ucCnfCount;
    /**
    * Confirm of List-mode NSFT
    */
    Rf_LIST_MODE_NSFT_RPT_V5_T      report[RF_MAX_LIST_MODE_COMMAND_COUNT];
} Rf_LIST_MODE_NSFT_RPT_CNF_V5_T;

// Start the List Mode NSFT process V5
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_List_Mode_NSFT_Start_V5_r
 */
META_RESULT  __stdcall META_Rf_List_Mode_NSFT_Start_V5(unsigned int ms_timeout, const  Rf_LIST_MODE_NSFT_REQ_V5_T* req, Rf_LIST_MODE_NSFT_RPT_CNF_V5_T* cnf);
/**
 * \details For triggering GSM TX NSFT and BER test
 * \ingroup GSM
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Request parameters for triggering GSM TX NSFT and BER test
 * \param [out] cnf Confirm message of list mode NSFT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_List_Mode_NSFT_Start_V5_r(const int meta_handle, unsigned int ms_timeout, const  Rf_LIST_MODE_NSFT_REQ_V5_T* req, Rf_LIST_MODE_NSFT_RPT_CNF_V5_T* cnf);


typedef struct
{
    /**
    * GSM Band
    * \sa FrequencyBand
    */
    FrequencyBand   band;
    /**
    * GSM ARFCN for BCCH
    * \sa ARFCN
    */
    ARFCN           BCH_ARFCN;
    /**
    * GSM ARFCN for TCH
    * \sa ARFCN
    */
    ARFCN           TCH_ARFCN;
    /**
    * DL power level for BCCH
    * \sa Power
    */
    Power           BCH_DL_Power;
    /**
    * DL power level for TCH
    * \sa Power
    */
    Power           TCH_DL_Power;
    TSC             tsc;
    TimeSlot        TCH_slot;
    Power           tx_power_level;
    bool            is_EPSK_tx;
    CodingScheme    epsk_cs;
    /**
    * Antenna mask
    */
    GSM_AntDimension    Antenna;
} Rf_NSFT_REQ_V5_T;

// Start the BER NSFT process V5
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_Start_V5_r
 */
META_RESULT  __stdcall META_Rf_NSFT_Start_V5(unsigned int ms_timeout, const  Rf_NSFT_REQ_V5_T* req);
/**
 * \ingroup GSM
 * \details For triggering traditional NSFT
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Rf_NSFT_REQ_V5_T
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_NSFT_Start_V5_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_V5_T* req);

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_ChangeSettings_V5_r
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings_V5(unsigned int ms_timeout, const  Rf_NSFT_REQ_V5_T* req);
/**
 * \ingroup GSM
 * \details For changing traditional NSFT settings
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Rf_NSFT_REQ_V5_T
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings_V5_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_V5_T* req);

// Get the RX level results V5
/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_NSFT_GetRxLevel_V5_r
 */
META_RESULT __stdcall META_Rf_NSFT_GetRxLevel_V5(unsigned int ms_timeout, unsigned short rx_level[GSM_RF_MAX_RX_ANT_NUM_V5]);
/**
 * \ingroup GSM
 * \details For getting traditional NSFT RSSI results
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] rx_level Measured RSSI in RX_LEV format (spec. defined)
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_Rf_NSFT_GetRxLevel_V5_r(const int meta_handle, unsigned int ms_timeout, unsigned short rx_level[GSM_RF_MAX_RX_ANT_NUM_V5]);

/**
  * \ingroup GSMStruct
  * eLNA mode (1: UTRA HIGH, 2: HIGH, 3: MID, 4: MID SAWLESS, 5: LOW, 6: BYPASS LOW)
  */
typedef enum
{
   RX_LNA_NONE = 0,
   RX_LNA_UTRA_HIGH = 1,
   RX_LNA_HIGH = 2,
   RX_LNA_MID = 3,
   RX_LNA_MID_SAWLESS = 4,
   RX_LNA_LOW = 5,
   RX_LNA_BYPASS_LOW = 6,
} RfTestRx_Lna_Mode_E;

typedef struct
{
    /**
    * GSM Band
    * \sa FrequencyBand
    */
    FrequencyBand       band;
    /**
    * GSM ARFCN
    * \sa ARFCN
    */
    ARFCN               arfcn;
    char                sampleNoPerFrame; /**< Sample number per frame  */
    Gain                gain[GSM_RF_MAX_RX_ANT_NUM_V5]; 
    short               frames; /**< Frame count  */
    GSM_AntDimension    Antenna;    /**< Antenna mask  */
    RfTestRx_Lna_Mode_E elna_mode[GSM_RF_MAX_RX_ANT_NUM_V5];    /**< eLNA mode  */
} RfPm_Req_V5;

typedef struct
{
    unsigned char    valid[GSM_RF_MAX_RX_ANT_NUM_V5];
    int              iOffset[GSM_RF_MAX_RX_ANT_NUM_V5];
    int              qOffset[GSM_RF_MAX_RX_ANT_NUM_V5];
    int              validSamples[GSM_RF_MAX_RX_ANT_NUM_V5];
} RfPmExtraInfo_T_V5;

typedef struct
{
   /* Resoultion can be up to RSSI_RESOLUTION_BITS bits*/
   int              power[GSM_RF_MAX_RX_ANT_NUM_V5];
   /* Resoultion can be up to RSSI_RESOLUTION_BITS*2 bits*/
   int              deviation[GSM_RF_MAX_RX_ANT_NUM_V5];
   /* Resoultion can be up to RSSI_RESOLUTION_BITS bits*/
   Gain             usedGain[GSM_RF_MAX_RX_ANT_NUM_V5];
   RfPmExtraInfo_T_V5       extra_info;
   RfTestRx_Lna_Mode_E      elna_mode[GSM_RF_MAX_RX_ANT_NUM_V5];
   int            ok;
} RfPm_Cnf_V5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_Pm_V5_r
 */
META_RESULT __stdcall META_Rf_Pm_V5(unsigned int ms_timeout, const RfPm_Req_V5* req, RfPm_Cnf_V5* cnf);
/**
 * \ingroup GSM
 * \details For measuring power
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req RfPm_Req_V5 
 * \param [out] cnf RfPm_Cnf_V5
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT __stdcall META_Rf_Pm_V5_r(const int meta_handle, unsigned int ms_timeout, const RfPm_Req_V5* req, RfPm_Cnf_V5* cnf);


typedef struct
{
    /**
    * GSM Band
    * \sa FrequencyBand
    */
    FrequencyBand       band;
    /**
    * GSM ARFCN
    * \sa ARFCN
    */
    ARFCN               arfcn;
    Gain                gain[GSM_RF_MAX_RX_ANT_NUM_V5];
    GSM_AntDimension    Antenna;     /**< Antenna mask  */
    RfTestRx_Lna_Mode_E elna_mode[GSM_RF_MAX_RX_ANT_NUM_V5];     /**< eLNA mode  */
    unsigned char       onOff;  /**< Burst mode (0: off, 1: on)  */
} RfCnRx_Req_V5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_CONTINUE_RX_V5_r
 */
META_RESULT __stdcall META_Rf_CONTINUE_RX_V5(unsigned int ms_timeout, const RfCnRx_Req_V5* req);
/**
 * \ingroup GSM
 * \details For triggering DUT to continuously receive RX signal 
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req RfCnRx_Req_V5 
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT __stdcall META_Rf_CONTINUE_RX_V5_r(const int meta_handle, unsigned int ms_timeout, const RfCnRx_Req_V5* req);

typedef struct
{
    RfPm_Req_V5 pm;
    char        m_IfFlag;
}RfIfPm_Req_V5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_IfPm_V5_r
 */
META_RESULT __stdcall META_Rf_IfPm_V5(unsigned int ms_timeout, const RfIfPm_Req_V5* req, RfPm_Cnf_V5* cnf);
/**
 * \ingroup GSM
 * \details ToBeDo
 */
META_RESULT __stdcall META_Rf_IfPm_V5_r(const int meta_handle, unsigned int ms_timeout, const RfIfPm_Req_V5* req, RfPm_Cnf_V5* cnf);


typedef struct
{
    /**
    * GSM Band
    * \sa FrequencyBand
    */
    FrequencyBand           band;
    GSM_AntDimension        Antenna;    /**< Antenna mask  */
    RfTestRx_Lna_Mode_E     elna_mode[GSM_RF_MAX_RX_ANT_NUM_V5];    /**< eLNA mode  */
} RfRxGainCalculate_Req_V5;

/**
  * \ingroup GSMStruct
  * Status of RX gain calculator (1: SUCCESS, 2: FAIL)
  */
typedef enum
{
    GSM_CALCULATE_NULL = 0,
    GSM_CALCULATE_SUCCESS,
    GSM_CALCULATE_FAIL
} E_GSM_Rx_Gain_Caculator_Status;

typedef struct
{
    short           recommend_dlpow;    /**< recommended downlink power  */
    unsigned short  request_gain [GSM_RF_MAX_RX_ANT_NUM_V5];  /**< recommended gain  */
    E_GSM_Rx_Gain_Caculator_Status  calculate_status;   /**< status of RX gain calculator  */
} RfRxGainCalculate_Cnf_V5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_RX_Gain_Calculate_V5_r
 */
META_RESULT __stdcall META_Rf_RX_Gain_Calculate_V5(unsigned int ms_timeout, const RfRxGainCalculate_Req_V5* req, RfRxGainCalculate_Cnf_V5* cnf);
/**
 * \ingroup GSM
 * \details For getting the recommended gain and downlink power by specified the parameter
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req RfRxGainCalculate_Req_V5 
 * \param [out] req RfRxGainCalculate_Cnf_V5
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 */
META_RESULT __stdcall META_Rf_RX_Gain_Calculate_V5_r(const int meta_handle, unsigned int ms_timeout, const RfRxGainCalculate_Req_V5* req, RfRxGainCalculate_Cnf_V5* cnf);

typedef struct
{
   FrequencyBand    band;
   unsigned char    is_epsk;
} RfTestCmdGetTpoValue;
typedef struct
{
    unsigned char   ok;
    short           power_offset;
} RfTestResultGetTpoValue;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTpoValue_r
 */
META_RESULT __stdcall  META_Rf_GetTpoValue(const unsigned int ms_timeout, RfTestCmdGetTpoValue* req, RfTestResultGetTpoValue* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_GetTpoValue_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdGetTpoValue* req, RfTestResultGetTpoValue* cnf);

typedef struct
{
   FrequencyBand    band;
   unsigned char    is_epsk;
   short            power_offset;
} RfTestCmdSetTpoValue;


/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTpoValue_r
 */
META_RESULT __stdcall  META_Rf_SetTpoValue(const unsigned int ms_timeout, RfTestCmdSetTpoValue* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_SetTpoValue_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetTpoValue* req);

typedef struct
{
   FrequencyBand    band;
   unsigned char    is_epsk;
} RfTestCmdGetTpoValueV5;

typedef struct
{
    unsigned char   ok;
    short          power_apcdac_offset;
    short          power_db_offset; // 0.125 dB
} RfTestResultGetTpoValueV5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_GetTpoValueV5_r
 */
META_RESULT __stdcall  META_Rf_GetTpoValueV5(const unsigned int ms_timeout, RfTestCmdGetTpoValueV5* req, RfTestResultGetTpoValueV5* cnf);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_GetTpoValueV5_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdGetTpoValueV5* req, RfTestResultGetTpoValueV5* cnf);

typedef struct
{
    FrequencyBand  band;
    unsigned char  is_epsk;
    short         power_apcdac_offset;
    short         power_db_offset; // 0.125 dB
} RfTestCmdSetTpoValueV5;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTpoValueV5_r
 */
META_RESULT __stdcall  META_Rf_SetTpoValueV5(const unsigned int ms_timeout, RfTestCmdSetTpoValueV5* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_SetTpoValueV5_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetTpoValueV5* req);

typedef struct
{
   unsigned char    rxlev_precision;
} RfTestCmdSetNsftRxlevPrecision;

/**
 * \ingroup GSM
 * \sa non-reentrant version of META_Rf_SetTpoValueV5_r
 */
META_RESULT __stdcall  META_Rf_SetNsftRxlevPrecision(const unsigned int ms_timeout, RfTestCmdSetNsftRxlevPrecision* req);
/**
 * \ingroup GSM
 * \brief ToBeDo
 */
META_RESULT __stdcall  META_Rf_SetNsftRxlevPrecision_r(const int meta_handle, const unsigned int ms_timeout, RfTestCmdSetNsftRxlevPrecision* req);
#if defined(__META_LTE__)
//--------------------------------------------------------------------------//
//  LTE RF                                                                  //
//--------------------------------------------------------------------------//
/********************* MT6291 Constant Definitions *********************/

#define MAX_FHC_RX_FREQ_NUM_EX       15

/**
 * \ingroup LTEStruct
 * maximum number of subband
 */
#define MAX_FHC_TX_FREQ_NUM_EX       15

#define MAX_RX_CC_NUM                2  // for gain-by-gain PCC & SCC results

#define MAX_ROUTE_NUM                128
#define MAX_ROUTE_NUM_IN_WORD        (((MAX_ROUTE_NUM-1)>>5)+1)
/**
 * \ingroup LTEStruct
 * the maximum temperature section can be use for different temperature compensation
 */
#define MAX_TEMP_SECTION_NUM         8
#define MAX_RX_LNA_N_MODE_NUM        6  //for LNA normal mode
#define MAX_RX_LNA_L_MODE_NUM        1  //for LNA low power mode
#define MAX_RX_LNA_MODE_NUM         (MAX_RX_LNA_N_MODE_NUM+MAX_RX_LNA_L_MODE_NUM)

/**
 * \ingroup LTEStruct
 * [0], [1], [2] are compensation for PA operating in high, middle, low mode, respectively
 */
#define MAX_TX_PA_MODE_NUM           3
/**
 * \ingroup LTEStruct
 * [0], [1], [2] are compensation for PA operating in high, middle, low mode, respectively
 */
#define MAX_TX_DET_MODE_NUM          MAX_TX_PA_MODE_NUM
/**
 * \ingroup LTEStruct
 * the maximum allowable TX gain mode number to be calibrated
 */
#define MAX_TX_PA_LEVEL_NUM          8
#define MAX_TX_RPT_NUM              (MAX_TX_DET_MODE_NUM+MAX_TX_PA_LEVEL_NUM)


#define MAX_FHC_RX_TYPE1_ROUTE_NUM   48 //single band + inter-CA + PCC/SCC exchange
#define MAX_FHC_RX_TYPE2_ROUTE_NUM   8  //intra-NCCA
#define MAX_FHC_TX_TYPE1_ROUTE_NUM   21

#define MAX_SCENARIO_BY_BAND_NUM     15 // SCENARIO means CA category

//META self-defined
#define INVALID_CA_COMB_TABLE_INDEX  255
#define MAX_SRX_LNA_SETTING_NUM   3
#define MAX_CA_USAGE_NUM   256
#define MAX_CA_COMBINE_NUM   256

/********************* MT6291 Constant Definitions *********************/
#define ERF_MAX_BAND_NUM 21

#define MAX_LTE_BAND (44)
typedef struct
{
    unsigned char band;
#define ERF_TX_TEST_COMMAND_CONFIG_TDD 0
#define ERF_TX_TEST_COMMAND_CONFIG_FDD 1
    unsigned char duplexMode; /**< tdd,fdd */
    unsigned char tddConfig;
    unsigned char tddSfConfig;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_6RB 0
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_15RB 1
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_25RB 2
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_50RB 3
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_75RB 4
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_100RB 5
    unsigned char ulBandwidth; /**< 6,15,25,50,75,100RB */
    unsigned char vrbStart;
    unsigned char vrbLength;
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_QPSK 0
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_16QAM 1
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_64QAM 2
    unsigned char mcsMode;
    short txPower;
    unsigned char networkSelection; /**< 0~31 */
    unsigned char txPowerMode;
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
    short bbBackoff;
    unsigned char rfGain;
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_HIGH 0
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_MIDDLE 1
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_LOW 2
    unsigned char paMode;
    unsigned char paVcc;
    unsigned char vm0;
    unsigned char vm1;
    unsigned char enableCsr; //0: Don't enable CSR, 1: Enable Csr
    unsigned short dlFrequency;
} ERfTestCmdPuschTx;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxPusch_r
 */
META_RESULT __stdcall META_ERf_TxPusch( const ERfTestCmdPuschTx* req, const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TxPusch_r( const int meta_handle, const  ERfTestCmdPuschTx* req, const unsigned int ms_timeout );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartTraditionalTxNSFT_r
 */
META_RESULT __stdcall META_ERf_StartTraditionalTxNSFT( const ERfTestCmdPuschTx* req, const unsigned int ms_timeout, unsigned int* pSyncStatus );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_StartTraditionalTxNSFT_r( const int meta_handle, const  ERfTestCmdPuschTx* req, const unsigned int ms_timeout, unsigned int* pSyncStatus );

typedef struct
{
    unsigned char band;
    unsigned char duplexMode /**< tdd,fdd */;
    unsigned char tddConfig;
    unsigned char tddSfConfig;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
    unsigned char ulBandwidth; /**< 6,15,25,50,75,100RB */
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1 0
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1A 1
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1B 2
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2 3
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2_CPACK 4
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2A 5
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2B 6
    unsigned char format; /**< 1,1a,1b,2,2_cpack,2a,2b */
    short txPower;
    unsigned char networkSelection; /**< 0~31 */
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
} ERfTestCmdPucchTx;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxPucch_r
 */
META_RESULT __stdcall META_ERf_TxPucch( const ERfTestCmdPucchTx* req, const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TxPucch_r( const int meta_handle, const  ERfTestCmdPucchTx* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned char band;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_FDD_TIME_MASK 0
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_TDD_TIME_MASK 1
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_FDD_EVM 2
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_TDD_EVM 3
    unsigned char configIndex; /**< fdd time mask,tdd time mask,fdd evm,tdd evm*/
    short txPower;
    unsigned char networkSelection; /**< 0~31 */
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
} ERfTestCmdPrachTx;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxPrach_r
 */
META_RESULT __stdcall META_ERf_TxPrach( const ERfTestCmdPrachTx* req, const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TxPrach_r( const int meta_handle, const  ERfTestCmdPrachTx* req, const unsigned int ms_timeout );


typedef struct
{
    unsigned char band;
    unsigned char duplexMode /**< tdd,fdd */;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_0 0
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_2 2
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_5 5
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_7 7
    unsigned char tddCsSrsBwCfg;
    short txPower;
    unsigned char networkSelection; /**< 0~31 */
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
} ERfTestCmdSrsTx;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxSrs_r
 */
META_RESULT __stdcall META_ERf_TxSrs( const ERfTestCmdSrsTx* req, const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TxSrs_r( const int meta_handle, const  ERfTestCmdSrsTx* req, const unsigned int ms_timeout );

typedef struct
{
#define MAX_ERF_TEST_MIXRX_DLRX_MODE (0)
#define MAX_ERF_TEST_MIXRX_TXRX_MODE (1)
#define MAX_ERF_TEST_MIXRX_PSEUDO_TXRX_MODE (2)
    unsigned char mode;
#define MAX_ERF_TEST_MIXRX_REPORT_COUNT 10
    unsigned char measCnt;
    unsigned char measBandwidth; /**< Refer to Tx ulBandwidth - 6,15,25,50,75,100RB */
    short afcdac;
    unsigned short dlFrequency;
    unsigned char band;
    unsigned char duplexMode; /**< Refer to Tx duplexMode - tdd,fdd */
    unsigned char tddConfig;
    unsigned char tddSfConfig;
    unsigned char bandwidth; /**< Refer to Tx ulBandwidth - 6,15,25,50,75,100RB */
    unsigned char rxPath0Enbl;
    unsigned char rxPath1Enbl;
    unsigned short ulFrequency;
    short txPowerValue;
    unsigned char vrbStart;
    unsigned char vrbLength;
    unsigned char mcsMode; /**< Refer to Tx mcsMode */
} ERfTestCmdMixRx;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartMixRx_r
 */
META_RESULT __stdcall META_ERf_StartMixRx( const unsigned int ms_timeout, const ERfTestCmdMixRx* req );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_StartMixRx_r( const int meta_handle, const ERfTestCmdMixRx* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned char measRptCnt; //0 ~ MAX_ERF_TEST_MIXRX_REPORT_COUNT
    short rssiPath0[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rssiPath1[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrpPath0[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrpPath1[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrqPath0[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrqPath1[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    unsigned int crcOK_cnt;
    unsigned int crcNG_cnt;
} ERfTestCmdGetMixRxRpt;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetMixRxReport_r
 */
META_RESULT __stdcall META_ERf_GetMixRxReport( const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt* resp );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt* resp );

typedef struct
{
    unsigned char mode;//0: DL Rx, 1: Tx-Rx, 2: Pseudo Tx-Rx

    /*Common parameters*/
    unsigned char measCnt[MAX_RX_CC_NUM];//range 0~10
    unsigned char measBandwidth[MAX_RX_CC_NUM];//0: 6 RB, 1: 15 RB, 2: 25 RB, 3: 50 RB, 4: 75 RB, 5: 100 RB
    short         afcdac;
    unsigned short dlFrequency[MAX_RX_CC_NUM];//range: 7280~26900 (100KHz unit)
    unsigned char band[MAX_RX_CC_NUM];
    unsigned char duplexMode;//0:tdd, 1:fdd
    unsigned char tddConfig[MAX_RX_CC_NUM];//range 0~7
    unsigned char tddSfConfig[MAX_RX_CC_NUM];//range 0~8
    unsigned char bandwidth;//(UL BW) 0: 6 RB, 1: 15 RB, 2: 25 RB, 3: 50 RB, 4: 75 RB, 5: 100 RB
    unsigned char rxPath0Enbl;
    unsigned char rxPath1Enbl;

    /*Tx-Rx & Pseudo Tx-Rx only*/
    unsigned short ulFrequency;//range: 7280~26900 (100KHz unit)
    short         txPowerValue;/*S(8,8)*/

    /*Pseudo Tx-Rx only*/
    unsigned char vrbStart;
    unsigned char vrbLength;
    unsigned char mcsMode;
} ERfTestCmdMixRx_CaMode;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartMixRx_CaMode_r
 */
META_RESULT __stdcall META_ERf_StartMixRx_CaMode( const unsigned int ms_timeout, const ERfTestCmdMixRx_CaMode* req );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_StartMixRx_CaMode_r( const int meta_handle, const ERfTestCmdMixRx_CaMode* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned char measRptCnt[MAX_RX_CC_NUM];//range 0~10
    short rssiPath0[MAX_RX_CC_NUM][10];//final format is TBD
    short rssiPath1[MAX_RX_CC_NUM][10];//final format is TBD
    short rsrpPath0[MAX_RX_CC_NUM][10];//final format is TBD
    short rsrpPath1[MAX_RX_CC_NUM][10];//final format is TBD
    short rsrqPath0[MAX_RX_CC_NUM][10];//final format is TBD
    short rsrqPath1[MAX_RX_CC_NUM][10];//final format is TBD

    unsigned int crcOK_cnt[MAX_RX_CC_NUM];
    unsigned int crcNG_cnt[MAX_RX_CC_NUM];
} ERfTestCmdGetMixRxRpt_CaMode;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetMixRxReport_CaMode_r
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode( const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt_CaMode* resp );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt_CaMode* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_ResetCounter_r
 */
META_RESULT __stdcall META_ERf_ResetCounter( const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_ResetCounter_r( const int meta_handle, const unsigned int ms_timeout );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StopTestMode_r
 */
META_RESULT __stdcall META_ERf_StopTestMode( const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_StopTestMode_r( const int meta_handle, const unsigned int ms_timeout );

typedef struct
{
    //PA Control
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE 8
    unsigned char paControlLevel; /* 2~8 */
    unsigned char calRoomTempIdx;
    short hysteresisStart0;
    short hysteresisEnd0;
    short hysteresisStart1;
    short hysteresisEnd1;
    unsigned char paMode[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    short pRf[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short paGain[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char dc2dcLevel[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short vBiasDac[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm0[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm1[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    //Tx Compensation
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE 8
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE 21
    unsigned short ulFrequency[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short couplerLossHigh;
    short couplerLossMiddle;
    short couplerLossLow;
    short powerDetectorHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
} ERfTestCmdGetSetTpcSetting;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetTpcSetting_r
 */
META_RESULT  __stdcall META_ERf_GetTpcSetting( unsigned char band,  const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_GetTpcSetting_r( const int meta_handle, unsigned char band, const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetTpcSetting_r
 */
META_RESULT  __stdcall META_ERf_SetTpcSetting( unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_SetTpcSetting_r( const int meta_handle, unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );

// WARNNING: backward compatible(BC) function, these will be removed after MP
typedef struct
{
    //PA Control
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE 8
    unsigned char paControlLevel; /* 2~8 */
    short hysteresisStart0;
    short hysteresisEnd0;
    short hysteresisStart1;
    short hysteresisEnd1;
    unsigned char paMode[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    short pRf[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short paGain[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char dc2dcLevel[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short vBiasDac[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm0[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm1[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    //Tx Compensation
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE 8
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE 21
    unsigned short earfcn[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short couplerLossHigh;
    short couplerLossMiddle;
    short couplerLossLow;
    short powerDetectorHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
} ERfTestCmdGetSetTpcSetting_Bc;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetTpcSetting_Bc_r
 */
META_RESULT  __stdcall META_ERf_GetTpcSetting_Bc( unsigned char band,  const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_GetTpcSetting_Bc_r( const int meta_handle, unsigned char band, const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetTpcSetting_Bc_r
 */
META_RESULT  __stdcall META_ERf_SetTpcSetting_Bc( unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_SetTpcSetting_Bc_r( const int meta_handle, unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned int is_capable: 1;
    unsigned int is_mandatory: 1;
    unsigned int fdd_to_tdd_switch_time: 3;
    unsigned int fdd_tx_to_rx_switch_time: 3;
    unsigned int tdd_tx_to_rx_switch_time: 3;
    unsigned int freq_switch_time: 3;
    unsigned int band_switch_time: 3;
    unsigned int tx_step_width: 3;
    unsigned int reserve: 12;
} ERfCalItemSwitchTime;

typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} ERfTestCmdRfCapabilityReq;

typedef struct
{
    unsigned int  supportBandMap[2];            ///< supportBandMap[0]           :Band01(LSB)~Band32(MSB);supportBandMap[1]            :Band33(LSB)~Band64(MSB)
    unsigned int  supportMipiBandMap[2];        ///< supportMipiBandMap[0]       :Band01(LSB)~Band32(MSB);supportMipiBandMap[1]        :Band33(LSB)~Band64(MSB)
    unsigned int  supportCoexistenceBandMap[2]; ///< supportCoexistenceBandMap[0]:Band01(LSB)~Band32(MSB);supportCoexistenceBandMap[1] :Band33(LSB)~Band64(MSB)
    unsigned int  supportDpdBandMap[2];         ///< supportDpdBandMap[0]        :Band01(LSB)~Band32(MSB);supportDpdBandMap[1]         :Band33(LSB)~Band64(MSB)
    unsigned int  supportCim3BandMap[2];        ///< supportCim3BandMap[0]       :Band01(LSB)~Band32(MSB);supportCim3BandMap[1]        :Band33(LSB)~Band64(MSB)
    unsigned int  supportHRMBandMap[2];         ///< supportHRMBandMap[0]        :Band01(LSB)~Band32(MSB);supportHRMBandMap[1]         :Band33(LSB)~Band64(MSB)
    unsigned int  supportNCCAOneElnaBandMap[2]; ///< supportNCCAOneElnaBandMap[0]:Band01(LSB)~Band32(MSB);supportNCCAOneElnaBandMap[1] :Band33(LSB)~Band64(MSB)
} ErfCapabilityItemSet;

typedef struct
{
    unsigned int is_capable: 1;
    unsigned int is_mandatory: 1;
    unsigned int parameter: 30;
} ErfCalibrationItem;

typedef struct
{
    ErfCalibrationItem tadc_cal;                     /**< [0] TADC calibration capability.                 ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem multi_rat_tadc_bitmap;        /**< [1] Bit map of multi-rat TADC calibration;       ;is_capable (0: not supported, 1: supported) parameter (0|0|C|Lf|Lt|T|W|G) */
    ErfCalibrationItem multi_rat_afc_bitmap;         /**< [2] Bit map of multi-rat AFC calibration;        ;is_capable (0: not supported, 1: supported) parameter (0|0|C|Lf|Lt|T|W|G) */
    ErfCalibrationItem pd_temp_comp;                 /**< [3] Target support PD temperature compensation.  ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem mipi_pa_level_and_cw_num;     /**< [4] MIPI PA power level and codeword number.     ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem temperature_info;             /**< [5] Target support temperature info.             ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem et_module_support;            /**< [6] support ET modulator.                        ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem tool_usage_setting_support;   /**< [7] Support set tool usage or not.               ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem thermal_sensor_type;          /**< [8] Target support temp sensor type.             ;is_capable (0: not supported, 1: supported) parameter (0: internal, 1: external) */
    ErfCalibrationItem cap_id_calibration;           /**< [9] Target support CAP ID calibration.           ;is_capable (0: not supported, 1: supported) parameter (MAX CAP ID) */
    ErfCalibrationItem enable_csr;                   /**< [10] Target support carrier search.              ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem gps_co_tms_support;           /**< [11] Target support GPS CO-TMS.                  ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_ca_support;               /**< [12] Target support CA mode.                     ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_ca_ena;                   /**< [13] Target enable CA mode.                      ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_dpd_support;              /**< [14] DPD calibration item.                       ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_cim3_support;             /**< [15] CIM3 calibration item.                      ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_coexistence_support;      /**< [16] Coexistence calibration item.               ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_hrm_support;              /**< [17] HRM calibration item.                       ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem fhc_sw_time;                  /**< [18] FHC dut's minimum switch time               ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem nsft_extension;               /**< [19] NSFT extension.                             ;is_capable (0: not supported, 1: supported) parameter (0x01:HRM 0x02:filter mode)*/
    ErfCalibrationItem lte_tas_support;              /**< [20] TAS support.                                ;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem ncca_bypass_check;            /**< [21] For reporting NCCA Bypass check rx gain mode;is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_generation_version;       /**< [22]: For reporting generation version control   ;is_capable (0: not supported, 1: supported) parameter (0x01:MD_V1 0x02:MD_V2...)*/
    ErfCalibrationItem lte_rftool_ui_version;        /**< [23]: For reporting RF tool UI version control   ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem additional_palevel_support;
    ErfCalibrationItem lte_elna_support;             /**< [25]: For lte elna feature support               ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem lte_band2bitmap;              /**< [26]:For lte band to bitmap mapping  */
    ErfCalibrationItem lte_ubin_mode_setup;          /**< [27]:For lte UBin support                        ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem lte_auxadc_read;              /**< [28]:For lte AuxADC read                         ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem lte_fhc_rx_measurement_info;  /**< [29]:For lte FHC RSSI measurement information    ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem lte_fhc_tx_measurement_info;  /**< [30]:For lte FHC Sinetone stable measurement information             ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem lte_ul256qam_support;         /**< [31]:Indicate whether "ul 256qam" is supported or not                ; is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_max_ulcc_support;         /**< [32]:For reporting max ul cc to META tool                            ; parameter (max_ulcc: 8; reserve: 22) */
    ErfCalibrationItem lte_force_mode_rxtx_support;  /**< [33]:Indicate whether pseudo TXRX in force mode is supported or not  ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem report_rx_gain_in_mix_mode;   /**< [34]:Indicate whether "reporting used RX gain in RSRP/RSRQ mode" is supported or not ;is_capable (0: not supported, 1: supported) parameter */
    ErfCalibrationItem lte_afc_fhc;                  /**< [35]:Indicate AFC support FHC or not                                 ;is_capable (0: not supported, 1: supported) parameter (capid_seqment: 8; reserve: 22) */
    ErfCalibrationItem lte_tx_power_modification;    /**< [36]:Indicate LTE power Adjustment in NSFT stage supported or not    ;is_capable (0: not supported, 1: supported) parameter */    
    ErfCalibrationItem lte_mipi_pa_tuning_support;   /**< [37]:Indicate LTE MIPI code word supported or not                    ;is_capable (0: not supported, 1: supported) parameter bit0: ET, bit1: DPD */
    ErfCalibrationItem lte_tx_forward_test;          /**< [38]:Indicate tx forward test is supported or not                    ; is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_nsft_partial_band_info;   /**< [39]:Indicate reporting freq range by-comp-route is supported or not ; is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem lte_tx_config_updt;           /**< [40]:Indicate whether "tx config updt for route, pwr, vrb, mcs without sync cell" is supported or not ; is_capable (0: not supported, 1: supported) */
} ErfCalibrationItemSet;

#define ERF_RF_ID_UNSUPPORT (0)
#define ERF_RF_ID_MT6169    (1)
#define ERF_RF_ID_MT6176    (2)
#define ERF_RF_ID_MT6179    (3)
#define ERF_RF_ID_MT6177    (4)
#define ERF_RF_ID_MT6177M   (5)
#define ERF_RF_ID_MT6185    (6)
#define ERF_RF_ID_MT6186    (7)
#define ERF_RF_ID_MT6185E2  (8)

typedef struct
{
    int                    valid;
    int                    status;
    unsigned int           rfId;
    ErfCapabilityItemSet   capabilityItems;
    ErfCalibrationItemSet  calibrationItems;
} ERfTestCmdRfCapabilityCnf;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetRfCapability_r
 */
META_RESULT __stdcall META_ERf_GetRfCapability( const unsigned int ms_timeout, const ERfTestCmdRfCapabilityReq* req, const unsigned int requestLength, ERfTestCmdRfCapabilityCnf* resp, const unsigned int responseLength );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetRfCapability_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdRfCapabilityReq* req, const unsigned int requestLength, ERfTestCmdRfCapabilityCnf* resp, const unsigned int responseLength );

typedef struct
{
    unsigned char duplexMode /**< 0:tdd, 1:fdd */;
    unsigned char band;
    unsigned short ulFrequency;/**< range: 7280~26900 (100KHz unit) */
    unsigned char capid;    /**< 0 ~ 255 */
    short afcdac;  /**< 0 ~ 8191 */
    unsigned char afcDataType; /**< 0: calibration data, 1: interface */
    short txPowerValue;/**<S(8,8),  x dB * 256.0 */
} ERfTestCmdAfcSingleToneTx;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_AfcSingleToneTx_r
 */
META_RESULT  __stdcall META_ERf_AfcSingleToneTx( const ERfTestCmdAfcSingleToneTx* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \details AFC single tone TX for calibrating frequency error.
 * \param meta_handle meta handle
 * \param req The single TX control parameters to target
 * \param ms_timeout time out in ms
 * \sa ERF_TEST_CMD_START_AFC_SINGLE_TONE_TX
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_AfcSingleToneTx_r( const int meta_handle, const ERfTestCmdAfcSingleToneTx* req, const unsigned int ms_timeout);

typedef struct
{
    unsigned char     capid;      /**< the LTE AFC CAP ID value which ranges from 0 to 255 */
    unsigned short    afcdac;     /**< the LTE AFC DAC value which ranges from 0 to 8191 */
    int               slopeInv;   /**< the LTE AFC Slop value */
} ERfFreqAdjustTable;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetAfcSetting_r
 */
META_RESULT  __stdcall META_ERf_GetAfcSetting( const unsigned int ms_timeout, ERfFreqAdjustTable* resp );
/**
 * \ingroup LTE
 * \details Getting the LTE AFC calibration from target.
 * \param meta_handle context handle to specific DUT
 * \param resp the pointer to a memory space for storing the result of AFC calibration item acquired from target.
 * \param ms_timeout API transaction timeout value in milliseconds
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 **/
META_RESULT  __stdcall META_ERf_GetAfcSetting_r( const int meta_handle, const unsigned int ms_timeout, ERfFreqAdjustTable* resp );
/**
 * \ingroup LTE
 * \brief non-reentrant version of META_ERf_SetAfcSetting_r
 */
META_RESULT  __stdcall META_ERf_SetAfcSetting( const ERfFreqAdjustTable* req, const unsigned int ms_timeout );
/**
 * \ingroup LTE
 * \details For updating the LTE AFC calibration to target
 * \param meta_handle context handle to specific DUT
 * \param req the pointer to a memory space which is stored the AFC data for writing to target.
 * \param ms_timeout API transaction timeout value in milliseconds
 *
 * \retval META_SUCCESS The operation completed successfully. 
 * \retval META_TIMEOUT Target was no response when the given TIMEOUT interval expired. 
 * \retval META_FAILED The requested operation was unsuccessful.
 **/
META_RESULT  __stdcall META_ERf_SetAfcSetting_r( const int meta_handle, const ERfFreqAdjustTable* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned char duplexMode /**< 0:tdd, 1:fdd */;
    unsigned char band;
    unsigned short ulFrequency;/**< range: 7280~26900 (100KHz unit) */
    unsigned char bandwidth;///<(UL BW) 0: 6 RB, 1: 15 RB, 2: 25 RB, 3: 50 RB, 4: 75 RB, 5: 100 RB
    short ulFrequencyOffset;/*<* range: -32768~32767, 6 ==> 90K (1:15K), multipler of 6 */
    short afcdac;
    unsigned char afcDataType; /**< 0: calibration data, 1: interface */
    short txPowerValue;/*<*S(8,8), x dB * 256.0 */
    unsigned char txCloseLoopDisbl;
    unsigned char pa_mode;
} ERfTestCmdTpcSingleToneTx;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_ApcSingleToneTx_r
 */
META_RESULT  __stdcall META_ERf_ApcSingleToneTx( const ERfTestCmdTpcSingleToneTx* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \details APC single tone TX for calibrating TX power.
 * \param meta_handle meta handle
 * \param req The single TX control parameters to target
 * \param ms_timeout time out in ms
 * \sa ERF_TEST_CMD_START_TPC_SINGLE_TONE_TX
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_ApcSingleToneTx_r( const int meta_handle, const ERfTestCmdTpcSingleToneTx* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned char   band; /**< 1~40 */
    short           txPaGain[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE]; /**< resolution 1/32 */
} ERfTestCmdSetTpcPaGain;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_UpdateRunTimePaGains_r
 */
META_RESULT  __stdcall META_ERf_UpdateRunTimePaGains( const ERfTestCmdSetTpcPaGain* req, const unsigned int ms_timeout );
/**
 * \ingroup LTE
 * \details The API for changing the TX PA gain in DRAM (runtime value)
 *     for calibrating TX power.
 * \param meta_handle meta handle
 * \param req The pa gain of 8-level DC2DC table
 * \param ms_timeout time out in ms
 * \sa ERF_TEST_CMD_SET_TPC_PA_GAIN
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_UpdateRunTimePaGains_r( const int meta_handle, const ERfTestCmdSetTpcPaGain* req, const unsigned int ms_timeout );
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetPowerDectorValue_r
 */
META_RESULT  __stdcall META_ERf_GetPowerDectorValue( const unsigned int ms_timeout, short* txPowerDetectorValue );
/**
 * \ingroup LTE
 * \details The API for acquiring the DAC value of power detector.
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param txPowerDetectorValue the short space for storing the DAC value of
 *                 power detector acquiring from target.
 * \sa ERF_TEST_CMD_GET_POWER_DETECTOR_VALUE
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_GetPowerDectorValue_r( const int meta_handle, const unsigned int ms_timeout, short* txPowerDetectorValue );

typedef struct
{
#define MAX_ERF_TEST_RX_RSSI_FREQ_NUM 36
    unsigned char   duplexMode;/**< 0:tdd, 1:fdd */
    unsigned char   band; /**< 1~40 */
    unsigned char   num_freq; /**< 1~36 */
    unsigned short  dl_freq[MAX_ERF_TEST_RX_RSSI_FREQ_NUM];
    unsigned char   temperatureIndex; /**< 0~7 */
    short           gain1; /**< main path, resolution 1/32 */
    short           gain2; /**< rx diversity path, resolution 1/32 */
} ERfTestCmdRSSI;

typedef struct
{
    unsigned char   num_freq;
    short           dl_freq[MAX_ERF_TEST_RX_RSSI_FREQ_NUM];
    short           rssi[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /**< resolution 1/32 */
    unsigned char   lna_mode[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /**< 0 ~ 5 */
    short           rssi_rxd[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /**< resolution 1/32 */
    unsigned char   lna_mode_rxd[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /**< 0 ~ 5 */
} ERfTestResultRSSI;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_Rssi_r
 */
META_RESULT  __stdcall META_ERf_Rssi( const ERfTestCmdRSSI* req, const unsigned int ms_timeout, ERfTestResultRSSI* resp );
/**
 * \ingroup LTE
 * \details The API for calibrating RX path loss.
 *     Set the command to target and get back the RSSI value.
 * \param meta_handle meta handle
 * \param req RSSI commands to target
 * \param ms_timeout time out in ms
 * \param resp RSSI results acquired from target
 * \sa ERF_TEST_CMD_START_RSSI
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_Rssi_r( const int meta_handle, const ERfTestCmdRSSI* req, const unsigned int ms_timeout, ERfTestResultRSSI* resp );

typedef struct
{
    unsigned char   duplexMode;                            /* 0:tdd, 1:fdd */
    unsigned char   ca_comb_tbl_idx;        /* 1~40 */
    unsigned char   num_freq;                              /* 1~36 */
    short          dl_freq[MAX_RX_CC_NUM][MAX_FHC_RX_FREQ_NUM_EX];
    unsigned char   temperatureIndex;                       /* 0~7 */
    short          gain1[MAX_RX_CC_NUM];       /* resolution 1/32 */
    short          gain2[MAX_RX_CC_NUM];       /* resolution 1/32 */
} ERfTestCmdRSSI_CaMode;

typedef struct
{
    unsigned char   num_freq;
    short          dl_freq[MAX_RX_CC_NUM][MAX_FHC_RX_FREQ_NUM_EX];
    short          rssi[MAX_RX_CC_NUM][MAX_FHC_RX_FREQ_NUM_EX];         /* resolution 1/32 */
    unsigned char   lna_mode[MAX_RX_CC_NUM][MAX_FHC_RX_FREQ_NUM_EX];     /* 0 ~ 5 */
    short          rssi_rxd[MAX_RX_CC_NUM][MAX_FHC_RX_FREQ_NUM_EX];     /* resolution 1/32 */
    unsigned char   lna_mode_rxd[MAX_RX_CC_NUM][MAX_FHC_RX_FREQ_NUM_EX]; /* 0 ~ 5 */
} ERfTestResultRSSI_CaMode;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_Rssi_CaMode_r
 */
META_RESULT  __stdcall META_ERf_Rssi_CaMode( const ERfTestCmdRSSI_CaMode* req, const unsigned int ms_timeout, ERfTestResultRSSI_CaMode* resp );
/**
 * \ingroup LTE
 * \details The API for calibrating RX path loss for ca mode.
 *     Set the command to target and get back the RSSI ca mode value.
 * \param meta_handle meta handle
 * \param req RSSI ca mode commands to target
 * \param ms_timeout time out in ms
 * \param resp RSSI ca mode results acquired from target
 * \sa ERF_TEST_CMD_START_RSSI_CA_MODE
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_Rssi_CaMode_r( const int meta_handle, const ERfTestCmdRSSI_CaMode* req, const unsigned int ms_timeout, ERfTestResultRSSI_CaMode* resp );

typedef struct
{
#define MAX_ERF_TEST_RX_LNA_MODE_NUM 6
    short   lna_mode[MAX_ERF_TEST_RX_LNA_MODE_NUM]; ///<loss of mode 0~5; resolution 1/32
} ERfRSSIGainOffsetTable;

typedef struct
{
#define MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM 15
    ERfRSSIGainOffsetTable gain_of_dl_freq[MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM];
} ERfRSSITempOffsetTable;

typedef struct
{
#define MAX_ERF_TEST_RX_RSSI_TEMP_INDEX_NUM 8
    unsigned short  dlMainFrequency[MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM];
    unsigned short  dlDiversityFrequency[MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM];
    ERfRSSITempOffsetTable  pathlossMainData[MAX_ERF_TEST_RX_RSSI_TEMP_INDEX_NUM];
    ERfRSSITempOffsetTable  pathlossDiversityData[MAX_ERF_TEST_RX_RSSI_TEMP_INDEX_NUM];
} ERfRSSIBandGainTable;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetPathLossSetting_r
 */
META_RESULT  __stdcall META_ERf_SetPathLossSetting( const unsigned char band, const ERfRSSIBandGainTable* req, const unsigned int ms_timeout );
/**
 * \ingroup LTE
 * \details SET/GET gain offset table to/from target for a specific band
 * \param meta_handle meta handle
 * \param band band index
 * \param req RSSI commands to target
 * \param ms_timeout time out in ms
 * \sa ERF_TEST_CMD_SET_RSSI_SETTING
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_SetPathLossSetting_r( const int meta_handle, const unsigned char band, const ERfRSSIBandGainTable* req, const unsigned int ms_timeout );
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetPathLossSetting_r
 */
META_RESULT  __stdcall META_ERf_GetPathLossSetting( const unsigned char band, const unsigned int ms_timeout, ERfRSSIBandGainTable* resp );
/**
 * \ingroup LTE
 * \details GET gain offset table to/from target for a specific band
 * \param meta_handle meta handle
 * \param band band index
 * \param ms_timeout time out in ms
 * \param resp: RSSI results acquired from target
 * \sa ERF_TEST_CMD_GET_RSSI_SETTING
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_GetPathLossSetting_r( const int meta_handle, const unsigned char band, const unsigned int ms_timeout, ERfRSSIBandGainTable* resp );

typedef enum
{
    ERF_TEST_RSSI_TABLE_TYPE_INVALID     = 0,
    ERF_TEST_RSSI_TABLE_TYPE_1          = 1,  // for single band or inter-band CA RSSI table
    ERF_TEST_RSSI_TABLE_TYPE_2          = 2,  // for NCCA RSSI table
    ERF_TEST_RSSI_TABLE_TYPE_MAX,
} ERfTestRSSITableType;

typedef struct
{
    short   lna_mode[MAX_RX_LNA_MODE_NUM];  // loss of mode 0~5; resolution 1/32
} ERfRSSIGainOffsetTable_Type1;

typedef struct
{
    short   lna_mode[MAX_RX_CC_NUM][MAX_RX_LNA_N_MODE_NUM][MAX_RX_LNA_N_MODE_NUM]; // loss of mode 0~5, PCC & SCC; resolution 1/32
} ERfRSSIGainOffsetTable_Type2;

typedef struct
{
    short  temp_comp[MAX_TEMP_SECTION_NUM];
} ERfRSSITempOffsetTable_Ex;

typedef struct
{
    unsigned char   bandIndex;
    unsigned char   routeIndex;
    unsigned short  subbandFrequency[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSIGainOffsetTable_Type1 pathlossMainData[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSIGainOffsetTable_Type1 pathlossDiversityData[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSITempOffsetTable_Ex pathlossTempData;
} ERfRSSIBandGainTable_Type1;

typedef struct
{
    unsigned char   bandIndex;
    unsigned char   routeIndex;
    unsigned short  subbandFrequency[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSIGainOffsetTable_Type2 pathlossMainData[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSIGainOffsetTable_Type2 pathlossDiversityData[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSITempOffsetTable_Ex pathlossTempData;
} ERfRSSIBandGainTable_Type2;

typedef union
{
    ERfRSSIBandGainTable_Type1  t1_tbl;
    ERfRSSIBandGainTable_Type2  t2_tbl;
} ERfRSSIBandGainTable_Ex;


/**
 * \ingroup LTEStruct
 * This enum is used for show rx route data check result
 */
typedef enum
{
   /** Enum default state (no used)
    */
    ERF_TEST_RSSI_SET_STATUS_INVALID = 0,
    /** Rx route data check pass
    */
    ERF_TEST_RSSI_SET_STATUS_OK   = 1,   // set scusses
    /** Route not belong this band
    */
    ERF_TEST_RSSI_SET_STATUS_ERR1 = 2, // band mismatch with route
    /** Sub-band frequency is out of band region
    */
    ERF_TEST_RSSI_SET_STATUS_ERR2 = 3, // subband frequency out of band region
    /** Enum maximum size (no used)
    */
    ERF_TEST_RSSI_SET_STATUS_MAX,
} ERfTestRSSISetStatus;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetPathLossSettingEx_r
 */
META_RESULT  __stdcall META_ERf_SetPathLossSettingEx( const unsigned char RssiTableType, const ERfRSSIBandGainTable_Ex* req, const unsigned int ms_timeout, ERfTestRSSISetStatus* statusCode);
/**
 * \ingroup LTE
 * \details SET/GET gain offset table to/from target for a specific band
 * \param meta_handle meta handle
 * \param route_index route index
 * \param req path loss commands to target
 * \param ms_timeout time out in ms
 * \sa ERF_TEST_CMD_SET_RSSI_SETTING_EX
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_SetPathLossSettingEx_r( const int meta_handle, const unsigned char RssiTableType, const ERfRSSIBandGainTable_Ex* req, const unsigned int ms_timeout, ERfTestRSSISetStatus* statusCode);
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetPathLossSettingEx_r
 */
META_RESULT  __stdcall META_ERf_GetPathLossSettingEx( const unsigned char RssiTableType, const unsigned int ms_timeout, ERfRSSIBandGainTable_Ex* resp );
/**
 * \ingroup LTE
 * \details GET gain offset table to/from target for a specific band
 * \param meta_handle meta handle
 * \param route_index route index
 * \param ms_timeout time out in ms
 * \param resp: path loss results acquired from target
 * \sa ERF_TEST_CMD_GET_RSSI_SETTING_EX
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_GetPathLossSettingEx_r( const int meta_handle, const unsigned char RssiTableType, const unsigned int ms_timeout, ERfRSSIBandGainTable_Ex* resp );

typedef struct
{
    unsigned char   duplexMode;/**< 0:tdd, 1:fdd */
    unsigned char   band; /**< 1~40 */
    unsigned short  dl_freq;
    unsigned char   bandwidth;///<(DL BW) 0: 6 RB, 1: 15 RB, 2: 25 RB, 3: 50 RB, 4: 75 RB, 5: 100 RB
    short           gain1; /**< main path, resolution 1/32 */
    short           gain2;  /**< rx diversity path, resolution 1/32 */
} ERfTestCmdContRx;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_ContRx_r
 */
META_RESULT  __stdcall META_ERf_ContRx( const ERfTestCmdContRx* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \details Trigger DUT starts continuous RX
 * \param meta_handle meta handle
 * \param req Continuous RX commands to target
 * \param ms_timeout: time out in ms
 * \sa ERF_TEST_CMD_START_CONT_RX
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_ContRx_r( const int meta_handle, const ERfTestCmdContRx* req, const unsigned int ms_timeout);

typedef struct
{
    unsigned char duplexMode; /* 0:tdd, 1:fdd */
    unsigned char ca_comb_tbl_idx; /* 1~128 */
    unsigned short dl_freq[MAX_RX_CC_NUM];
    unsigned char bandwidth[MAX_RX_CC_NUM]; /*(DL BW) 0: 6 RB, 1: 15 RB, 2: 25 RB, 3: 50 RB, 4: 75 RB, 5: 100 RB*/
    short gain1[MAX_RX_CC_NUM]; /* main path, resolution 1/32 */
    short gain2[MAX_RX_CC_NUM]; /* rx diversity path, resolution 1/32 */
} ERfTestCmdContRx_CaMode;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_ContRx_CaMode_r
 */
META_RESULT  __stdcall META_ERf_ContRx_CaMode( const ERfTestCmdContRx_CaMode* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \details Trigger DUT starts continuous RX CA Mode
 * \param meta_handle meta handle
 * \param req Continuous RX CA Mode commands to target
 * \param ms_timeout: time out in ms
 * \sa ERF_TEST_CMD_START_CONT_RX_CA_MODE
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_ContRx_CaMode_r( const int meta_handle, const ERfTestCmdContRx_CaMode* req, const unsigned int ms_timeout);
typedef struct
{
    unsigned char  rf_band;
    unsigned char  vco_lna_port_cfg_index;
    unsigned char  is_lna_low_power_mode;  // 0: HPM, 1: LPM
} ERfTestCmdSetRxCommonCfg;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetLnaSrx_r
 */
META_RESULT  __stdcall META_ERf_SetLnaSrx( const ERfTestCmdSetRxCommonCfg* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \details Set RX path to target
 * \param meta_handle meta handle
 * \param req Set RX Path commands to target
 * \param ms_timeout: time out in ms
 * \sa non-reentrant version of ERF_TEST_CMD_SET_LNA_SRX
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_SetLnaSrx_r( const int meta_handle, const ERfTestCmdSetRxCommonCfg* req, const unsigned int ms_timeout);


typedef struct
{
    unsigned char          vco;
    unsigned char          srx;
    unsigned char          lna_port;
    unsigned char          lna_group;
} ERfTestVcoSrxLnaCfg;

typedef struct
{
    unsigned char          band;
    unsigned char          padding[MAX_SRX_LNA_SETTING_NUM];
    ERfTestVcoSrxLnaCfg     cfg[MAX_SRX_LNA_SETTING_NUM];
} ERfTestSupportVcoSrxLnaCfg;

typedef struct
{
    unsigned char          band;
    unsigned char          route_idx;
    unsigned char          usg_start_idx;
    unsigned char          usg_stop_idx;
} ERfTestUsageElm;

typedef struct
{
    ERfTestUsageElm    cat[4];
} ERfTestSupportRxUsageByBand;

typedef struct
{
    unsigned char          band;
    unsigned char          index[MAX_SCENARIO_BY_BAND_NUM];
} ERfTestSupportCaCombTblIdx;

typedef enum
{
    VCO_SRX_SEL_INVALID = 0,
    VCO_SRX_SEL_VCO     = 1,
    VCO_SRX_SEL_SRX     = 2
} ERfTestVcoSrxSel;

typedef struct
{
    unsigned char          band;
    unsigned char          bw_class;
    unsigned char          lna_port;
    unsigned char          lna_group;
    unsigned char          vco_cfg;
    unsigned char          srx_cfg;
    unsigned char          padding[2];
} ERfTestRouteDes;

typedef struct
{
    ERfTestRouteDes    cfg[MAX_RX_CC_NUM];
} ERfTestScenarioDes;

typedef struct
{
    int table_idx_count;
    ERfTestScenarioDes caCombinationTableElement[128];
} ERfTestCaCombinationTable;

typedef struct
{
    unsigned char     cc_band;
    unsigned char     cc_class;
} ERfTestCcElm;

typedef struct
{
    unsigned char      cc_num;
    unsigned char      usg_band;
    ERfTestCcElm       cc_setting[MAX_RX_CC_NUM];
} ERfTestUsageDes;

typedef struct
{
    unsigned short  usg_num;
    ERfTestUsageDes usg_array[MAX_CA_USAGE_NUM];
} ERfTestUsageDesTable;

typedef struct
{
    unsigned char         band;
    unsigned char         ca_cat_rx_cal_bitmap;
    unsigned char         ca_cat_tx_cal_bitmap;
    unsigned char         padding;
} ERfTestSupportCaCalDim;

typedef struct
{
    unsigned short         gain_mode1_ena    : 1;
    unsigned short         gain_mode2_ena    : 1;
    unsigned short         gain_mode3_ena    : 1;
    unsigned short         gain_mode4_ena    : 1;
    unsigned short         gain_mode5_ena    : 1;
    unsigned short         gain_mode6_ena    : 1;
    unsigned short         gain_mode_lpm_ena : 1;
    unsigned short         gain_mode_reserved: 9;
    unsigned short         gain_by_gain_expn_type;
} ERfTestSupportRxGainModeMask;

typedef struct
{
    unsigned short         gain_mode_setting[MAX_RX_LNA_MODE_NUM][2]; /*[0] upper limit; [1] lower limit*/
} ERfTestSupportRxGain;

typedef struct
{
   char          ncca_gbg_bypass_check_table[MAX_RX_CC_NUM][MAX_RX_LNA_N_MODE_NUM][MAX_RX_LNA_N_MODE_NUM];
} ERfTestNccaGbgBypassCheck;

#define ERF_BAND_MAPPING_TBL_SIZE 64

typedef struct
{
    /*Struct should be 4 bytes alignment*/
    unsigned int                  support_route_map[MAX_ROUTE_NUM_IN_WORD];
    unsigned int                  ltea_vco_srx_sel;
    ERfTestSupportVcoSrxLnaCfg    support_vco_srx_lna_cfg[ERF_MAX_BAND_NUM];
    ERfTestCaCombinationTable     ca_comb_tbl;
    ERfTestSupportCaCombTblIdx    support_ca_cfg_tbl_idx[ERF_MAX_BAND_NUM];
    ERfTestUsageDesTable          rx_usg_tbl;
    ERfTestSupportRxUsageByBand   support_rx_usage_by_band[ERF_MAX_BAND_NUM];
    ERfTestSupportCaCalDim        ca_cal_dim[ERF_MAX_BAND_NUM];
    ERfTestSupportRxGainModeMask  support_rx_gain_mode_mask;
    ERfTestSupportRxGain          support_rx_gain_mode_setting;
    ERfTestNccaGbgBypassCheck     ncca_gbg_bypass_check_setting;
    unsigned int                band_mapping_table[ERF_BAND_MAPPING_TBL_SIZE];
} ERfTestCmdCaConfig;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_QueryCaConfigTable_r
 */
META_RESULT  __stdcall META_ERf_QueryCaConfigTable( const unsigned int ms_timeout, ERfTestCmdCaConfig* resp);
/**
 * \ingroup LTE
 * \details To get ca config table from target
 * \param meta_handle meta handle
 * \param ms_timeout: time out in ms
 * \param resp RX ca usage table
 * \sa ERF_TEST_CMD_QUERY_RX_CA_USAGE_TABLE
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_QueryCaConfigTable_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdCaConfig* resp);

/********************
 *   FHC interface  *
 ********************/

#define MAX_FHC_BAND_NUM 10
#define MAX_FHC_RX_FREQ_NUM 22  ///< MAX( MAX_FHC_RX_FREQ_NUM, MAX_FHC_TX_FREQ_NUM )
#define MAX_FHC_TX_FREQ_NUM 22  ///< subband nubmer + middle channel
#define MAX_FHC_PWR_STEP_NUM 27     ///< 8 pa section * 3 + 3 PD values(H,M,L)

/* uplink arrangements */
typedef struct
{
    unsigned short   ul_freq;///<100kHz unit
    unsigned char    ul_bw;///<0(1.4M)~5(20M)
    unsigned char    pwr_step_num; ///< number of power steps
    short            pwr_step_value[MAX_FHC_PWR_STEP_NUM]; ///< tx power report from detector S(8, 8)
    short            pwr_step_pa_gain [MAX_FHC_PWR_STEP_NUM]; ///< PA gain used for tx power step
    unsigned char    pwr_step_pa_gain_tbl_indx [MAX_FHC_PWR_STEP_NUM]; ///< PA gain table index for tx power step
    unsigned char    pwr_step_pa_mode [MAX_FHC_PWR_STEP_NUM];  /**< 0: high, 1: middle, 2: low */
} ERf_FHC_Tx_Freq_Param;

typedef struct
{
    unsigned char    band_index; ///< band indicator (starting from 0)
    unsigned char    freq_num;
    ERf_FHC_Tx_Freq_Param freq_param[MAX_FHC_TX_FREQ_NUM];
} ERf_FHC_Tx_Band_Param;

typedef struct
{
    unsigned char    tx_step_width;///<ms unit
    unsigned char    band_num;
    ERf_FHC_Tx_Band_Param     band_param[MAX_FHC_BAND_NUM];
    short            freq_offst;///<range -32768~32767
    short            afc_dac;
    unsigned char    afc_data_type;///<0: calibration data, 1: from interface value
    unsigned char    close_loop_disable;
} ERf_FHC_Tx_Cfg;

/* uplink arrangements */
typedef struct
{
    unsigned short   dl_freq;///<100kHz unit
    unsigned char    temperature_indx;
    unsigned char    pwr_step_num;
    short            gain1[MAX_FHC_PWR_STEP_NUM];
    short            gain2[MAX_FHC_PWR_STEP_NUM];
} ERf_FHC_Rx_Freq_Param;

typedef struct
{
    unsigned char    band_index;
    unsigned char    freq_num;
    ERf_FHC_Rx_Freq_Param freq_param[MAX_FHC_RX_FREQ_NUM];
} ERf_FHC_Rx_Band_Param;

typedef struct
{
    unsigned char   tx_to_rx_time;///<ms unit
    unsigned char   band_num;
    ERf_FHC_Rx_Band_Param    band_param[MAX_FHC_BAND_NUM];
} ERf_FHC_Rx_Cfg;

/* FHC TRX command parameter */
typedef struct
{
    unsigned char    phy_cell_id;///< no used for single tone?
    unsigned char    fdd_band_start_index;
    unsigned char    fdd_band_end_index;
    unsigned char    tdd_band_start_index;
    unsigned char    tdd_band_end_index;
    unsigned char    fdd_to_tdd_switch_time;///<ms unit
    unsigned char    tdd_to_fdd_switch_time;///<ms unit
    unsigned char    tdd_tx_rx_switch_time;///<ms unit
    unsigned char    freq_switch_time;///<ms unit
    unsigned char    band_switch_time;///<ms unit
    ERf_FHC_Tx_Cfg   txCmd;
    ERf_FHC_Rx_Cfg   rxCmd;
} ERf_FHC_Cmd;


/* FHC TRX results */
typedef struct
{
    unsigned short    ul_freq;///<100kHz unit
    short             txPowerDetectorValue[MAX_FHC_PWR_STEP_NUM];
    unsigned char     pwr_step_num;
} ERf_FHC_Tx_Freq_Rpt;

typedef struct
{
    unsigned short   dl_freq;///<100kHz unit
    short            rssi[MAX_FHC_PWR_STEP_NUM];
    short            rssi_rxd[MAX_FHC_PWR_STEP_NUM];
    unsigned char    lna_mode[MAX_FHC_PWR_STEP_NUM];
    unsigned char    lna_mode_rxd[MAX_FHC_PWR_STEP_NUM];
    unsigned char    pwr_step_num;
} ERf_FHC_Rx_Freq_Rpt;

typedef struct
{
    unsigned char    band_index;
    unsigned char    tx_freq_num;
    unsigned char    rx_freq_num;
    ERf_FHC_Tx_Freq_Rpt  tx_freq_rpt[MAX_FHC_TX_FREQ_NUM];
    ERf_FHC_Rx_Freq_Rpt  rx_freq_rpt[MAX_FHC_RX_FREQ_NUM];
} ERf_FHC_TRx_Band_Rpt;

typedef struct
{
    unsigned char           band_num;
    ERf_FHC_TRx_Band_Rpt    band_rpt[MAX_FHC_BAND_NUM];
} ERf_FHC_TRx_Rpt;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_FHC_r
 */
META_RESULT  __stdcall META_ERf_FHC( const ERf_FHC_Cmd* req, const unsigned int ms_timeout, ERf_FHC_TRx_Rpt* resp );
/**
 * \ingroup LTE
 * \details Command target to execute FHC arrangements and blocking until result returns
 * \param meta_handle meta handle
 * \param req FHC arrangements
 * \param ms_timeout time out in ms
 * \param resp RSSI results and PD values acquired from target
 * \sa ERF_TEST_CMD_START_FHC
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_FHC_r( const int meta_handle, const ERf_FHC_Cmd* req, const unsigned int ms_timeout, ERf_FHC_TRx_Rpt* resp );

/********************* MT6291 Structure Definitions *********************/

/********************* CA Mode FHC REPORT *********************/
typedef struct
{
    unsigned short  dl_freq;//100kHz unit
    short          rssi_m[MAX_RX_LNA_MODE_NUM];
    short          rssi_d[MAX_RX_LNA_MODE_NUM];
} ERf_FHC_Rx_Type1_Freq_Rpt;

typedef struct
{
    unsigned short  dl_freq;//100kHz unit
    short          rssi_m[MAX_RX_CC_NUM][MAX_RX_LNA_N_MODE_NUM][MAX_RX_LNA_N_MODE_NUM];
    short          rssi_d[MAX_RX_CC_NUM][MAX_RX_LNA_N_MODE_NUM][MAX_RX_LNA_N_MODE_NUM];
} ERf_FHC_Rx_Type2_Freq_Rpt;

typedef struct
{
    unsigned char              route_index;
    unsigned char              band_index;  //real band number,  ex. band_index=LTE_BAND26
    unsigned char              rx_freq_num;
    ERf_FHC_Rx_Type1_Freq_Rpt  rx_freq_rpt[MAX_FHC_RX_FREQ_NUM_EX];
} ERf_FHC_Rx_Type1_Route_Rpt;

typedef struct
{
    unsigned char              route_index;
    unsigned char              band_index;  //real band number,  ex. band_index=LTE_BAND26
    unsigned char              rx_freq_num;
    ERf_FHC_Rx_Type2_Freq_Rpt  rx_freq_rpt[MAX_FHC_RX_FREQ_NUM_EX];
} ERf_FHC_Rx_Type2_Route_Rpt;

typedef struct
{
    unsigned short  ul_freq;      //100kHz unit
    short          txPowerDetectorValue[MAX_TX_RPT_NUM];
} ERf_FHC_Tx_Type1_Freq_Rpt;

typedef struct
{
    unsigned char             route_index;  //route_index = X th calibration Band
    unsigned char             band_index;   //real band number,  ex. band_index=LTE_BAND26
    unsigned char             tx_freq_num;
    ERf_FHC_Tx_Type1_Freq_Rpt tx_freq_rpt[MAX_FHC_TX_FREQ_NUM_EX];
} ERf_FHC_Tx_Type1_Route_Rpt;

typedef struct
{
    unsigned char               rx_type1_route_num;
    unsigned char               rx_type2_route_num;
    unsigned char               tx_type1_route_num;
    ERf_FHC_Rx_Type1_Route_Rpt  rx_type1_rpt[MAX_FHC_RX_TYPE1_ROUTE_NUM];
    ERf_FHC_Rx_Type2_Route_Rpt  rx_type2_rpt[MAX_FHC_RX_TYPE2_ROUTE_NUM];
    ERf_FHC_Tx_Type1_Route_Rpt  tx_type1_rpt[MAX_FHC_TX_TYPE1_ROUTE_NUM];
} ERf_FHC_CaMode_Rpt;

/********************* CA Mode FHC COMMAND *********************/
typedef struct
{
    short   gain_rxm[MAX_RX_LNA_MODE_NUM];
    short   gain_rxd[MAX_RX_LNA_MODE_NUM];
} ERf_FHC_Rx_Type1_Gain_Param;

typedef struct
{
    short   gain_rxm[MAX_RX_CC_NUM][MAX_RX_LNA_N_MODE_NUM][MAX_RX_LNA_N_MODE_NUM];
    short   gain_rxd[MAX_RX_CC_NUM][MAX_RX_LNA_N_MODE_NUM][MAX_RX_LNA_N_MODE_NUM];
} ERf_FHC_Rx_Type2_Gain_Param;

typedef struct
{
    unsigned char   band_index;
    unsigned char   ca_category;
    unsigned char   freq_num;
    unsigned short  dl_freq[MAX_FHC_RX_FREQ_NUM_EX]; //100kHz unit
} ERf_FHC_Rx_Band_Param_CaMode;

typedef struct
{
    unsigned char                band_num;
    ERf_FHC_Rx_Type1_Gain_Param  t1_band[3];
    ERf_FHC_Rx_Type2_Gain_Param  t2_band;
    ERf_FHC_Rx_Band_Param_CaMode band_param[ERF_MAX_BAND_NUM];
} ERf_FHC_Rx_Cfg_CaMode;

typedef struct
{
    unsigned char   band_index;
    unsigned char   freq_num;
    unsigned short  ul_freq[MAX_FHC_TX_FREQ_NUM_EX];
    unsigned char   pwr_step_pa_mode [MAX_TX_RPT_NUM];
    short          pwr_step_value[MAX_TX_RPT_NUM]; //target Power (PRF)
    short          pwr_step_pa_gain[MAX_TX_RPT_NUM];
} ERf_FHC_Tx_Band_Param_Ex;

typedef struct
{
    unsigned char   band_num;
    unsigned char   pwr_step_num;
    ERf_FHC_Tx_Band_Param_Ex    band_param[ERF_MAX_BAND_NUM];
} ERf_FHC_Tx_Cfg_Ex;

typedef struct
{
    unsigned char         fdd_to_tdd_switch_time;//ms unit
    unsigned char         fdd_tx_rx_switch_time;
    unsigned char         tdd_tx_rx_switch_time;//ms unit
    unsigned char         freq_switch_time;//ms unit
    unsigned char         band_switch_time;//ms unit
    unsigned char         step_time;
    ERf_FHC_Tx_Cfg_Ex     txCmd;
    ERf_FHC_Rx_Cfg_CaMode rxCmd;
} ERf_FHC_Cmd_CaMode;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_FHC_CaMode_r
 */
META_RESULT  __stdcall META_ERf_FHC_CaMode( const ERf_FHC_Cmd_CaMode* req, const unsigned int ms_timeout, ERf_FHC_CaMode_Rpt* resp );
/**
 * \ingroup LTE
 * \details Command target to execute CA mode FHC arrangements and blocking until result returns
 * \param meta_handle meta handle
 * \param req CA mode FHC arrangements
 * \param ms_timeout time out in ms
 * \param resp RSSI results and PD values acquired from target
 * \sa ERF_TEST_CMD_START_FHC
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_FHC_CaMode_r( const int meta_handle, const ERf_FHC_Cmd_CaMode* req, const unsigned int ms_timeout, ERf_FHC_CaMode_Rpt* resp );


typedef struct
{
    bool         ok;
    unsigned int sum;
} ERf_TemperatureResult;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetRfTemperature_r
 */
META_RESULT __stdcall META_ERf_GetRfTemperature(const unsigned int ms_timeout, const unsigned short measureCount, ERf_TemperatureResult* result);
/**
 * \ingroup LTE
 * \details Get RF Temperature sensor reading
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param measureCount number of measurements
 * \param result the temperature sensor reading value
 * \sa ERF_TEST_CMD_GET_RF_TEMP
 * \retval META_SUCCESS successful
 **/
META_RESULT __stdcall META_ERf_GetRfTemperature_r(const int meta_handle, const unsigned int ms_timeout, const unsigned short measureCount, ERf_TemperatureResult* result);

typedef struct
{
#define MAX_ERF_TEST_TADC_INDEX_NUM 8
    unsigned short data[MAX_ERF_TEST_TADC_INDEX_NUM];
} ERfTadcSetting;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetTadcSetting_r
 */
META_RESULT __stdcall META_ERf_GetTadcSetting(const unsigned int ms_timeout, ERfTadcSetting* table);
/**
 * \ingroup LTE
 * \details LTE TADC NVRAM read API
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param table the LTE TADC NVRAM data
 * \sa ERF_TEST_CMD_GET_TADC_SETTING
 * \retval META_SUCCESS successful
 **/
META_RESULT __stdcall META_ERf_GetTadcSetting_r(const int meta_handle, const unsigned int ms_timeout, ERfTadcSetting* table);
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetTadcSetting_r
 */
META_RESULT __stdcall META_ERf_SetTadcSetting(const unsigned int ms_timeout, const ERfTadcSetting* table);
/**
 * \ingroup LTE
 * \details LTE TADC NVRAM write API
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param table the LTE TADC NVRAM data
 * \sa ERF_TEST_CMD_SET_TADC_SETTING
 * \retval META_SUCCESS successful
 **/
META_RESULT __stdcall META_ERf_SetTadcSetting_r(const int meta_handle, const unsigned int ms_timeout, const ERfTadcSetting* table);
#define MAX_ERF_MIPI_POWER_LEVEL   16
#define MAX_ERF_MIPI_CODE_WORD_NUM 16
typedef struct
{
    unsigned short       rf_band_idx;
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_ERF_MIPI_POWER_LEVEL][MAX_ERF_MIPI_CODE_WORD_NUM];
} ERfSetMIPICodeWord;
typedef struct
{
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_ERF_MIPI_POWER_LEVEL][MAX_ERF_MIPI_CODE_WORD_NUM];
} ERfGetMIPICodeWord;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetMIPICodeWord_r
 */
META_RESULT __stdcall META_ERf_SetMIPICodeWord(const ERfSetMIPICodeWord* req,  unsigned int ms_timeout);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_SetMIPICodeWord_r(const int meta_handle, const ERfSetMIPICodeWord* req, const unsigned int ms_timeout);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetMIPICodeWord_r
 */
META_RESULT __stdcall META_ERf_GetMIPICodeWord(const unsigned int ms_timeout, const unsigned short RfBandIndex, ERfGetMIPICodeWord* cnf);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetMIPICodeWord_r(const int meta_handle, const unsigned int ms_timeout, const unsigned short RfBandIndex, ERfGetMIPICodeWord* cnf);

typedef enum
{
   ERF_TEST_MODEM_NULL  =  0,
   ERF_TEST_MODEM_V1    =  1,
   ERF_TEST_MODEM_V2    =  2,
   ERF_TEST_MODEM_V3    =  3,
   ERF_TEST_MODEM_V5    =  4,
   ERF_TEST_MODEM_V7    =  5,
   ERF_TEST_MODEM_END   =  0xFFFF
} ERfTestLteGeneration;
/********************* MT6292 Constant Definitions *********************/
#define      ERF_BAND_MAP_SIZE                     2 //support 2*32 bands at maximum, need to align LTE_BIT_MASK_BUFFER_SIZE
#define      ERF_MAX_BAND_NUM_V2                   35
#define      MAX_TX_CC_NUM                         2
#define      MAX_RX_CC_NUM_V2                      4
#define      MAX_RX_LNA_TYPE_NUM                   2

#define      MAX_TX_TYPE1_CATEGORY_NUM            16
#define      MAX_TX_CATEGORY_NUM                 MAX_TX_TYPE1_CATEGORY_NUM
#define      MAX_RX_TYPE1_CATEGORY_NUM            16
#define      MAX_RX_TYPE2_CATEGORY_NUM             8
#define      MAX_RX_CATEGORY_NUM                 MAX_RX_TYPE1_CATEGORY_NUM  +  MAX_RX_TYPE2_CATEGORY_NUM

#define      MAX_RX_TYPE1_LNA_N_MODE_NUM           6     //   for LNA normal mode
#define      MAX_RX_TYPE1_LNA_L_MODE_NUM           3     //   for LNA low power mode
#define      MAX_RX_TYPE1_LNA_MODE_NUM          (MAX_RX_TYPE1_LNA_N_MODE_NUM  +  MAX_RX_TYPE1_LNA_L_MODE_NUM)

#define      MAX_RX_TYPE2_LNA_N_MODE_NUM           6  //for LNA normal mode
#define      MAX_RX_TYPE2_LNA_L_MODE_NUM           3  //for LNA low power mode
#define      MAX_RX_TYPE2_LNA_MODE_NUM          (MAX_RX_TYPE2_LNA_N_MODE_NUM  +  MAX_RX_TYPE2_LNA_L_MODE_NUM)

#define      RX_TYPE2_START_ROUTE_NUM            512
/**
 * \ingroup LTEStruct
 * the maximum allowable carrier number
 */
#define      MAX_RX_TYPE2_GBG_PATH_NUM             2

#define      MAX_FHC_TX_TYPE1_ROUTE_NUM_V2       256
#define      MAX_FHC_RX_TYPE1_ROUTE_NUM_V2       512
#define      MAX_FHC_RX_TYPE2_ROUTE_NUM_V2        64

#define      MAX_TX_ROUTE_NUM                    MAX_FHC_TX_TYPE1_ROUTE_NUM_V2
#define      MAX_RX_ROUTE_NUM                    MAX_FHC_RX_TYPE1_ROUTE_NUM_V2 + MAX_FHC_RX_TYPE2_ROUTE_NUM_V2

#define      MAX_FHC_RX_TYPE1_CMD_NUM             16
#define      MAX_FHC_RX_TYPE2_CMD_NUM              8
#define      MAX_FHC_TX_TYPE1_CMD_NUM             16
#define      MAX_FHC_RX_TYPE1_REPORT_NUM          16
#define      MAX_FHC_RX_TYPE2_REPORT_NUM           8
#define      MAX_FHC_TX_TYPE1_REPORT_NUM          16

#define      MAX_RX_ANT_NUM                        2
#define      MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM     65
#define      MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM      5
#define      MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM     32

#define      ADDITIONAL_PA_LEVEL                   2
#define      MAX_TX_RPT_NUM_V2                  (MAX_TX_DET_MODE_NUM + MAX_TX_PA_LEVEL_NUM + ADDITIONAL_PA_LEVEL)
#define      ERF_MAX_TX_BYPASS_BAND_NUM            5
#define      ERF_MAX_TX_CCA_BAND_NUM             ERF_MAX_BAND_NUM_V2
#define      LTE_PORT_ASCII_ARRAY_SIZE           8
/********************* MT6292 Constant Definitions *********************/

/********************* MT6293 Constant Definitions *********************/
#define ERF_MAX_BAND_NUM_V3                       25
#define ERF_MAX_TX_CCA_BAND_NUM_V3                ERF_MAX_BAND_NUM_V3
#define ERF_MAX_TX_BYPASS_BAND_NUM_V3             5

/**
 * \ingroup LTEStruct
 * the maximum allowable sub-band frequency number
 */
#define ERF_MAX_FHC_RX_FREQ_NUM_V3                15
/**
 * \ingroup LTEStruct
 * the maximum allowable number of TX sub-band division
 */
#define ERF_MAX_FHC_TX_FREQ_NUM_V3                15

/**
 * \ingroup LTEStruct
 * main path and diversity path loss data be stored separately
 */
#define ERF_MAX_RX_ANT_NUM_V3                     2
#define ERF_MAX_RX_CC_NUM_V3                      2
#define ERF_MAX_TX_CC_NUM_V3                      2

#define ERF_MAX_RX_ELNA_TYPE_V3                   5

#define ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3          4
#define ERF_MAX_TX_CATEGORY_NUM_V3                ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3

#define ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3          4
#define ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3          2
#define ERF_MAX_RX_CATEGORY_NUM_V3                ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3 + ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3

/**
 * \ingroup LTEStruct
 * the maximum allowable combination LNA mode
 */
#define ERF_MAX_RX_LNA_MODE_NUM_V3                7

/**
 * \ingroup LTEStruct
 * the maximum allowable LNA gain mode number to be calibrated
 */
#define ERF_MAX_RX_TYPE1_SEQ_NUM_V3               7
/**
 * \ingroup LTEStruct
 * the maximum allowable LNA gain mode number to be calibrated
 */
#define ERF_MAX_RX_TYPE2_SEQ_NUM_V3               18

#define ERF_RX_TYPE2_START_ROUTE_NUM_V3           96
/**
 * \ingroup LTEStruct
 * there are two scenarios (PCC on and SCC off, or vise versa) which are run in single carrier manner
 */
#define ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3          2

#define ERF_MAX_FHC_TX_TYPE1_ROUTE_NUM_V3         50
#define ERF_MAX_FHC_RX_TYPE1_ROUTE_NUM_V3         88
#define ERF_MAX_FHC_RX_TYPE2_ROUTE_NUM_V3         22

#define ERF_MAX_TX_ROUTE_NUM_V3                   ERF_MAX_FHC_TX_TYPE1_ROUTE_NUM_V3
#define ERF_MAX_RX_ROUTE_NUM_V3                   ERF_MAX_FHC_RX_TYPE1_ROUTE_NUM_V3 + ERF_MAX_FHC_RX_TYPE2_ROUTE_NUM_V3

#define ERF_LTE_ANT_ALL_MASK_V3                   (LTE_ANT_0_MASK | LTE_ANT_1_MASK)

/**
 * \ingroup LTEStruct
 * the maximum allowable number of RX type-1 routes for single FHC command
 */
#define ERF_MAX_FHC_RX_TYPE1_CMD_NUM_V3           12
/**
 * \ingroup LTEStruct
 * the maximum allowable number of RX type-2 routes for single FHC command
 */
#define ERF_MAX_FHC_RX_TYPE2_CMD_NUM_V3           6
/**
 * \ingroup LTEStruct
 * the maximum allowable number of TX routes for single FHC command
 */
#define ERF_MAX_FHC_TX_TYPE1_CMD_NUM_V3           12

/**
 * \ingroup LTEStruct
 * the maximum allowable number of RX type-1 routes for single FHC command
 */
#define ERF_MAX_FHC_RX_TYPE1_REPORT_NUM_V3        12
/**
 * \ingroup LTEStruct
 * the maximum allowable number of RX type-2 routes for single FHC command
 */
#define ERF_MAX_FHC_RX_TYPE2_REPORT_NUM_V3        6
/**
 * \ingroup LTEStruct
 * the maximum allowable number of TX routes for single FHC command
 */
#define ERF_MAX_FHC_TX_TYPE1_REPORT_NUM_V3        12

/**
 * \ingroup LTEStruct
 * the maximum allowable band number for one single FHC command
 */
#define ERF_MAX_FHC_BAND_CMD_NUM_V3               12

/**
 * \ingroup LTEStruct
 * the maximum allowable memory size of peer buffer (50 kB)
 */
#define ERF_MAX_PEER_BUF_CNF_BYTE_SIZE            51200
#define ERF_MAX_PEER_BUF_CNF_WORD_SIZE            ERF_MAX_PEER_BUF_CNF_BYTE_SIZE >> 2

/**
 * \ingroup LTEStruct
 * which is determined by the maximum allowable rx type-1 route number data for one single setting command's peer buffer
 */
#define ERF_MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM_V3   ( ERF_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(ERfRSSIBandGainTable_Type1_V3) )
/**
 * \ingroup LTEStruct
 * which is determined by the maximum allowable rx type-2 route number data for one single setting command's peer buffer
 */
#define ERF_MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM_V3   ( ERF_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(ERfRSSIBandGainTable_Type2_V3) )
/**
 * \ingroup LTEStruct
 * which is determined by the maximum allowable tx type-1 route number data for one single setting command's peer buffer
 */
#define ERF_MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM_V3   ( ERF_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(ERfTestCmdGetSetTpcSetting_V3) )
/**
 * \ingroup LTEStructStruct
 * reserved PA steps for calibration
 */
#define ADDITIONAL_PA_LEVEL_V3                    2
/**
 * \ingroup LTEStruct
 * consist of 3 fields for detector calibration, 8 fields for PA gain calibration, and 2 reserve fields
 */
#define MAX_TX_RPT_NUM_V3                       (MAX_TX_DET_MODE_NUM + MAX_TX_PA_LEVEL_NUM + ADDITIONAL_PA_LEVEL_V3)

#define MAX_RX_RFTOOL_FERQ_NUM                    5


// Define for Multi-Mode
/**
 * \ingroup MultiModeStruct
 * the maximum combination of route and path select
 */
#define MAX_TX_ROUTE_AND_PS_NUM                    (256 * 4)
#define MMDPD_MAX_AM_LUT_PWR_NUM_V3         (16)
#define MMDPD_MAX_PM_LUT_PWR_NUM_V3         (MMDPD_MAX_AM_LUT_PWR_NUM_V3)

// Define for LTE
#define LTE_TARGET_SUPPORT_BAND_NUM_MAX_V3    (25)
#define LTE_TARGET_MAX_SUPPORT_BAND_NUM_V3  (LTE_TARGET_SUPPORT_BAND_NUM_MAX_V3)
#define LTE_DPD_MAX_CBW_NUM_V3              (6)
#define LTE_DPD_MAX_PA_LEVEL_NUM_V3         (8)
#define LTE_DPD_MAX_PGA_NUM_PER_PA_V3       (1)
#define LTE_DPD_MAX_AM_LUT_GAIN_NUM_V3      (LTE_DPD_MAX_PA_LEVEL_NUM_V3 * LTE_DPD_MAX_PGA_NUM_PER_PA_V3)
#define LTE_DPD_MAX_PM_LUT_GAIN_NUM_V3      (LTE_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define LTE_DPD_FDB_NUM_V3                  (MAX_FHC_TX_FREQ_NUM_EX * LTE_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define LTE_DPD_MAX_PTAR_TH_NUM_V3          (MAX_FHC_TX_FREQ_NUM_EX * LTE_DPD_MAX_PA_LEVEL_NUM_V3)
#define LTE_DPD_MAX_IMPLICIT_RSV_NUM_V3     (0)
#define LTE_DPD_MAX_IMPLICIT_NUM_V3         (LTE_DPD_FDB_NUM_V3 + LTE_DPD_MAX_PTAR_TH_NUM_V3 + LTE_DPD_MAX_IMPLICIT_RSV_NUM_V3)
#define LTE_DPD_MAX_SET_ALL_DATA_NUM_V3     (11)
#define LTE_DPD_MAX_GET_ALL_DATA_NUM_V3     (LTE_DPD_MAX_SET_ALL_DATA_NUM_V3)
#define LTE_DPD_MAX_SET_PARTIAL_DATA_NUM_V3 (63)

// Define for WCDMA
#define MAX_SUPPORTED_BAND_INDEX_V3         (5)
#define UL1_DPD_MAX_PA_LEVEL_NUM_V3         (8)
#define UL1_DPD_MAX_PGA_NUM_PER_PA_V3       (1)
#define UL1_DPD_MAX_AM_LUT_GAIN_NUM_V3      (UL1_DPD_MAX_PA_LEVEL_NUM_V3 * UL1_DPD_MAX_PGA_NUM_PER_PA_V3)
#define UL1_DPD_MAX_PM_LUT_GAIN_NUM_V3      (UL1_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define UL1D_DPD_MAX_PA_MODE_NUM_V3         (3)
#define UL1D_DPD_MAX_PA_HYST_NUM_V3         (UL1D_DPD_MAX_PA_MODE_NUM_V3 - 1)
#define UL1_DPD_FDB_NUM_V3                  (CAL_UARFCN_SECTION * UL1_DPD_MAX_PA_LEVEL_NUM_V3)
#define UL1_DPD_MAX_PTAR_TH_NUM_V3          (CAL_UARFCN_SECTION * UL1_DPD_MAX_PA_LEVEL_NUM_V3)
#define UL1_DPD_MAX_IMPLICIT_RSV_NUM_V3     (0)
#define UL1_DPD_MAX_IMPLICIT_NUM_V3         (UL1_DPD_FDB_NUM_V3 + UL1_DPD_MAX_PTAR_TH_NUM_V3 + UL1_DPD_MAX_IMPLICIT_RSV_NUM_V3)

//=================================C2K DPD define==========================================
#define C2K_UARFCN_SECTION                  16
#define MMRF_MAX_C2K_DPD_BAND_NUM_V3        22
#define C2K_DPD_MAX_PA_LEVEL_NUM_V3         8
#define C2K_DPD_MAX_PGA_NUM_PER_PA_V3       (1)
#define C2K_MAX_SUPPORTED_BAND_INDEX_V3     MMRF_MAX_C2K_DPD_BAND_NUM_V3
#define C2K_DPD_MAX_PA_MODE_NUM_V3          3
#define C2K_DPD_MAX_PA_HYST_NUM_V3          (C2K_DPD_MAX_PA_MODE_NUM_V3 - 1)
#define C2K_DPD_MAX_AM_LUT_GAIN_NUM_V3      (C2K_DPD_MAX_PA_LEVEL_NUM_V3 * C2K_DPD_MAX_PGA_NUM_PER_PA_V3)
#define C2K_DPD_MAX_PM_LUT_GAIN_NUM_V3      (C2K_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define C2K_DPD_FDB_NUM_V3                  (C2K_UARFCN_SECTION * C2K_DPD_MAX_PA_LEVEL_NUM_V3)
#define C2K_DPD_MAX_PTAR_TH_NUM_V3          (C2K_UARFCN_SECTION * C2K_DPD_MAX_PA_LEVEL_NUM_V3)
#define C2K_DPD_MAX_IMPLICIT_RSV_NUM_V3     (0)
#define C2K_DPD_MAX_IMPLICIT_NUM_V3         (C2K_DPD_FDB_NUM_V3 + C2K_DPD_MAX_PTAR_TH_NUM_V3 + C2K_DPD_MAX_IMPLICIT_RSV_NUM_V3)
#define MMRF_DPD_C2K_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V3      (22)


typedef enum
{
   C2K_TEST_START_DPD_INVALID              = 0,
   C2K_TEST_START_DPD_OK                   = 1,
   C2K_TEST_START_DPD_FAILURE              = 2,
   C2K_TEST_START_DPD_PEER_SIZE_MISMATCH   = 3,
   C2K_TEST_START_DPD_PARAM_ERROR          = 4
} MMRfTestSetC2kDpdPaAndDpdFacCalStatus;

typedef struct
{
    unsigned char   lut[C2K_DPD_MAX_AM_LUT_GAIN_NUM_V3][MMDPD_MAX_AM_LUT_PWR_NUM_V3];
} C2kTestCmdDpdAmLutSubBandV3;

typedef struct
{
    char            lut[C2K_DPD_MAX_PM_LUT_GAIN_NUM_V3][MMDPD_MAX_PM_LUT_PWR_NUM_V3];
} C2kTestCmdDpdPmLutSubBandV3;

typedef struct
{
    //short                       dpdImplicitArray[C2K_DPD_MAX_IMPLICIT_NUM_V3];
    C2kTestCmdDpdAmLutSubBandV3    am_lut_subband[C2K_UARFCN_SECTION];
    C2kTestCmdDpdPmLutSubBandV3    pm_lut_subband[C2K_UARFCN_SECTION];
} C2kTestCmdSetGetDpdDpdPeerV3;

    /* update NVRAM flag, 0: do not update, 1: update */
    /* 0: 1xRTT, 1: EVDO */
    /* number of band */

typedef struct
{
    /* The reference power, in 1/32 dBm. */
    short           refPwr;
    /* The reference power output PA without feq/temp compensation, in 1/32 dBm. */
    short           paGain;
    /* The PA mode info.*/
    unsigned short  paMode;
    /* The PA control RFGPOs level */
    //TODO: Below 3 parameter not used
    unsigned short  paVm0;
    unsigned short  paVm1;
    /* PA BUCK supply voltage level, unit is mv*/
    unsigned short  paVdd;
} CL1D_RF_PA_CONTEXT_T;

typedef struct
{
    short        start;  /* Tx power for L2M or M2H, unit is 1/32dBm (Q5)*/
    short        end;    /* Tx power for H2M or M2L, unit is 1/32dBm (Q5)*/
} CL1D_RF_TX_PA_HYST_DATA_T;

typedef struct
{
    short        TH_OP_A2D; //unit is 1/32dBm (Q5)
    short        TH_OP_D2A; //unit is 1/32dBm (Q5)
} CL1D_RF_APT_DPD_SWITCH_THD_T;

typedef struct
{
    short tempFreqComp[8][C2K_UARFCN_SECTION]; /*TEMP:8; FREQ:16 */
} CL1D_RF_TEMP_FREQ_COMP_DATA_T;

typedef struct
{
    short      FdB[C2K_DPD_MAX_PA_LEVEL_NUM_V3];
    short      PtarThTmp[C2K_DPD_MAX_PA_LEVEL_NUM_V3];
} CL1D_RF_TX_DPD_COMM_DATA_T;

typedef struct
{
    char                            tempCelsius[8]; /*TEMP:8 */
    unsigned short                  chanNum[C2K_UARFCN_SECTION]; /*FREQ:16 */
    CL1D_RF_TEMP_FREQ_COMP_DATA_T   paGainComp[C2K_DPD_MAX_PA_LEVEL_NUM_V3]; /*PA Gain:8 */
    CL1D_RF_TX_DPD_COMM_DATA_T      dpdComm[C2K_UARFCN_SECTION];
    short                           dpdTr[C2K_UARFCN_SECTION];
} CL1D_RF_TX_DPD_PA_GAIN_COMP_T;

typedef struct
{
    unsigned char paSectionNum;
    CL1D_RF_PA_CONTEXT_T            paSection[C2K_DPD_MAX_PA_LEVEL_NUM_V3]; /*PA Gain:8 */
    CL1D_RF_TX_PA_HYST_DATA_T       txHyst[C2K_DPD_MAX_PA_HYST_NUM_V3]; /*Hyst Region */
    short                           paPhaseComp[C2K_DPD_MAX_PA_MODE_NUM_V3]; /*PA mode:3 */
    CL1D_RF_APT_DPD_SWITCH_THD_T    aptDpdSwitchThd;
    CL1D_RF_TX_DPD_PA_GAIN_COMP_T   paGainComp;
} C2kTestCmdSetGetDpdTpcPeerV3;

typedef struct
{
    C2kTestCmdSetGetDpdTpcPeerV3        dpdtpc_peer;
} C2kTestCmdSetDpdPaAndDpdFacCalPartialOneBandV3;

typedef struct
{
    C2kTestCmdSetGetDpdTpcPeerV3    dpdtpc_peer;
    C2kTestCmdSetGetDpdDpdPeerV3    dpd_peer;
} C2kTestCmdSetDpdPaAndDpdFacCalAllOneBandV3;

typedef struct
{
    unsigned char   updateNvram;
    unsigned char   rfMode;
    unsigned char   num_of_band;
    unsigned char   bandClass[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
} C2kTestCmdSetDpdPartialReqInfoV3;
typedef struct
{
    unsigned char    num_of_band;
    unsigned char    status; /* C2kTestResultSetDpdFacCalStatusV3 */
} C2kTestResultSetDpdPartialCnfInfoV3;
typedef struct
{ 
    unsigned char   updateNvram;
    unsigned char   rfMode;
    unsigned char   num_of_band;
    unsigned char   bandClass[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
} C2kTestCmdSetDpdAllReqInfoV3;
typedef struct
{
    unsigned char    num_of_band;
    unsigned char    status; /* C2kTestResultSetDpdFacCalStatusV3 */
} C2kTestResultSetDpdAllCnfInfoV3;

typedef struct
{
    unsigned char   rfMode;
    unsigned char   num_of_band;
    unsigned char    bandClass[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
} C2kTestCmdGetDpdAllReqInfoV3;

typedef struct
{
    unsigned char    num_of_band;
    unsigned char   get_status; /* C2kTestResultGetDpdFacCalStatusV3 */
} C2kTestResultGetDpdAllCnfInfoV3;

typedef struct
{
    C2kTestCmdSetGetDpdTpcPeerV3    dpdtpc_peer;
    C2kTestCmdSetGetDpdDpdPeerV3    dpd_peer;
} C2kTestResultGetDpdPaAndDpdFacCalAllOneBandV3;

typedef struct
{
    /* Current temperature index */
    unsigned char   tempIdx;
    /* 0: 1xRTT, 1: EVDO */
    unsigned char      rfMode;
    /* number of band */
    unsigned char   num_of_band;
    unsigned char   cal_band[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
} C2kTestCmdStartDpdReqInfoV3;

typedef struct
{
    unsigned short    apt_ref_channel;
    short            tpc_wanted_p_offset;
} C2kTestCmdAptRefChannelOneBandV3;

typedef struct
{
    unsigned char   bandNum;
    unsigned char   bandClass[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
    unsigned char   status; /* MMRfTestResultStartWcdmaDpdPaAndDpdFacCalStatusV3 */
    unsigned char   curr_band_num;
    unsigned short  curr_channel;
    unsigned short  curr_pa_idx;
    short           pa_gain;
} C2kTestResultStartDpdCnfInfoV3;

//=================================C2K DPD define end==========================================

// Define request struct
typedef struct
{
    unsigned short  num_of_route_and_ps;
} ERfTestCmdSetDpdAllReqInfoV3;

typedef struct
{
    unsigned short    num_of_band;
} URfTestCmdSetDpdAllReqInfoV3;

typedef union
{
    ERfTestCmdSetDpdAllReqInfoV3    lte_dpd_req;
    URfTestCmdSetDpdAllReqInfoV3    wcdma_dpd_req;
    C2kTestCmdSetDpdAllReqInfoV3    c2k_dpd_req;
} MMRfTestCmdSetMmDpdAllReqInfoV3;

typedef struct
{
    /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned short                    rat_idx;
    MMRfTestCmdSetMmDpdAllReqInfoV3 mm_dpd_info;
} MMRfTestCmdSetDpdPaAndDpdFacCalAllReqParamV3;

typedef struct
{
    unsigned short  rf_band;
    unsigned short    comp_route;
    unsigned short    path_select;
    unsigned char    paControlLevel; /* 2~8 */
    unsigned char    calRoomTempIdx;
    short            hysteresisStart0;
    short            hysteresisEnd0;
    short            hysteresisStart1;
    short            hysteresisEnd1;
    unsigned char    paMode[LTE_DPD_MAX_PA_LEVEL_NUM_V3]; /* ERfTestTxPaModeE */
    short            pRf[LTE_DPD_MAX_PA_LEVEL_NUM_V3];
    unsigned short    paGain[LTE_DPD_MAX_PA_LEVEL_NUM_V3];
    unsigned char    dc2dcLevel[LTE_DPD_MAX_PA_LEVEL_NUM_V3]; /* voltage map by chip, TODO */
    unsigned short    vBiasDac[LTE_DPD_MAX_PA_LEVEL_NUM_V3];
    unsigned char    vm0[LTE_DPD_MAX_PA_LEVEL_NUM_V3];
    unsigned char    vm1[LTE_DPD_MAX_PA_LEVEL_NUM_V3];
    short            paGainSbWeight[MAX_TX_PA_MODE_NUM][MAX_TEMP_SECTION_NUM][MAX_FHC_TX_FREQ_NUM_EX];
    unsigned char   dpd_cal_done;
    short            dpd_tr[MAX_FHC_TX_FREQ_NUM_EX][LTE_DPD_MAX_CBW_NUM_V3];
} ERfTestCmdSetGetDpdTpcPeerV3;

typedef struct
{
    unsigned char   lut[LTE_DPD_MAX_AM_LUT_GAIN_NUM_V3][MMDPD_MAX_AM_LUT_PWR_NUM_V3];
} ERfTestCmdDpdAmLutSubBandV3;

typedef struct
{
    char            lut[LTE_DPD_MAX_PM_LUT_GAIN_NUM_V3][MMDPD_MAX_PM_LUT_PWR_NUM_V3];
} ERfTestCmdDpdPmLutSubBandV3;

typedef struct
{
    short                        dpdImplicitArray[LTE_DPD_MAX_IMPLICIT_NUM_V3]; /* For the parameters whose name will not be shown in cal file */
    ERfTestCmdDpdAmLutSubBandV3 am_lut_subband[MAX_FHC_TX_FREQ_NUM_EX];
    ERfTestCmdDpdPmLutSubBandV3 pm_lut_subband[MAX_FHC_TX_FREQ_NUM_EX];
} ERfTestCmdSetGetDpdDpdPeerV3;

typedef struct
{
    ERfTestCmdSetGetDpdTpcPeerV3    dpdtpc_peer;
    ERfTestCmdSetGetDpdDpdPeerV3    dpd_peer;
} ERfTestCmdSetDpdPaAndDpdFacCalAllOneRouteV3;

typedef struct
{
    unsigned short            rf_band;
    unsigned char            dpd_cal_done;
    short                    dpd_tr[CAL_UARFCN_SECTION];
    short                    vga_comp_subband[UL1D_DPD_MAX_PA_MODE_NUM_V3][CAL_UARFCN_SECTION];
    short                    vga_comp_temperature[UL1D_DPD_MAX_PA_MODE_NUM_V3][UL1_DPD_MAX_PA_LEVEL_NUM_V3];
    UL1D_sHYSTERESISDATA    tx_hysteresis[UL1D_DPD_MAX_PA_HYST_NUM_V3];
    unsigned char            octlev_num_section;
    unsigned int            pa_phase_compensation[UL1D_DPD_MAX_PA_MODE_NUM_V3];
    UL1D_sPMULEVHANDLE        pmu_level_handle[UL1_DPD_MAX_PA_LEVEL_NUM_V3];
} URfTestCmdSetGetDpdTpcPeerV3;

typedef struct
{
    unsigned char   lut[UL1_DPD_MAX_AM_LUT_GAIN_NUM_V3][MMDPD_MAX_AM_LUT_PWR_NUM_V3];
} URfTestCmdDpdAmLutSubBandV3;

typedef struct
{
    char            lut[UL1_DPD_MAX_PM_LUT_GAIN_NUM_V3][MMDPD_MAX_PM_LUT_PWR_NUM_V3];
} URfTestCmdDpdPmLutSubBandV3;

typedef struct
{
    short                       dpdImplicitArray[UL1_DPD_MAX_IMPLICIT_NUM_V3];
    URfTestCmdDpdAmLutSubBandV3    am_lut_subband[CAL_UARFCN_SECTION];
    URfTestCmdDpdPmLutSubBandV3    pm_lut_subband[CAL_UARFCN_SECTION];
} URfTestCmdSetGetDpdDpdPeerV3;

typedef struct
{
    URfTestCmdSetGetDpdTpcPeerV3    dpdtpc_peer;
    URfTestCmdSetGetDpdDpdPeerV3    dpd_peer;
} URfTestCmdSetDpdPaAndDpdFacCalAllOneBandV3;

typedef struct
{
   MMRfTestCmdSetDpdPaAndDpdFacCalAllReqParamV3 reqParam;
   union
   {
        ERfTestCmdSetDpdPaAndDpdFacCalAllOneRouteV3 lteReqPeer[LTE_DPD_MAX_SET_ALL_DATA_NUM_V3];
        URfTestCmdSetDpdPaAndDpdFacCalAllOneBandV3  wcdmaReqPeer[MAX_SUPPORTED_BAND_INDEX_V3];
        C2kTestCmdSetDpdPaAndDpdFacCalAllOneBandV3  c2kReqPeer[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
   };
} MMRfTestSetDpdPaAndDpdFacCalAllReqV3;


// Define confirm struct
typedef enum
{
    ERF_TEST_SET_DPDPA_DPD_COARSE_INVALID                = 0,
    ERF_TEST_SET_DPDPA_DPD_COARSE_OK                    = 1,
    ERF_TEST_SET_DPDPA_DPD_COARSE_PEER_SIZE_MISMATCH    = 2 /* count/offset mismatch */
} ERfTestResultSetDpdFacCalCoarseStatusV3;

typedef enum
{
    ERF_TEST_SET_DPDPA_DPD_ROUTE_INVALID        = 0,
    ERF_TEST_SET_DPDPA_DPD_ROUTE_OK                = 1,
    ERF_TEST_SET_DPDPA_DPD_ROUTE_BAND_MISMATCH  = 2
} ERfTestResultSetDpdFacCalRouteStatusV3;

typedef struct
{
    unsigned short  num_of_route_and_ps;
    unsigned char     coarse_status; /* ERfTestResultSetDpdFacCalCoarseStatusV3 */
    unsigned char     route_status[LTE_DPD_MAX_SET_ALL_DATA_NUM_V3]; /* ERfTestResultSetDpdFacCalRouteStatusV3 */
} ERfTestResultSetDpdAllCnfInfoV3;

typedef enum
{
   URF_TEST_SET_DPD_INVALID                = 0,
   URF_TEST_SET_DPD_OK                    = 1,
   URF_TEST_SET_DPD_PEER_SIZE_MISMATCH  = 2
}URfTestResultSetDpdFacCalStatusV3;

typedef struct
{
    unsigned short  num_of_band;
    unsigned char    status; /* URfTestResultSetDpdFacCalStatusV3 */
} URfTestResultSetDpdAllCnfInfoV3;

typedef union
{
   ERfTestResultSetDpdAllCnfInfoV3  lte_dpd_cnf;
   URfTestResultSetDpdAllCnfInfoV3  wcdma_dpd_cnf;
   C2kTestResultSetDpdAllCnfInfoV3  c2k_dpd_cnf;
}MMRfTestResultSetMmDpdAllCnfInfoV3;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                       rat_idx;
   MMRfTestResultSetMmDpdAllCnfInfoV3   mm_dpd_cnf;
}MMRfTestResultSetDpdPaAndDpdFacCalAllCnfParamV3;

typedef struct
{
   MMRfTestResultSetDpdPaAndDpdFacCalAllCnfParamV3  cnfParam;
} MMRfTestSetDpdPaAndDpdFacCalAllCnfV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPaAndDpdFacCalAll_V3_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalAll_V3( const unsigned int ms_timeout, const MMRfTestSetDpdPaAndDpdFacCalAllReqV3 *req, MMRfTestSetDpdPaAndDpdFacCalAllCnfV3 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalAll_V3_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestSetDpdPaAndDpdFacCalAllReqV3 *req, MMRfTestSetDpdPaAndDpdFacCalAllCnfV3 *cnf);

// Define request struct
typedef struct
{
    unsigned short  num_of_route_and_ps;
} ERfTestCmdSetDpdPartialReqInfoV3;

typedef struct
{
    unsigned short  num_of_band;
} URfTestCmdSetDpdPartialReqInfoV3;

typedef union
{
    ERfTestCmdSetDpdPartialReqInfoV3    lte_dpd_req;
    URfTestCmdSetDpdPartialReqInfoV3    wcdma_dpd_req;
    C2kTestCmdSetDpdPartialReqInfoV3    c2k_dpd_req;
} MMRfTestCmdSetMmDpdPartialReqInfoV3;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                       rat_idx;
   MMRfTestCmdSetMmDpdPartialReqInfoV3  mm_dpd_info;
} MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqParamV3;

typedef struct
{
    ERfTestCmdSetGetDpdTpcPeerV3        dpdtpc_peer;
} ERfTestCmdSetDpdPaAndDpdFacCalPartialOneRouteV3;

typedef struct
{
    URfTestCmdSetGetDpdTpcPeerV3        dpdtpc_peer;
} URfTestCmdSetDpdPaAndDpdFacCalPartialOneBandV3;

typedef struct
{
   MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqParamV3 reqParam;
   union
   {
        ERfTestCmdSetDpdPaAndDpdFacCalPartialOneRouteV3 lteReqPeer[LTE_DPD_MAX_SET_PARTIAL_DATA_NUM_V3];
        URfTestCmdSetDpdPaAndDpdFacCalPartialOneBandV3  wcdmaReqPeer[MAX_SUPPORTED_BAND_INDEX_V3];
        C2kTestCmdSetDpdPaAndDpdFacCalPartialOneBandV3  c2kReqPeer[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
   };
} MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqV3;


// Define confirm struct
typedef struct
{
    unsigned short  num_of_route_and_ps;
    unsigned char    coarse_status; /* ERfTestResultSetDpdFacCalCoarseStatusV3 */
    unsigned char    route_status[LTE_DPD_MAX_SET_PARTIAL_DATA_NUM_V3]; /* ERfTestResultSetDpdFacCalRouteStatusV3 */
} ERfTestResultSetDpdPartialCnfInfoV3;

typedef struct
{
    unsigned short    num_of_band;
    unsigned char    status; /* URfTestResultSetDpdFacCalStatusV3 */
} URfTestResultSetDpdPartialCnfInfoV3;

typedef union
{
    ERfTestResultSetDpdPartialCnfInfoV3 lte_dpd_cnf;
    URfTestResultSetDpdPartialCnfInfoV3 wcdma_dpd_cnf;
    C2kTestResultSetDpdPartialCnfInfoV3 c2k_dpd_cnf;
} MMRfTestResultSetMmDpdPartialCnfInfoV3;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                           rat_idx;
   MMRfTestResultSetMmDpdPartialCnfInfoV3   mm_dpd_cnf;
}MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfParamV3;

typedef struct
{
   MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfParamV3 cnfParam;
}MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPaAndDpdFacCalPartial_V3_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalPartial_V3( const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqV3 *req, MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfV3 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalPartial_V3_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqV3 *req, MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfV3 *cnf);


// Define request struct
typedef struct
{
    unsigned short  comp_route;
    unsigned short    path_select;
} ERfTestCmdRouteInfoV3;

typedef struct
{
    unsigned short            num_of_route_and_ps;
    ERfTestCmdRouteInfoV3   route_info[LTE_DPD_MAX_GET_ALL_DATA_NUM_V3];
} ERfTestCmdGetDpdAllReqInfoV3;

typedef struct
{
    unsigned short  num_of_band;
    unsigned short    band_num[MAX_SUPPORTED_BAND_INDEX_V3];
} URfTestCmdGetDpdAllReqInfoV3;

typedef union
{
   ERfTestCmdGetDpdAllReqInfoV3 lte_dpd_req;
   URfTestCmdGetDpdAllReqInfoV3 wcdma_dpd_req;
   C2kTestCmdGetDpdAllReqInfoV3 c2k_dpd_req;
}MMRfTestCmdGetMmDpdAllReqInfoV3;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                   rat_idx;
   MMRfTestCmdGetMmDpdAllReqInfoV3  mm_dpd_req;
}MMRfTestCmdGetDpdPaAndDpdFacCalAllReqParamV3;

typedef struct
{
    MMRfTestCmdGetDpdPaAndDpdFacCalAllReqParamV3 reqParam;
} MMRfTestCmdGetDpdPaAndDpdFacCalAllReqV3;


// Define confirm struct
typedef enum
{
    ERF_TEST_GET_DPD_INVALID    = 0,
    ERF_TEST_GET_DPD_OK         = 1
} ERfTestResultGetDpdFacCalStatusV3;

typedef struct
{
    unsigned short  num_of_route_and_ps;
    unsigned char    get_status; /* ERfTestResultGetDpdFacCalStatusV3 */
} ERfTestResultGetDpdAllCnfInfoV3;

typedef enum
{
   URF_TEST_GET_DPD_INVALID = 0,
   URF_TEST_GET_DPD_OK      = 1
} URfTestResultGetDpdFacCalStatusV3;

typedef struct
{
    unsigned short    num_of_band;
    unsigned char   get_status; /* URfTestResultGetDpdFacCalStatusV3 */
} URfTestResultGetDpdAllCnfInfoV3;

typedef union
{
   ERfTestResultGetDpdAllCnfInfoV3  lte_dpd_cnf;
   URfTestResultGetDpdAllCnfInfoV3  wcdma_dpd_cnf;
   C2kTestResultGetDpdAllCnfInfoV3  c2k_dpd_cnf;
} MMRfTestResultGetMmDpdAllCnfInfoV3;

typedef struct
{
    /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned short                      rat_idx;
    MMRfTestResultGetMmDpdAllCnfInfoV3  mm_dpd_cnf;
} MMRfTestResultGetDpdPaAndDpdFacCalAllCnfParamV3;

typedef struct
{
    ERfTestCmdSetGetDpdTpcPeerV3    dpdtpc_peer;
    ERfTestCmdSetGetDpdDpdPeerV3    dpd_peer;
} ERfTestResultGetDpdPaAndDpdFacCalAllOneRouteV3;

typedef struct
{
    URfTestCmdSetGetDpdTpcPeerV3    dpdtpc_peer;
    URfTestCmdSetGetDpdDpdPeerV3    dpd_peer;
} URfTestResultGetDpdPaAndDpdFacCalAllOneBandV3;

typedef struct
{
    MMRfTestResultGetDpdPaAndDpdFacCalAllCnfParamV3 cnfParam;
    union
    {
        ERfTestResultGetDpdPaAndDpdFacCalAllOneRouteV3  lteCnfPeer[LTE_DPD_MAX_GET_ALL_DATA_NUM_V3];
        URfTestResultGetDpdPaAndDpdFacCalAllOneBandV3   wcdmaCnfPeer[MAX_SUPPORTED_BAND_INDEX_V3];
        C2kTestResultGetDpdPaAndDpdFacCalAllOneBandV3   c2kCnfPeer[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
    };
} MMRfTestResultGetDpdPaAndDpdFacCalAllCnfV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdPaAndDpdFacCalAll_V3_r
 */
META_RESULT __stdcall META_MMRf_GetDpdPaAndDpdFacCalAll_V3( const unsigned int ms_timeout, MMRfTestCmdGetDpdPaAndDpdFacCalAllReqV3 *req, const MMRfTestResultGetDpdPaAndDpdFacCalAllCnfV3 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetDpdPaAndDpdFacCalAll_V3_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdGetDpdPaAndDpdFacCalAllReqV3 *req, const MMRfTestResultGetDpdPaAndDpdFacCalAllCnfV3 *cnf);


// Define request struct
typedef struct
{
    unsigned short  num_of_route_and_ps;
    unsigned short    num_of_band;
    unsigned short    cal_band[LTE_TARGET_SUPPORT_BAND_NUM_MAX_V3];
} ERfTestCmdStartDpdReqInfoV3;

typedef struct
{
    unsigned short    num_of_band;
    unsigned short  cal_band[MAX_SUPPORTED_BAND_INDEX_V3];
} URfTestCmdStartDpdReqInfoV3;

typedef union
{
   ERfTestCmdStartDpdReqInfoV3  lte_dpd_req;
   URfTestCmdStartDpdReqInfoV3  wcdma_dpd_req;
   C2kTestCmdStartDpdReqInfoV3  c2k_dpd_req;
} MMRfTestCmdStartMmDpdReqInfoV3;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                   rat_idx;
   MMRfTestCmdStartMmDpdReqInfoV3   mm_dpd_info;
} MMRfTestCmdStartDpdPaAndDpdFacCalReqParamV3;

typedef struct
{
    unsigned short  comp_route;
    unsigned short    path_select;
    unsigned short    apt_ref_channel;
    short           tpc_wanted_p_offset;
} ERfTestCmdAptRefChannelOneRouteV3;

typedef struct
{
    unsigned short    band_num;
    unsigned short    apt_ref_channel;
    short            tpc_wanted_p_offset;
} URfTestCmdAptRefChannelOneBandV3;

typedef struct
{
   MMRfTestCmdStartDpdPaAndDpdFacCalReqParamV3 reqParam;
   union
   {
        ERfTestCmdAptRefChannelOneRouteV3   lteReqPeer[MAX_TX_ROUTE_AND_PS_NUM];
        URfTestCmdAptRefChannelOneBandV3    wcdmaReqPeer[MAX_SUPPORTED_BAND_INDEX_V3];
        C2kTestCmdAptRefChannelOneBandV3    c2kReqPeer[C2K_MAX_SUPPORTED_BAND_INDEX_V3];
   };
} MMRfTestCmdStartDpdPaAndDpdFacCalReqV3;


// Define confirm struct
typedef enum
{
    ERF_TEST_START_DPD_INVALID                  = 0,
    ERF_TEST_START_DPD_OK                       = 1,
    ERF_TEST_START_DPD_PEER_SIZE_MISMATCH       = 2,
    ERF_TEST_START_DPD_EXCEED_TTG_LIMIT_INIT    = 3,
    ERF_TEST_START_DPD_EXCEED_TTG_LIMIT         = 4,
    ERF_TEST_START_DPD_NEGATIVE_TR              = 5,
    ERF_TEST_START_DPD_LARGE_PA_GAIN_DIFF       = 6,
    ERF_TEST_START_DPD_TX_SIGNAL_ABNORMAL       = 7    
} ERfTestResultStartDpdPaAndDpdFacCalStatusV3;

typedef enum
{
    URF_TEST_START_DPD_INVALID                    = 0,
    URF_TEST_START_DPD_OK                         = 1,
    URF_TEST_START_DPD_PEER_SIZE_MISMATCH         = 2,
    URF_TEST_START_DPD_EXCEED_TTG_LIMIT_INIT    = 3,
    URF_TEST_START_DPD_EXCEED_TTG_LIMIT         = 4,
    URF_TEST_START_DPD_NEGATIVE_TR                 = 5,
    URF_TEST_START_DPD_LARGE_PA_GAIN_DIFF         = 6
} URfTestResultStartDpdPaAndDpdFacCalStatusV3;

typedef struct
{
    unsigned char   status; /* MMRfTestResultStartLteDpdPaAndDpdFacCalStatusV3 */
    unsigned short  curr_band_num;
    unsigned int    curr_subband_idx;
    unsigned int    curr_gain_idx;
    short           pa_gain;
} ERfTestResultStartDpdCnfInfoV3;

typedef struct
{
    unsigned char   status; /* MMRfTestResultStartWcdmaDpdPaAndDpdFacCalStatusV3 */
    unsigned short  curr_band_num;
    unsigned int    curr_subband_idx;
    unsigned int    curr_gain_idx;
    short           pa_gain;
} URfTestResultStartDpdCnfInfoV3;

typedef union
{
   ERfTestResultStartDpdCnfInfoV3   lte_dpd_status;
   URfTestResultStartDpdCnfInfoV3   wcdma_dpd_status;
   C2kTestResultStartDpdCnfInfoV3   c2k_dpd_status;
} MMRfTestResultStartMmDpdCnfInfoV3;

typedef struct
{
   unsigned short                       rat_idx;
   MMRfTestResultStartMmDpdCnfInfoV3    mm_dpd_cnf;
} MMRfTestResultStartDpdPaAndDpdFacCalCnfParamV3;

typedef struct
{
   MMRfTestResultStartDpdPaAndDpdFacCalCnfParamV3 cnfParam;
} MMRfTestResultStartDpdPaAndDpdFacCalCnfV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdPaAndDpdFacCal_V3_r
 */
META_RESULT __stdcall META_MMRf_StartDpdPaAndDpdFacCal_V3( const unsigned int ms_timeout, const MMRfTestCmdStartDpdPaAndDpdFacCalReqV3 *req, MMRfTestResultStartDpdPaAndDpdFacCalCnfV3 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartDpdPaAndDpdFacCal_V3_r( const int meta_handle, const unsigned int ms_timeout , const MMRfTestCmdStartDpdPaAndDpdFacCalReqV3 *req, MMRfTestResultStartDpdPaAndDpdFacCalCnfV3 *cnf);
typedef enum
{
   URF_TEST_TRAD_CAL_EXE_INVALID    = 0,
   URF_TEST_TRAD_CAL_EXE_START      = 1,
   URF_TEST_TRAD_CAL_EXE_END        = 2
} URfTestCmdForceTradCalExeStatus;
typedef struct
{
    unsigned int exe_status;
} URfTestCmdForceTradCalTxModeReqInfo;

typedef union
{
    URfTestCmdForceTradCalTxModeReqInfo wcdma_trad_cal_info;
} MMRfTestCmdForceTradCalTxModeReqInfo;
typedef struct
{
    unsigned short  rat_idx;
    MMRfTestCmdForceTradCalTxModeReqInfo mm_trad_cal_info;
} MMRfTestCmdForceTradCalIntoAptModeReq;
typedef enum
{
   URF_TEST_TRAD_CAL_CMD_INVALID    = 0,
   URF_TEST_TRAD_CAL_CMD_OK            = 1
} URfTestResultForceTradCalCmdStatus;
typedef struct
{
    unsigned int cmd_status;
} URfTestResultForceTradCalTxModeCnfInfo;
typedef union
{
    URfTestResultForceTradCalTxModeCnfInfo wcdma_trad_cal_info;
} MMRfTestResultForceTradCalTxModeCnfInfo;
typedef struct
{
    unsigned short  rat_idx;
    MMRfTestResultForceTradCalTxModeCnfInfo mm_trad_cal_info;
} MMRfTestResultForceTradCalIntoAptModeCnf;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_ForceTradCalIntoAptMode_r
 */
META_RESULT __stdcall META_MMRf_ForceTradCalIntoAptMode( const unsigned int ms_timeout, const MMRfTestCmdForceTradCalIntoAptModeReq *req, MMRfTestResultForceTradCalIntoAptModeCnf *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_ForceTradCalIntoAptMode_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdForceTradCalIntoAptModeReq *req, MMRfTestResultForceTradCalIntoAptModeCnf *cnf);
/********************* MT6293 Constant Definitions *********************/

/********************* MT6292 Structure Definitions *********************/
typedef struct
{
    unsigned char       total_route_num;
    unsigned char       padding;
    unsigned short      band;
    unsigned short      total_route_idx[MAX_TX_TYPE1_CATEGORY_NUM];
    unsigned short      comp_route_idx[MAX_TX_TYPE1_CATEGORY_NUM];//take considerate FE route + RFIC route
    unsigned short      FE_route_idx[MAX_TX_TYPE1_CATEGORY_NUM];
    unsigned char       port[MAX_TX_TYPE1_CATEGORY_NUM];
    unsigned char       stx[MAX_TX_TYPE1_CATEGORY_NUM];
} ERfTestTxType1CaInfo;

typedef struct
{
    unsigned char    total_route_num;
    unsigned char    padding;
    unsigned short   band;
    unsigned short   total_route_idx[MAX_RX_TYPE1_CATEGORY_NUM];
    unsigned short   comp_route_idx[MAX_RX_TYPE1_CATEGORY_NUM];
    unsigned short   FE_route_idx[MAX_RX_TYPE1_CATEGORY_NUM];
    unsigned char    port[MAX_RX_TYPE1_CATEGORY_NUM][MAX_RX_ANT_NUM];
    unsigned char    dummy_param1[MAX_RX_TYPE1_CATEGORY_NUM];
    unsigned char    srx[MAX_RX_TYPE1_CATEGORY_NUM];
    unsigned char    dummy_param2[MAX_RX_TYPE1_CATEGORY_NUM];
} ERfTestRxType1CaInfo;

typedef struct
{
    unsigned char       total_route_num;
    unsigned char       padding;
    unsigned short      band;
    unsigned short      total_route_idx[MAX_RX_TYPE2_CATEGORY_NUM];
    unsigned short      comp_route_idx[MAX_RX_TYPE2_CATEGORY_NUM];
    unsigned char       FE_route_idx[MAX_RX_TYPE2_CATEGORY_NUM];
    unsigned char       port[MAX_RX_TYPE2_CATEGORY_NUM][2];
    unsigned char       dummy_param1[MAX_RX_TYPE2_CATEGORY_NUM];
    unsigned char       srx[MAX_RX_TYPE2_CATEGORY_NUM][MAX_RX_TYPE2_GBG_PATH_NUM];
    unsigned char       dummy_param2[MAX_RX_TYPE2_CATEGORY_NUM][MAX_RX_TYPE2_GBG_PATH_NUM];
} ERfTestRxType2CaInfo;

typedef struct
{
    ERfTestTxType1CaInfo     tx_type1_ca_info[ERF_MAX_BAND_NUM_V2];
    ERfTestRxType1CaInfo     rx_type1_ca_info[ERF_MAX_BAND_NUM_V2];
    ERfTestRxType2CaInfo     rx_type2_ca_info[ERF_MAX_BAND_NUM_V2];
} ERfTestTRxCaInfo;

typedef struct
{
    unsigned char    total_route_num;
    unsigned char    padding[3];
    unsigned short    band;
    unsigned short    route_idx[MAX_TX_TYPE1_CATEGORY_NUM];
} ERfTestTxCCARouteInfo, ERfTestTxFilterRouteInfo;

typedef struct
{
   unsigned char        total_band_num;
   ERfTestTxCCARouteInfo tx_cca_route_info[ERF_MAX_TX_CCA_BAND_NUM];
} ERfTestTxCCAInfo;

typedef struct
{
   unsigned char          total_band_num;
   ERfTestTxFilterRouteInfo    tx_filter_route_info[ERF_MAX_TX_BYPASS_BAND_NUM];
} ERfTestTxFILTERInfo;

typedef struct
{
    unsigned char    normal_used_tbl[MAX_RX_TYPE1_LNA_N_MODE_NUM];
    unsigned char    lpm_used_tbl[MAX_RX_TYPE1_LNA_N_MODE_NUM];
} ERfTestRXUsageType1Info;

typedef struct
{
    unsigned char    gbg_normal_used_tbl[MAX_RX_TYPE2_LNA_N_MODE_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM];
    unsigned char    gbg_lpm_used_tbl[MAX_RX_TYPE2_LNA_N_MODE_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM];
    unsigned char    partialon_normal_used_tbl[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE1_LNA_N_MODE_NUM];
    unsigned char    partialon_lpm_used_tbl[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE1_LNA_N_MODE_NUM];
} ERfTestRXUsageType2Info;

typedef struct
{
    ERfTestRXUsageType1Info    rx_type1_usagetbl;
    ERfTestRXUsageType2Info    rx_type2_usagetbl;
} ERfTestRXUsageInfo;

typedef struct
{
    short    normalmode_gain[MAX_RX_TYPE1_LNA_N_MODE_NUM][MAX_RX_ANT_NUM]; //[ Upper Bound, Lower Bound ]
    short    lpm_gain[MAX_RX_TYPE1_LNA_N_MODE_NUM][MAX_RX_ANT_NUM];
} ERfTestRXGainInfo;

typedef struct
{
    unsigned char  total_route_num;
    unsigned char  padding;
    unsigned short band;
    unsigned short total_route_idx[MAX_TX_TYPE1_CATEGORY_NUM];
    unsigned short comp_route_idx[MAX_TX_TYPE1_CATEGORY_NUM];
    unsigned char  port[MAX_TX_TYPE1_CATEGORY_NUM][LTE_PORT_ASCII_ARRAY_SIZE];
} ERfTestTxType1PortInfo;

typedef struct
{
    unsigned char  total_route_num;
    unsigned char  padding;
    unsigned short band;
    unsigned short total_route_idx[MAX_RX_TYPE1_CATEGORY_NUM];
    unsigned short comp_route_idx[MAX_RX_TYPE1_CATEGORY_NUM];
    unsigned char  port[MAX_RX_TYPE1_CATEGORY_NUM][MAX_RX_ANT_NUM][LTE_PORT_ASCII_ARRAY_SIZE];
} ERfTestRxType1PortInfo;

typedef struct
{
    unsigned char  total_route_num;
    unsigned char  padding;
    unsigned short band;
    unsigned short total_route_idx[MAX_RX_TYPE2_CATEGORY_NUM];
    unsigned short comp_route_idx[MAX_RX_TYPE2_CATEGORY_NUM];
    unsigned char  port[MAX_RX_TYPE2_CATEGORY_NUM][MAX_RX_ANT_NUM][LTE_PORT_ASCII_ARRAY_SIZE];
} ERfTestRxType2PortInfo;

typedef struct
{
    ERfTestTxType1PortInfo tx_type1_port_info[ERF_MAX_BAND_NUM_V2];
    ERfTestRxType1PortInfo rx_type1_port_info[ERF_MAX_BAND_NUM_V2];
    ERfTestRxType2PortInfo rx_type2_port_info[ERF_MAX_BAND_NUM_V2];
} ERfTestTRxPortInfo;

typedef struct
{
    unsigned char         eLNA_info[MAX_RX_ROUTE_NUM];
    unsigned short        band_mapping_info[ERF_BAND_MAPPING_TBL_SIZE];
    ERfTestTRxCaInfo      trx_ca_info;
    ERfTestTxCCAInfo      tx_cca_info;
    ERfTestTxFILTERInfo   tx_filter_info;
    ERfTestRXUsageInfo    rx_usage_info;
    ERfTestRXGainInfo     rx_gain_info;
    ERfTestTRxPortInfo    trx_band_port_info;
} ERfTestCmdCaConfig_V2;

typedef struct
{
    unsigned short band;
    unsigned char  rx_type1_num;
    unsigned char  rx_type2_num;
    unsigned char  tx_type1_num;
    unsigned char  rx_freq_num;
    unsigned char  tx_freq_num;
    unsigned char  padding;
} ERf_FHC_V2_Band_Usage_Param;

typedef struct
{
    unsigned char                 band_num;
    unsigned char                 padding;
    ERf_FHC_V2_Band_Usage_Param    band_usage[MAX_FHC_RX_TYPE1_CMD_NUM];
} ERf_FHC_V2_Band_Info_Param;

typedef struct
{
    unsigned short    route_idx;
    unsigned short    band;
    unsigned short    dl_freq[MAX_FHC_RX_FREQ_NUM_EX];
    short            temp_offset[MAX_TEMP_SECTION_NUM];
} ERf_FHC_V2_Rx_Type1_Cfg;

typedef struct
{
    unsigned short    route_idx;
    unsigned short    band;
    unsigned char     ant_mask;
    unsigned short    dl_freq[MAX_FHC_RX_FREQ_NUM_EX];
    short            temp_offset[MAX_TEMP_SECTION_NUM];
} ERf_FHC_V2_Rx_Type2_Cfg;

/**
 * \ingroup LTEStruct
 * This structure defines the TX path selection parameters
 */
typedef struct
{
  /** bit 0:\n
   *  0: bypass path\n
   *  1: filter path
   */
    unsigned short is_filter_path: 1;

  /** bit 1:\n
   *  0: non-CCA setting\n
   *  1: CCA setting
   */
    unsigned short is_cca_setting: 1;

  /** reserved (not used)
   */
    unsigned short reserved      :14;
} ERfTestParamTxCfg;

/**
 * \ingroup LTEStruct
 */
typedef struct
{
    unsigned short  bandIndex;
    unsigned short  routeIndex;
    ERfTestParamTxCfg path_select;
    /* PA Control */
    unsigned char   paControlLevel; /* 2~8 */
    unsigned char   calRoomTempIdx;
    short          hysteresisStart0;
    short          hysteresisEnd0;
    short          hysteresisStart1;
    short          hysteresisEnd1;
    unsigned char   paMode[MAX_TX_PA_LEVEL_NUM]; /* 0:high, 1:middle, 2:low */
    short          pRf[MAX_TX_PA_LEVEL_NUM];
    unsigned short  paGain[MAX_TX_PA_LEVEL_NUM];
    unsigned char   dc2dcLevel[MAX_TX_PA_LEVEL_NUM]; /* voltage map by chip, TODO */
    unsigned short  vBiasDac[MAX_TX_PA_LEVEL_NUM];
    unsigned char   vm0[MAX_TX_PA_LEVEL_NUM];
    unsigned char   vm1[MAX_TX_PA_LEVEL_NUM];
    unsigned short  pa_gain_g12a;
    unsigned short  pa_gain_g12b;
    /* TX Compensation */
    unsigned short  ulFrequency[MAX_FHC_TX_FREQ_NUM_EX];//100kHz unit
    short   paGainSbWeight[MAX_TX_PA_MODE_NUM][MAX_TEMP_SECTION_NUM][MAX_FHC_TX_FREQ_NUM_EX];
    short   couplerLoss[MAX_TX_DET_MODE_NUM];
    short   powerDetector[MAX_TX_DET_MODE_NUM][MAX_TEMP_SECTION_NUM][MAX_FHC_TX_FREQ_NUM_EX];
} ERfTestCmdGetSetTpcSetting_V2;

typedef struct
{
    unsigned short              route_idx;
    unsigned short              band;
    unsigned short              tx_path_sel_bitmap;
    ERfTestCmdGetSetTpcSetting_V2 tpc_settings;
    unsigned char               freq_pwr_step_num[MAX_FHC_TX_FREQ_NUM_EX];
    unsigned char               pwr_step_pa_mode[MAX_TX_RPT_NUM_V2];
    short                      pwr_step_value[MAX_TX_RPT_NUM_V2];
    short                      pwr_step_pa_gain[MAX_TX_RPT_NUM_V2];
} ERf_FHC_V2_Tx_Type1_Cfg;

typedef struct
{
    unsigned char           switch_time;
    unsigned char           tx_rx_switch_time;
    short                  gain_rxm[MAX_RX_LNA_TYPE_NUM][MAX_RX_TYPE2_LNA_MODE_NUM];
    short                  gain_rxd[MAX_RX_LNA_TYPE_NUM][MAX_RX_TYPE2_LNA_MODE_NUM];
    ERf_FHC_V2_Band_Info_Param band_info;
    ERf_FHC_V2_Rx_Type1_Cfg rx_type1_route[MAX_FHC_RX_TYPE1_CMD_NUM];
    ERf_FHC_V2_Rx_Type2_Cfg rx_type2_route[MAX_FHC_RX_TYPE2_CMD_NUM];
    ERf_FHC_V2_Tx_Type1_Cfg tx_type1_route[MAX_FHC_TX_TYPE1_CMD_NUM];
} ERf_FHC_V2_CaMode_Cmd;

typedef struct
{
    short                 txPowerDetectorValue[MAX_TX_RPT_NUM_V2];
} ERf_FHC_V2_Tx_Type1_Freq_Rpt;

typedef struct
{
    unsigned short             route_idx;
    unsigned short             band;
    unsigned short             tx_path_sel;
    unsigned char              tx_freq_num;
    unsigned char              padding;
    ERf_FHC_V2_Tx_Type1_Freq_Rpt tx_freq_rpt[MAX_FHC_TX_FREQ_NUM_EX];
} ERf_FHC_V2_Tx_Type1_Rpt;

typedef struct
{
    short partialOn[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE1_LNA_MODE_NUM];
    short lpm[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE2_LNA_L_MODE_NUM];
    short gainbygain[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM];
} ERf_FHC_V2_Rx_Type2_NCCA_Rpt;

typedef struct
{
    ERf_FHC_V2_Rx_Type2_NCCA_Rpt rssi_m;
    ERf_FHC_V2_Rx_Type2_NCCA_Rpt rssi_d;
} ERf_FHC_V2_Rx_Type2_Freq_Rpt;

typedef struct
{
    unsigned short             route_idx;
    unsigned short             band;
    unsigned char              rx_freq_num;
    unsigned char              padding;
    ERf_FHC_V2_Rx_Type2_Freq_Rpt rx_freq_rpt[MAX_FHC_RX_FREQ_NUM_EX];
} ERf_FHC_V2_Rx_Type2_Rpt;

typedef struct
{
    short rssi_m[MAX_RX_TYPE1_LNA_MODE_NUM];
    short rssi_d[MAX_RX_TYPE1_LNA_MODE_NUM];
} ERf_FHC_V2_Rx_Type1_Freq_Rpt;

typedef struct
{
    unsigned short             route_idx;
    unsigned short             band;
    unsigned char              rx_freq_num;
    unsigned char              padding;
    ERf_FHC_V2_Rx_Type1_Freq_Rpt rx_freq_rpt[MAX_FHC_RX_FREQ_NUM_EX];
} ERf_FHC_V2_Rx_Type1_Rpt;

typedef struct
{
    unsigned short         rx_type1_route_num;
    unsigned short         rx_type2_route_num;
    unsigned short         tx_type1_route_num;
    ERf_FHC_V2_Rx_Type1_Rpt rx_type1_rpt[MAX_FHC_RX_TYPE1_REPORT_NUM];
    ERf_FHC_V2_Rx_Type2_Rpt rx_type2_rpt[MAX_FHC_RX_TYPE2_REPORT_NUM];
    ERf_FHC_V2_Tx_Type1_Rpt tx_type1_rpt[MAX_FHC_TX_TYPE1_REPORT_NUM];
} ERf_FHC_V2_CaMode_Rpt;

// Peer buffer of confirm: RX Type-2
typedef struct
{
    short   lna_mode_hpm[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE1_LNA_N_MODE_NUM];
    short   lna_mode_lpm[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE1_LNA_N_MODE_NUM];
} ERfRSSIGainOffsetTable_Type2a_V2;

typedef struct
{
    short   lna_mode_hpm[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM];
    short   lna_mode_lpm[MAX_RX_TYPE2_GBG_PATH_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM][MAX_RX_TYPE2_LNA_N_MODE_NUM];
} ERfRSSIGainOffsetTable_Type2b_V2;

typedef struct
{
    unsigned short  bandIndex;
    unsigned short  routeIndex;
    unsigned short  subbandFrequency[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSIGainOffsetTable_Type2a_V2 pathlossData_sc[MAX_RX_ANT_NUM][MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSIGainOffsetTable_Type2b_V2 pathlossData_gbg[MAX_RX_ANT_NUM][MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSITempOffsetTable_Ex pathlossTempComp;
} ERfRSSIBandGainTable_Type2_V2;

// Peer buffer of confirm: RX Type-1
typedef struct
{
    short   lna_mode_hpm[MAX_RX_TYPE1_LNA_N_MODE_NUM];  // loss of mode 0~5; resolution 1/32
    short   lna_mode_lpm[MAX_RX_TYPE1_LNA_N_MODE_NUM];  // loss of mode 0~5; resolution 1/32
} ERfRSSIGainOffsetTable_Type1_V2;

typedef struct
{
    unsigned short  bandIndex;
    unsigned short  routeIndex;
    unsigned short  subbandFrequency[MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSIGainOffsetTable_Type1_V2 pathlossData[MAX_RX_ANT_NUM][MAX_FHC_RX_FREQ_NUM_EX];
    ERfRSSITempOffsetTable_Ex pathlossTempComp;
} ERfRSSIBandGainTable_Type1_V2;

/**
 * \ingroup LTEStruct
 * This structure is used for tx route supported path information
 */
typedef struct
{
   /** tx route index
   */
   unsigned short    route_index;
   /** supported tx path for the route
   */
   ERfTestParamTxCfg  path_select;
} ERfTestParamRouteInfo;

// Local parameter of request
typedef struct
{
    unsigned short  rx_type1_route_num;
    unsigned short  rx_type2_route_num;
    unsigned short  tx_type1_route_num;
    unsigned short  rx_type1_route_index[MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM];
    unsigned short  rx_type2_route_index[MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM];
    ERfTestParamRouteInfo  tx_type1_route_index[MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM];
} ERfTestCmdGetRxTxSettingReqParam_T;

// Local parameter of confirm
/**
 * \ingroup LTEStruct
 * This structure is used for tx/rx route calibration data information in following raw data poor
 */
typedef struct
{
   /** Number of tx/rx route for this get calibration data command
    */
    unsigned short  count;
   /** The memory offset about tx/rx route calibration data in whole following raw data poor
    */
    unsigned short  offset;
} ERfTestParamDynamicEntryElm;

/**
 * \ingroup LTEStruct
 * This enum is used for show get calibration data command's status
 */
typedef enum
{
   /** Enum default state (no used)
    */
    ERF_TEST_GET_RX_TX_STATUS_INVALID  = 0,
    /**
Get calibration data successfully
    */
    ERF_TEST_GET_RX_TX_STATUS_OK       = 1,
    /** Message's peer buffer exceed limitation (50KB)
    */
    ERF_TEST_GET_RX_TX_STATUS_OVERFLOW = 2,  // request parameters exceed 50kB
    /** Enum maximum size (no used)
    */
    ERF_TEST_GET_RX_TX_STATUS_MAX      = 0xFFFF
}ERfTestGetRxTxSettingStatus;
/**
 * \ingroup LTEStruct
 * This enum is used for show set calibration data command's status
 */
typedef enum
{
   /** Enum default state (no used)
    */
    ERF_TEST_SET_RX_TX_STATUS_INVALID  = 0,
    /** Set calibraion successfully
    */
    ERF_TEST_SET_RX_TX_STATUS_OK       = 1,
    /** RX type-1 route data lose
    */
    ERF_TEST_SET_RX_TYPE1_PARAM_ERROR  = 2,  // TX type-1 count/offset mismatch
    /** RX type-2 route data lose
    */
    ERF_TEST_SET_RX_TYPE2_PARAM_ERROR  = 3,  // TX type-1 count/offset mismatch
    /** TX type-1 route data lose
    */
    ERF_TEST_SET_TX_TYPE1_PARAM_ERROR  = 4,  // TX type-1 count/offset mismatch
    /** Enum maximum size (no used)
    */
    ERF_TEST_SET_RX_TX_STATUS_MAX      = 0xFFFF
}ERfTestSetRxTxSettingStatus;
/**
 * \ingroup LTEStruct
 * This enum is used for show tx route data check result
 */
typedef enum
{
   /** Enum default state (no used)
    */
    ERF_TEST_TPC_SET_STATUS_INVALID = 0,
    /** Tx route data check pass
    */
    ERF_TEST_TPC_SET_STATUS_OK      = 1,  // set success
    /** Aligned rX route check error message (no used)
    */
    ERF_TEST_TPC_SET_STATUS_ERR1    = 2,  // Not used, just aligned RX
    /** Sub-band frequency is out of band region
    */
    ERF_TEST_TPC_SET_STATUS_ERR2    = 3,  // subband frequency out of band region
    /** Enum maximum size (no used)
    */
    ERF_TEST_TPC_SET_STATUS_MAX,
}ERfTestTPCSetStatus;

typedef struct
{
    unsigned int                   result;
    ERfTestGetRxTxSettingStatus  get_status;
    ERfTestParamDynamicEntryElm  rx_type1_data;
    ERfTestParamDynamicEntryElm  rx_type2_data;
    ERfTestParamDynamicEntryElm  tx_type1_data;
} ERfTestResultGetRxTxSettingCnfParam_T;

typedef struct
{
   unsigned int                result;
   ERfTestSetRxTxSettingStatus   set_status;
   unsigned short              rx_type1_result_count;
   unsigned short              rx_type2_result_count;
   unsigned short              tx_type1_result_count;
   ERfTestRSSISetStatus         rx_type1_result[MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM];
   ERfTestRSSISetStatus         rx_type2_result[MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM];
   ERfTestTPCSetStatus          tx_type1_result[MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM];
}ERfTestResultSetRxTxSettingCnfParam_T;

typedef struct
{
    unsigned short  rx_type1_route_num;
    unsigned short  rx_type2_route_num;
    unsigned short  tx_type1_route_num;
    unsigned short  rx_type1_route_index[MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM];
    unsigned short  rx_type2_route_index[MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM];
    unsigned short  tx_type1_route_index[MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM];
    // RX TX data
    ERfRSSIBandGainTable_Type1_V2 rx_type1[MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM];
    ERfRSSIBandGainTable_Type2_V2 rx_type2[MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM];
    ERfTestCmdGetSetTpcSetting_V2 tx_type1[MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM];
} ERfTestCmdRxTxSetting;

typedef enum
{
   ERF_AFC_DATA_TYPE_USE_CAL_RESULT = 0, // use calibration data
   ERF_AFC_DATA_TYPE_USE_UI_SETTING = 1  // use setting in UI
}ERfTestAfcDataTypeE;

typedef struct
{
    unsigned short          band;
       unsigned short             routeidx;
      unsigned short          tx_path_sel_bitmap;
      unsigned short          ulFrequency;/* range: 0~65535 (100KHz unit) */
       unsigned char           capid;      /* 0 ~ 255 */
    unsigned short          afcdac;     /* 0 ~ 8191 */
      ERfTestAfcDataTypeE      afcDataType;
     unsigned short          txPowerValue;       /*S(8,8),  x dB * 256.0 */
} ERfTestCmdAfcSingleToneTxV2;

typedef enum
{
    ERF_FREQ_OFFSET_m540KHZ = 0xFFDC, // -36
    ERF_FREQ_OFFSET_m450KHZ = 0xFFE2, // -30
      ERF_FREQ_OFFSET_m360KHZ = 0xFFE8, // -24
       ERF_FREQ_OFFSET_m270KHZ = 0xFFEE, // -18
    ERF_FREQ_OFFSET_m180KHZ = 0xFFF4, // -12
      ERF_FREQ_OFFSET_m90KHZ  = 0xFFFA, // -6
     ERF_FREQ_OFFSET_ZERO    = 0x0000, // 0
     ERF_FREQ_OFFSET_p90KHZ  = 0x0006, // 6
    ERF_FREQ_OFFSET_p180KHZ = 0x000C, // 12
    ERF_FREQ_OFFSET_p270KHZ = 0x0012, // 18
       ERF_FREQ_OFFSET_p360KHZ = 0x0018, // 24
       ERF_FREQ_OFFSET_p450KHZ = 0x001E, // 30
      ERF_FREQ_OFFSET_p540KHZ = 0x0024, // 36
}ERfTestFreqOffsetE;

typedef enum
{
   ERF_TX_PA_MODE_HIGH = 0,
   ERF_TX_PA_MODE_MID  = 1,
   ERF_TX_PA_MODE_LOW  = 2
}ERfTestTxPaModeE;

typedef enum
{
    ERF_PGAMODE_NORMAL = 0,
    ERF_PGAMODE_A = 1,
    ERF_PGAMODE_B = 2
} ERfTestPgaModeE;

typedef enum
{
   ERF_BW_6RB,   // 1.4 MHz
   ERF_BW_15RB,  //   3 MHz
   ERF_BW_25RB,  //   5 MHz
   ERF_BW_50RB,  //  10 MHz
   ERF_BW_75RB,  //  15 MHz
   ERF_BW_100RB, //  20 MHz
}ERfTestBwE;

typedef struct
{
    unsigned short  band;
    unsigned short  txRoute;
    unsigned short  tx_path_sel_bitmap;
    unsigned char   cc_num;
    unsigned short  ulFrequency[MAX_TX_CC_NUM];/* range: 0~65535 (100KHz unit) */
    ERfTestFreqOffsetE  ulFrequencyOffset;
    unsigned short      afcdac;
    ERfTestBwE          tx_bw[MAX_TX_CC_NUM];
    ERfTestPgaModeE     pga_mode;
    unsigned short      txPowerValue;        /* S(8,8), x dB * 256.0 */
    ERfTestAfcDataTypeE    afcDataType;
} ERfTestCmdTpcSingleToneTxV2;

typedef struct
{
    unsigned char       is_partialon;        // 0:No , 1:Yes
    unsigned char       num_freq;            // 1~15
    unsigned char       temperatureIndex;    // 0~7
    unsigned char       powermode;           // 0: ModeA (HPM), 1: ModeB (LPM)
    unsigned char       partial_on_path;
    unsigned char       ant_sel;
    unsigned short      band;
    unsigned short      dl_freq[MAX_FHC_RX_FREQ_NUM_EX];
    unsigned short      routeidx;
    short               gain0[MAX_RX_ANT_NUM];       /* resolution 1/32 */
    short               gain1[MAX_RX_ANT_NUM];       /* resolution 1/32 */
} ERfTestCmdRSSIV2;

typedef struct
{
    unsigned char   num_freq;
       unsigned short  dl_freq[MAX_FHC_RX_FREQ_NUM_EX];
      short           rssi_path0[MAX_RX_ANT_NUM][MAX_FHC_RX_FREQ_NUM_EX];
      unsigned char   lna_mode_path0[MAX_RX_ANT_NUM];
     short           rssi_path1[MAX_RX_ANT_NUM][MAX_FHC_RX_FREQ_NUM_EX];
      unsigned char   lna_mode_path1[MAX_RX_ANT_NUM];
} ERfTestResultRSSIV2CnfPdu;

typedef struct
{
   unsigned char       rx_cc_num;
   unsigned short      rx_freq[MAX_RX_CC_NUM_V2]; //frequency in 100kHz
   unsigned short      rx_band[MAX_RX_CC_NUM_V2]; //LTE BAND
   ERfTestBwE      rx_bw[MAX_RX_CC_NUM_V2];
} ErfContRxRfNormalMode;

typedef struct
{
   unsigned short   routeidx;     // judge type1 or type2
   unsigned char    is_partialon; // if type2, 0:No , 1:Yes
   unsigned char       partial_on_path;
   unsigned short      rx_freq;      // frequency in 100kHz
   unsigned short      rx_band;
   ERfTestBwE      rx_bw;
} ErfContRxRfForceMode;

typedef union
{
   ErfContRxRfForceMode      forcemode;
   ErfContRxRfNormalMode        normalmode;
} ErfContRx_Rf_Param;

typedef struct
{
    unsigned char             is_forcedmode;       // 0:No , 1:Yes
    ErfContRx_Rf_Param      contrx_param;
} ERfTestCmdContRxV2;

typedef struct
{
    unsigned char   rx_cc_num;
    unsigned short  rx_freq[MAX_RX_CC_NUM_V2];
    unsigned short  rx_band[MAX_RX_CC_NUM_V2];
    ERfTestBwE  rx_bw[MAX_RX_CC_NUM_V2];
    unsigned char   tx_cc_num;
    unsigned short  tx_freq[MAX_TX_CC_NUM];
    unsigned short  tx_band[MAX_TX_CC_NUM];
    ERfTestBwE  tx_bw[MAX_TX_CC_NUM];
} ERfTestCmdGetTxRxRouteInfo;

typedef enum
{
    ERF_TEST_GET_TXRX_ROUTE_INFO_STATUS_INVALID    = 0,
    ERF_TEST_GET_TXRX_ROUTE_INFO_STATUS_OK         = 1,
    ERF_TEST_GET_TXRX_ROUTE_INFO_STATUS_ERR1    = 2,
    ERF_TEST_GET_TXRX_ROUTE_INFO_STATUS_ERR2    = 3,
    ERF_TEST_GET_TXRX_ROUTE_INFO_STATUS_MAX,
} ERfTestGetTxRxRouteInfoStatus;

typedef struct
{
    unsigned int  result;
    ERfTestGetTxRxRouteInfoStatus get_status;
} ERfTestResultGetTxRxRouteInfo;

typedef struct
{
       unsigned short      total_route_idx;
       unsigned short      comp_route_idx;
       unsigned short      FE_route_idx;
       unsigned char       port[MAX_RX_ANT_NUM][LTE_PORT_ASCII_ARRAY_SIZE];
       unsigned char       srx;
} ERfTestRxRouteInfo;

typedef struct
{
       unsigned short  total_route_idx;
       unsigned short  comp_route_idx;
       unsigned short  FE_route_idx;
      unsigned char   port[LTE_PORT_ASCII_ARRAY_SIZE];
       unsigned char   stx;
} ERfTestTxRouteInfo;

typedef struct
{
    unsigned char        get_status;
    ERfTestTxRouteInfo  tx_route_info[MAX_TX_CC_NUM];
    ERfTestRxRouteInfo     rx_route_info[MAX_RX_CC_NUM_V2];
} ERfTestResultGetTxRxRouteInfoCnfPdu;

/********************* MT6292 Structure Definitions *********************/

/********************* MT6293 Structure Definitions *********************/

/*******************************************************************************
 * ERF_TEST_CMD_QUERY_CA_CONFIG_TABLE_V3
 ******************************************************************************/

/**
 * \ingroup LTEStruct
 * \details TX route information of a band.
 */
typedef struct
{
   unsigned char   total_route_num;                                                     /**< Total number of TX routes in this band. */
   unsigned short  band;                                                                /**< LTE band number (spec. defined). */
   unsigned char   is_hrm[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3];                            /**< . */
   unsigned short  total_route_idx[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3];                   /**< . */
   unsigned short  comp_route_idx[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3];                    /**< Route number. */ //take considerate FE route + RFIC route
   unsigned short  FE_route_idx[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3];                      /**< Front end route number. */
   unsigned char   port[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3][LTE_PORT_ASCII_ARRAY_SIZE];   /**< Port name. */
   unsigned char   stx[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3];                               /**< . */
} ERfTestTxType1CaInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details RX type 1 route information of a band.
 */
typedef struct
{
   unsigned char   total_route_num;                                                                         /**< Total number of TX routes in this band. */
   unsigned char   padding;                                                                                 /**< Memory padding (not used). */
   unsigned short  band;                                                                                    /**< LTE band number (spec. defined). */
   unsigned short  total_route_idx[ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3];                                       /**< . */ //take considerate FE route + RFIC route
   unsigned short  comp_route_idx[ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3];                                        /**< Route number. */ //take considerate FE route + RFIC route
   unsigned short  FE_route_idx[ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3];                                          /**< Front end route number. */
   unsigned char   port[ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3][ERF_MAX_RX_ANT_NUM_V3][LTE_PORT_ASCII_ARRAY_SIZE];/**< Port name. */
   unsigned char   elna[ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];                           /**< eLNA mode. */
   unsigned char   srx[ERF_MAX_RX_TYPE1_CATEGORY_NUM_V3];                                                   /**< . */
} ERfTestRxType1CaInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details RX type 2 route information of a band.
 */
typedef struct
{
   unsigned char   total_route_num;                                                                         /**< Total number of TX routes in this band. */
   unsigned char   simultaneousl_k[ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3];                                       /**< . */
   unsigned short  band;                                                                                    /**< LTE band number (spec. defined). */
   unsigned short  total_route_idx[ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3];                                       /**< . */ //take considerate FE route + RFIC route
   unsigned short  comp_route_idx[ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3];                                        /**< Route number. */ //take considerate FE route + RFIC route
   unsigned char   FE_route_idx[ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3];                                          /**< Front end route number. */
   unsigned char   port[ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3][ERF_MAX_RX_ANT_NUM_V3][LTE_PORT_ASCII_ARRAY_SIZE];/**< Port name. */
   unsigned char   elna[ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];                           /**< eLNA mode. */
   unsigned char   srx[ERF_MAX_RX_TYPE2_CATEGORY_NUM_V3][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3];                 /**< . */ //for SRX path0 & path1
} ERfTestRxType2CaInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details TX RX route information.
 */
typedef struct
{
    ERfTestTxType1CaInfoV3_T     tx_type1_ca_info[ERF_MAX_BAND_NUM_V3]; /**< TX route information. */
    ERfTestRxType1CaInfoV3_T     rx_type1_ca_info[ERF_MAX_BAND_NUM_V3]; /**< RX type 1 route information. */
    ERfTestRxType2CaInfoV3_T     rx_type2_ca_info[ERF_MAX_BAND_NUM_V3]; /**< RX type 2 route information. */
} ERfTestTRxCaInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details TX CCA route information of a band.
 */
typedef struct
{
   unsigned char   total_route_num;                             /**< Total number of TX CCA routes in this band. */
   unsigned char   padding[3];                                  /**< Memory padding (not used). */
   unsigned short  band;                                        /**< LTE band number (spec. defined). */
   unsigned short  route_idx[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3]; /**< Route number. */ //take considerate FE route + RFIC route
} ERfTestTxCCARouteInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details TX CCA route information.
 */
typedef struct
{
   unsigned char              total_band_num;                               /**< Total number of bands. */
   ERfTestTxCCARouteInfoV3_T  tx_cca_route_info[ERF_MAX_TX_CCA_BAND_NUM_V3];/**< TX CCA route information of each band. */
} ERfTestTxCCAInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details TX filter route information of a band.
 */
typedef struct
{
   unsigned char   total_route_num;                             /**< Total number of TX filter routes in this band. */
   unsigned char   padding[3];                                  /**< Memory padding (not used). */
   unsigned short  band;                                        /**< LTE band number (spec. defined). */
   unsigned short  route_idx[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V3]; /**< Route number. */ //take considerate FE route + RFIC route
} ERfTestTxFilterRouteInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details TX filter route information.
 */
typedef struct
{
   unsigned char                 total_band_num;                                        /**< Total number of bands. */
   ERfTestTxFilterRouteInfoV3_T  tx_filter_route_info[ERF_MAX_TX_BYPASS_BAND_NUM_V3];   /**< TX filter route information of each band. */
} ERfTestTxFILTERInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details There are HPM and LPM for every LNA mode in current solution
 */
typedef enum
{
   ERF_TEST_RX_HPM            = 0,     /**< Indicate for LNA HPM mode. */
   ERF_TEST_RX_LPM            = 1,     /**< Indicate for LNA LPM mode. */
   ERF_TEST_RX_POWER_MODE_NUM,         /**< There are two LNA modes. */
   ERF_TEST_RX_POWER_MODE_MAX =  0xFF  /**< Unused. */
} ERfTestRxPowerMode_E;

/**
 * \ingroup LTEStruct
 * \details RX type 1 eLNA information.
 */
typedef struct
{
   unsigned char    seq_num[ERF_TEST_RX_POWER_MODE_NUM];                                                                /**< Number of point that need to be calibrated. */
   short            dlpow_default[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                             /**< Suggested downlink power. */ // resolution 1/32
   short            dlpow_lbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                              /**< Lower bound of downlink power. */ // resolution 1/32
   short            dlpow_hbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                              /**< Higer bound of downlink power. */ // resolution 1/32
   unsigned char    dlpow_lna_mode[ERF_MAX_RX_ANT_NUM_V3][ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];     /**< Corresponding LNA mode. */
   unsigned char    dlpow_elna_bypass[ERF_MAX_RX_ANT_NUM_V3][ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];  /**< Is in bypass gain mode. */ //1:bypass(elna off)
   unsigned char    nvram_idx[ERF_MAX_RX_ANT_NUM_V3][ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];          /**< Corresponding NVRAM index to store calibrated data. */
} ERfTestElnaInfoT1V3_T;

/**
 * \ingroup LTEStruct
 * \details RX type 2 eLNA information.
 */
typedef struct
{
   unsigned char    gbg_seq_num[ERF_TEST_RX_POWER_MODE_NUM];                                                                            /**< Number of gain by gain point that need to be calibrated. */
   short            gbg_dlpow_default[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];                                         /**< Suggested downlink power. */ // resolution 1/32
   short            gbg_dlpow_lbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];                                          /**< Lower bound of downlink power. */ // resolution 1/32
   short            gbg_dlpow_hbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];                                          /**< Higer bound of downlink power. */ // resolution 1/32
   unsigned char    gbg_dlpow_lna_mode[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];      /**< Corresponding LNA mode. */
   unsigned char    gbg_dlpow_elna_bypass[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];   /**< Is in bypass gain mode. */ //1:bypass(elna off)
   unsigned char    gbg_nvram_idx[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];           /**< Corresponding NVRAM index to store gain by gain calibrated data. */
   unsigned char    sc_seq_num[ERF_TEST_RX_POWER_MODE_NUM];                                                                             /**< Number of partial-on point that need to be calibrated. */
   short            sc_dlpow_default[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                          /**< Suggested downlink power. */ // resolution 1/32
   short            sc_dlpow_lbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                           /**< Lower bound of downlink power. */ // resolution 1/32
   short            sc_dlpow_hbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                           /**< Higer bound of downlink power. */ // resolution 1/32
   unsigned char    sc_dlpow_lna_mode[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                         /**< Corresponding LNA mode. */
   unsigned char    sc_dlpow_elna_bypass[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                      /**< Is in bypass gain mode. */ //1:bypass(elna off)
   unsigned char    sc_nvram_idx[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                              /**< Corresponding NVRAM index to store partial-on calibrated data. */
} ERfTestElnaInfoT2V3_T;

/**
 * \ingroup LTEStruct
 * \details RX eLNA information.
 */
typedef struct
{
   ERfTestElnaInfoT1V3_T elna_info_t1[ERF_MAX_RX_ELNA_TYPE_V3][ERF_MAX_RX_ELNA_TYPE_V3];   /**< RX type 1 eLNA information for both main and diversity antenna. */
   ERfTestElnaInfoT2V3_T elna_info_t2[ERF_MAX_RX_ELNA_TYPE_V3];                            /**< RX type 2 eLNA information for single antenna. */
} ERfTestElnaCalInfoV3_T;

/**
 * \ingroup LTEStruct
 * \details CA configuration information of M21 series.
 */
typedef struct
{
    unsigned short          band_mapping_info[ERF_BAND_MAPPING_TBL_SIZE];   /**< Band index to band number mapping table. */
    ERfTestTRxCaInfoV3_T    trx_ca_info;                                    /**< TX RX route information. */
    ERfTestTxCCAInfoV3_T    tx_cca_info;                                    /**< TX CCA route information. */
    ERfTestTxFILTERInfoV3_T tx_filter_info;                                 /**< TX filter route information. */
    ERfTestElnaCalInfoV3_T  elna_cal_info;                                  /**< RX eLNA information. */
} ERfTestCmdCaConfig_V3;

/*******************************************************************************
 * ERF_TEST_CMD_GET_RX_TX_SETTING_V3
 ******************************************************************************/

/**
 * \ingroup LTEStruct
 * \details This structure is used for storing pathloss data by two kinks of power mode
 */
typedef struct
{
    short lna_mode_lpm; /**< Normal power mode pathloss data. */
    short lna_mode_hpm; /**< Low power mode pathloss data. */
} ERfRxPLRAWData_V3_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for storing path-loss temperature compensation value
 */
typedef struct
{
    short temp_comp[MAX_TEMP_SECTION_NUM];    /**< Path-loss temperature compensation value. */
} ERfRxTempOffsetTable_V3_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for storing pathloss data by LNA mode
 */
typedef struct
{
    ERfRxPLRAWData_V3_T    pathloss_raw[ERF_MAX_RX_LNA_MODE_NUM_V3];    /**< Pathloss data store by LNA mode. */
} ERfRxPLSubband_Type1_V3_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for storing each rx type-1 route detail information
 */
typedef struct
{
    unsigned short              bandIndex;                                      /**< LTE band number (spec. defined) for this route information element. */
    unsigned short              routeIndex;                                     /**< Route number. */
    unsigned short              subbandFrequency[ERF_MAX_FHC_RX_FREQ_NUM_V3];   /**< Sub-band frequency information. */
    ERfRxPLSubband_Type1_V3_T   pathlossData[ERF_MAX_FHC_RX_FREQ_NUM_V3][ERF_MAX_RX_ANT_NUM_V3/*0: RXM, 1: RXD*/];  /**< Pathloss data store by frequency and antenna. */
    ERfRxTempOffsetTable_V3_T   pathlossTempComp;                               /**< Path-loss temperature compensation value. */
} ERfRSSIBandGainTable_Type1_V3;

/**
 * \ingroup LTEStruct
 * \details This structure is used for pathloss data storing by carrier dimenion and LNA mode
 */
typedef struct
{
    ERfRxPLRAWData_V3_T           pathloss_raw_sc[MAX_RX_TYPE2_GBG_PATH_NUM][ERF_MAX_RX_LNA_MODE_NUM_V3];   /**< Pathloss data store by carrier dimenion and LNA mode. */
} ERfRxPLSubband_Type2A_V3_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for pathloss data storing by carrier dimenion and LNA mode combination
 */
typedef struct
{
    ERfRxPLRAWData_V3_T           pathloss_raw_gbg[MAX_RX_TYPE2_GBG_PATH_NUM][ERF_MAX_RX_LNA_MODE_NUM_V3][ERF_MAX_RX_LNA_MODE_NUM_V3];  /**< Pathloss data store by carrier dimenion and LNA mode combination. */
} ERfRxPLSubband_Type2B_V3_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for two kinds of rx type-2 path-loss data store
 */
typedef struct
{
    ERfRxPLSubband_Type2A_V3_T    pathlossData_sc;  /**< Path-loss data for single carrier. */
    ERfRxPLSubband_Type2B_V3_T    pathlossData_gbg; /**< Path-loss data for NCCA. */
} ERfRxPLSubband_Type2_V3_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for storing each rx type-2 route detail information
 */
typedef struct
{
    unsigned short              bandIndex;                                                      /**< LTE band number (spec. defined) for this route information element. */
    unsigned short              routeIndex;                                                     /**< Route number. */
    unsigned short              subbandFrequency[ERF_MAX_FHC_RX_FREQ_NUM_V3];                   /**< Sub-band frequency information. */
    ERfRxPLSubband_Type2_V3_T   pathlossData[ERF_MAX_FHC_RX_FREQ_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];/**< Pathloss data store by frequency and antenna. */
    ERfRxTempOffsetTable_V3_T   pathlossTempComp;                                               /**< Path-loss temperature compensation value. */
} ERfRSSIBandGainTable_Type2_V3;

/**
 * \ingroup LTEStruct
 * \details This structure defines the TX calibration results
 */
typedef struct
{
    unsigned short        bandIndex;        /**< LTE band number (spec. defined) for this route information element. */
    unsigned short        routeIndex;       /**< Route number. */
    ERfTestParamTxCfg     path_select;      /**< TX path selection. */
    unsigned char         paControlLevel;   /**< Division of PA gain calibration (fixed to 8). */
    unsigned char         calRoomTempIdx;   /**< Temperature region when calibrating (always 4 now: room temperature). */
    short                 hysteresisStart0; /**< Start point of 1st hysteresis (in unit of 1/32 dB) . */
    short                 hysteresisEnd0;   /**< End point of 1st hysteresis (in unit of 1/32 dB). */
    short                 hysteresisStart1; /**< Start point of 2nd hysteresis (in unit of 1/32 dB). */
    short                 hysteresisEnd1;   /**< End point of 2nd hysteresis (in unit of 1/32 dB). */

   /** PA operation mode (enumeration):\n
    *   0: PA be operated in high mode\n
    *   1: PA be operated in middle mode\n
    *   2: PA be operated in low mode\n
    */
    unsigned char         paMode[MAX_TX_PA_LEVEL_NUM];

    short                 pRf[MAX_TX_PA_LEVEL_NUM];         /**< Target TX power used in PA gain calibration (in unit of 1/32 dB). */
    unsigned short        paGain[MAX_TX_PA_LEVEL_NUM];      /**< PA gain values corresponding to pRf for middle-channel. */

    /* voltage map by chip, TODO */
    unsigned char         dc2dcLevel[MAX_TX_PA_LEVEL_NUM];  /**< PA supply voltage (in unit of 1/10 volt). */

    unsigned short        vBiasDac[MAX_TX_PA_LEVEL_NUM];    /**< Phase-out item, not used now. */
    unsigned short        pa_gain_g12a;                     /**< Phase-out item, not used now. */
    unsigned short        pa_gain_g12b;                     /**< Phase-out item, not used now. */
    unsigned short        ulFrequency[ERF_MAX_FHC_TX_FREQ_NUM_V3];  /**< Sub-band frequency (in unit of 100 kHz). */
    short                 paGainSbWeight[MAX_TX_PA_MODE_NUM][MAX_TEMP_SECTION_NUM][ERF_MAX_FHC_TX_FREQ_NUM_V3]; /**< PA gain sub-band compensation results. */
    short                 couplerLoss[MAX_TX_DET_MODE_NUM]; /**< Coupler loss of middle channel. */
    short                 powerDetector[MAX_TX_DET_MODE_NUM][MAX_TEMP_SECTION_NUM][ERF_MAX_FHC_TX_FREQ_NUM_V3]; /**< Coupler loss sub-band compensation results. */
} ERfTestCmdGetSetTpcSetting_V3;

/**
 * \ingroup LTEStruct
 * \details This structure is used for get tx/rx calibration data request from NVRAM by route
 */
typedef struct
{
   unsigned short                rx_type1_route_num;    /**< Number of rx type-1 route for this getting calibration data command. */
   unsigned short                rx_type2_route_num;    /**< Number of rx type-2 route for this getting calibration data command. */
   unsigned short                tx_type1_route_num;    /**< Number of tx type-1 route for this getting calibration data command. */
   unsigned short                rx_type1_route_index[ERF_MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM_V3]; /**< Rx type-1 route index information for this time calibration data setting command. */
   unsigned short                rx_type2_route_index[ERF_MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM_V3]; /**< Rx type-2 route index information for this time calibration data setting command. */
   ERfTestParamRouteInfo         tx_type1_route_index[ERF_MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM_V3]; /**< Tx type-1 route index information for this time calibration data setting command. */
} ERfTestCmdGetRxTxSettingV3ReqParam_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for get tx/rx calibration data confirm from NVRAM by route
 */
typedef struct
{
    unsigned int                   result;      /**< Result for the setting command transfer to DUT success or not, [0] means fail and [1] means successful. */
    ERfTestGetRxTxSettingStatus  get_status;    /**< Calibration data get from NVRAM process status. */
    ERfTestParamDynamicEntryElm  rx_type1_data; /**< Rx type-1 route information for this get calibration data command. */
    ERfTestParamDynamicEntryElm  rx_type2_data; /**< Rx type-2 route information for this get calibration data command. */
    ERfTestParamDynamicEntryElm  tx_type1_data; /**< Tx type-1 route information for this get calibration data command. */
} ERfTestResultGetRxTxSettingV3CnfParam_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for set tx/rx calibration data confirm from NVRAM by route
 */
typedef struct
{
   unsigned int                 result;                 /**< Result for the setting command transfer to DUT success or not, [0] means fail and [1] means successful. */
   ERfTestSetRxTxSettingStatus  set_status;             /**< Calibration data set to NVRAM process status. */
   unsigned short               rx_type1_result_count;  /**< Number of rx type-1 route for this setting calibration data command. */
   unsigned short               rx_type2_result_count;  /**< Number of rx type-2 route for this setting calibration data command. */
   unsigned short               tx_type1_result_count;  /**< Number of tx type-1 route for this setting calibration data command. */
   ERfTestRSSISetStatus         rx_type1_result[ERF_MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM_V3];   /**< Each rx type-1 route calibration data setting result. */
   ERfTestRSSISetStatus         rx_type2_result[ERF_MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM_V3];   /**< Each rx type-2 route calibration data setting result. */
   ERfTestTPCSetStatus          tx_type1_result[ERF_MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM_V3];   /**< Each tx type-1 route calibration data setting result. */
} ERfTestResultSetRxTxSettingV3CnfParam_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for set tx/rx calibration data request from NVRAM by route
 */
typedef struct
{
   unsigned short  rx_type1_route_num;  /**< Number of rx type-1 route for this setting calibration data command. */
   unsigned short  rx_type2_route_num;  /**< Number of rx type-2 route for this setting calibration data command. */
   unsigned short  tx_type1_route_num;  /**< Number of tx type-1 route for this setting calibration data command. */
   unsigned short  rx_type1_route_index[ERF_MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM_V3];   /**< Rx type-1 route index information for this time calibration data setting command. */
   unsigned short  rx_type2_route_index[ERF_MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM_V3];   /**< Rx type-2 route index information for this time calibration data setting command. */
   unsigned short  tx_type1_route_index[ERF_MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM_V3];   /**< Tx type-1 route index information for this time calibration data setting command. */
   ERfRSSIBandGainTable_Type1_V3 rx_type1[ERF_MAX_RX_TYPE1_CAL_DATA_ACCESS_NUM_V3]; /**< Rx type-1 calibration data information for each route. */
   ERfRSSIBandGainTable_Type2_V3 rx_type2[ERF_MAX_RX_TYPE2_CAL_DATA_ACCESS_NUM_V3]; /**< Rx type-2 calibration data information for each route. */
   ERfTestCmdGetSetTpcSetting_V3 tx_type1[ERF_MAX_TX_TYPE1_CAL_DATA_ACCESS_NUM_V3]; /**< Tx type-1 calibration data information for each route. */
} ERfTestCmdRxTxSettingV3;

/*******************************************************************************
 * ERF_TEST_CMD_START_FHC_V3
 ******************************************************************************/
/**
 * \ingroup LTEStruct
 * \details This structure defines the route information for a given LTE band
 */
typedef struct
{
    unsigned short                    band;         /**< LTE band number (spec. defined) for this route information element. */
    unsigned char                     rx_type1_num; /**< Total number of RX type-1 route for this band. */
    unsigned char                     rx_type2_num; /**< Total number of RX type-2 route for this band. */
    unsigned char                     tx_type1_num; /**< Total number of TX route for this band. */
    unsigned char                     rx_freq_num;  /**< TX sub-band number (sub-band count for different routes should be all the same). */
    unsigned char                     tx_freq_num;  /**< RX sub-band number (sub-band count for different routes should be all the same). */
    unsigned char                     padding;      /**< Memory padding (not used). */
} FHC_V3_Band_Usage_Param_T;

/**
 * \ingroup LTEStruct
 * \details This structure defines the route information for each band within single FHC command
 */
typedef struct
{
    unsigned char                     band_num;                                 /**< Total number of bands for this FHC command. */
    unsigned char                     padding;                                  /**< Memory padding (not used). */
    FHC_V3_Band_Usage_Param_T         band_usage[ERF_MAX_FHC_BAND_CMD_NUM_V3];  /**< Route information for each band. */
} FHC_V3_Band_Info_Param_T;

/**
 * \ingroup LTEStruct
 * \details This structure defines the calibration information for RX type-1 routes to be calibrated
 */
typedef struct
{
    unsigned short                    route_idx;    /**< Acutal RX route index. */
    unsigned short                    band;         /**< LTE band number (spec. defined) for this route information element. */

   /** Antenna enable control (enumeration)\n
    *  1: RXM\n
    *  2: RXD\n
    *  3: RXM + RXD\n
    *
    *  For Gen95 MIMO, it can also be:\n
    *  4: RXM\n
    *  8: RXD\n
    *  12: RXM + RXD
    */
    unsigned short                    ant_mask;

    unsigned short                    dl_freq [ERF_MAX_FHC_RX_FREQ_NUM_V3];     /**< RX sub-band frequency (in unit of 100 kHz). */
    short                             temp_offset[MAX_TEMP_SECTION_NUM];        /**< Temperature compensation value. */
    unsigned char                     rx_cal_step[ERF_TEST_RX_POWER_MODE_NUM];  /**< LNA modes to be calibrated for both HPM and LPM. */
    short                             dl_power[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];    /**< DL power to be used for each LNA mode (in unit of 1/32 dB). */
} FHC_V3_Rx_Type1_Cfg_T;

/**
 * \ingroup LTEStruct
 * \details This structure defines the calibration information for RX type-2 routes to be calibrated
 */
typedef struct
{
    unsigned short                    route_idx;    /**< Acutal RX route index. */
    unsigned short                    band;         /**< LTE band number (spec. defined) for this route information element. */

   /** Antenna mask bitmap\n
    *  1: RXM\n
    *  2: RXD\n
    *  3: RXM + RXD
    */
    unsigned short                    ant_mask;

    unsigned short                    dl_freq [ERF_MAX_FHC_RX_FREQ_NUM_V3]; /**< RX sub-band frequency (in unit of 100 kHz). */
    short                             temp_offset[MAX_TEMP_SECTION_NUM];    /**< Temperature compensation value. */
    unsigned char                     sc_rx_cal_step[ERF_TEST_RX_POWER_MODE_NUM];   /**< LNA modes to be calibrated for both HPM and LPM in NCCA partial-on scenario. */
    short                             sc_dl_power[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3]; /**< DL power to be used for each LNA mode (in unit of 1/32 dB) in NCCA partial-on scenario. */
    unsigned char                     gbg_rx_cal_step[ERF_TEST_RX_POWER_MODE_NUM];  /**< LNA modes to be calibrated for both HPM and LPM in NCCA scenario. */
    short                             gbg_dl_power[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];    /**< DL power to be used for each LNA mode (in unit of 1/32 dB) in NCCA scenario. */
} FHC_V3_Rx_Type2_Cfg_T;

/**
 * \ingroup LTEStruct
 * \details This structure defines the calibration information for TX routes to be calibrated
 */
typedef struct
{
    unsigned short                    route_idx;            /**< Acutal RX route index. */
    unsigned short                    band;                 /**< LTE band number (spec. defined) for this route information element. */

  /** TX path selection (enumeration):\n
   *  0: normal-path + non-CCA setting\n
   *  1: filtered-path + non-CCA setting\n
   *  2: bypass-path + CCA setting\n
   *  3: filtered-path + CCA setting
   */
    unsigned short                    tx_path_sel_bitmap;

    unsigned char                     pwr_step_num_at_freq[ERF_MAX_FHC_TX_FREQ_NUM_V3]; /**< TX step number for each sub-band. */

  /** PA operation mode (enumeration):\n
   *   0: PA be operated in high mode\n
   *   1: PA be operated in middle mode\n
   *   2: PA be operated in low mode
   */
    unsigned char                     pwr_step_pa_mode[MAX_TX_RPT_NUM_V3];

    short                             pwr_step_value[MAX_TX_RPT_NUM_V3];    /**< Target power for each step (in unit of 1/256 dB). */
    short                             pwr_step_pa_gain[MAX_TX_RPT_NUM_V3];  /**< Initial PA gain value (from *.ini file). */
    ERfTestCmdGetSetTpcSetting_V3     tpc_settings; /**< TX initial settings (from *.ini file). */
} FHC_V3_Tx_Type1_Cfg_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used to assign parameters for triggering LTE FHC
 */
typedef struct
{
    unsigned char                   switch_time;                /**< Transition time for "band switch", "route switch", and "sub-band switch", in unit of ms; typical value is 2 ms. */
    unsigned char                   tx_rx_switch_time;          /**< Transition time for "TX sequence switch to RX sequence", in unit of ms; typical value is 3 ms. */
    unsigned short                  rx_dut_measurement_offet;   /**< Time offset (relative to sub-frame boundary) for RSSI measurement, in unit of us. */
    FHC_V3_Band_Info_Param_T        band_info;                  /**< Route information of each band to be calibrated (indexing in by-band manner). */
    FHC_V3_Rx_Type1_Cfg_T           rx_type1_route [ERF_MAX_FHC_RX_TYPE1_CMD_NUM_V3];    /**< Calibration information for RX type-1 routes to be calibrated. */
    FHC_V3_Rx_Type2_Cfg_T           rx_type2_route [ERF_MAX_FHC_RX_TYPE2_CMD_NUM_V3];    /**< Calibration information for RX type-2 routes to be calibrated. */
    FHC_V3_Tx_Type1_Cfg_T           tx_type1_route [ERF_MAX_FHC_TX_TYPE1_CMD_NUM_V3];    /**< Calibration information for TX routes to be calibrated. */
} ERfTestCmd_StartFhcV3_Req_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for reporting detected TX power of each sub-band frequency
 */
typedef struct
{
   short                 txPowerDetectorValue[MAX_TX_RPT_NUM_V3];   /**< Detected TX power. */
} FHC_V3_Tx_Type1_Freq_Rpt_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for reporting detected TX power of TX routes
 */
typedef struct
{
   unsigned short                 route_idx;            /**< Acutal TX route index. */
   unsigned short                 band;                 /**< LTE band number of this route. */

  /** TX path selection (enumeration):\n
   *  0: normal-path + non-CCA setting\n
   *  1: filtered-path + non-CCA setting\n
   *  2: bypass-path + CCA setting\n
   *  3: filtered-path + CCA setting
   */
   unsigned short                 tx_path_sel_bitmap;

   unsigned char                  tx_freq_num;          /**< Sub-band division number, 15 at maximum. */
  FHC_V3_Tx_Type1_Freq_Rpt_T tx_freq_rpt[ERF_MAX_FHC_TX_FREQ_NUM_V3];   /**< TX report for each sub-band. */
} FHC_V3_Tx_Type1_Rpt_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for reporting RX type-2 RSSI measurement results of each antenna path (RXM or RXD)
 */
typedef struct
{
  /** RSSI measurement results of single carrier, which is used in NCCA partial on scenario (PCC on and SCC off, or vise versa)
   */
   short sc[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];

  /** RSSI measurement results of NCCA scenario (PCC on and SCC on). Note that the pathloss in this case would be affected by LNA modes of PCC and SCC at the same time, each combination of PCC and SCC LNA mode should be treated as an unique LNA mode.
   */
   short gbg[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];
} FHC_V3_Rx_Type2_NCCA_Rpt_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for reporting RX type-2 RSSI measurement results of each sub-band frequency
 */
typedef struct
{
   FHC_V3_Rx_Type2_NCCA_Rpt_T   rssi_m; /**< RSSI measurement results of main path. */
   FHC_V3_Rx_Type2_NCCA_Rpt_T   rssi_d; /**< RSSI measurement results of diversity path. */
} FHC_V2_Rx_Type2_Freq_Rpt_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for reporting RSSI measurement results of RX type-2 routes
 */
typedef struct
{
   unsigned short               route_idx;    /**< Acutal RX route index. */
   unsigned short               band;         /**< LTE band number of this route. */
   unsigned char                rx_freq_num;  /**< Sub-band division number, 15 at maximum. */
   FHC_V2_Rx_Type2_Freq_Rpt_T   rx_freq_rpt[ERF_MAX_FHC_RX_FREQ_NUM_V3];  /**< RSSI measurement report for each sub-band. */
} FHC_V3_Rx_Type2_Rpt_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for reporting RX type-1 RSSI measurement results of each sub-band frequency
 */
typedef struct
{
   short rssi_m[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];  /**< RSSI measurement results of main path. */
   short rssi_d[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];  /**< RSSI measurement results of diversity path. */
} FHC_V3_Rx_Type1_Freq_Rpt_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for reporting RSSI measurement results of RX type-1 routes
 */
typedef struct
{
   unsigned short               route_idx;    /**< Acutal RX route index. */
   unsigned short               band;         /**< LTE band number of this route. */
   unsigned char                rx_freq_num;  /**< Sub-band division number, 15 at maximum. */
   FHC_V3_Rx_Type1_Freq_Rpt_T   rx_freq_rpt[ERF_MAX_FHC_RX_FREQ_NUM_V3];  /**< RSSI measurement report for each sub-band. */
} FHC_V3_Rx_Type1_Rpt_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of LTE FHC
 */
typedef struct
{
    unsigned short          rx_type1_route_num;    /**< Total number of RX type-1 routes to be calibrated (supports 12 RX type-1 routes at maximum for single FHC command). */
    unsigned short          rx_type2_route_num;    /**< Total number of RX type-2 routes to be calibrated (supports 6 RX type-2 routes at maximum for single FHC command). */
    unsigned short          tx_type1_route_num;    /**< Total number of TX routes to be calibrated (supports 12 TX routes at maximum for single FHC command). */
    FHC_V3_Rx_Type1_Rpt_T   rx_type1_rpt[ERF_MAX_FHC_RX_TYPE1_REPORT_NUM_V3];  /**< RSSI measurement report of RX type-1 routes. */
    FHC_V3_Rx_Type2_Rpt_T   rx_type2_rpt[ERF_MAX_FHC_RX_TYPE2_REPORT_NUM_V3];  /**< RSSI measurement report of RX type-2 routes. */
    FHC_V3_Tx_Type1_Rpt_T   tx_type1_rpt[ERF_MAX_FHC_TX_TYPE1_REPORT_NUM_V3];  /**< RSSI measurement report of TX routes. */
} ERfTestCmd_StartFhcV3_Cnf_T;

/*******************************************************************************
 * ERF_TEST_CMD_START_RSSI_V3
 ******************************************************************************/

/**
 * \ingroup LTEStruct
 * \details This structure is partial-on input of RSSI command
 */
typedef struct
{
   unsigned char    elna_bypass[ERF_MAX_RX_ANT_NUM_V3];     /**< Specify if each antenna is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
   short            rf_gain[ERF_MAX_RX_ANT_NUM_V3];         /**< RF gain value for each antenna. */
   short            digital_gain[ERF_MAX_RX_ANT_NUM_V3];    /**< Digital gain value for each antenna. */
}ERfStartRssiV3_Sc_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is gain by gain input of RSSI command
 */
typedef struct
{
   unsigned char    elna_bypass[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];   /**< Specify if each antenna and path is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
   short            rf_gain[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];       /**< RF gain value for each antenna and path. */
   short            digital_gain[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];  /**< Digital gain value for each antenna and path. */
}ERfStartRssiV3_Gbg_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is RX input of RSSI command
 */
typedef union
{
   ERfStartRssiV3_Sc_RxInput_T  sc_rxinput;     /**< Partial-on input of RSSI command. */
   ERfStartRssiV3_Gbg_RxInput_T gbg_rxinput;    /**< Gain by gain input of RSSI command. */
}ERfStartRssiV3_RxInput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is the frequency field of RSSI command
 */
typedef union
{
    unsigned short          in_100khz;  /**< Frequency in unit of 100KHz. */
    // for GP tool
    // ERfTestDlFrequency_E    in_enum;
}ERfTestDlFrequency_U;

/**
 * \ingroup LTEStruct
 * \details This structure is used for starting RSSI command
 */
typedef struct
{
   ERfTestRxPowerMode_E     powermode;                          /**< Specify which power mode to use. */
   ERfTestDlFrequency_U     dl_freq[MAX_RX_RFTOOL_FERQ_NUM];    /**< Channel frequency (support up to 5 channel). */
   unsigned char            is_partialon;                       /**< Specify if only need partial on path (0 for No, and 1 for Yes). */
   unsigned char            num_freq;                           /**< Channel number (range: 1 to 5). */
   unsigned char            temperatureIndex;                   /**< Temporature index (range: 0 to 7). */
   unsigned char            partialon_path;                     /**< Partial on path when "is_partialon" is on. */
   unsigned char            ant_sel;                            /**< Antenna mask (1 for main, 2 for diversity, and 3 for both). */
   unsigned short           band;                               /**< LTE band number (spec. defined). */
   unsigned short           routeidx;                           /**< Acutal RX route index. */
   ERfStartRssiV3_RxInput_U rssi_start_input;                   /**< RX input of RSSI command. */
} ERfTestCmd_StartRssiV3_ReqParam_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the partial-on RSSI value measured by RSSI command
 */
typedef struct
{
    short           rssi[MAX_RX_RFTOOL_FERQ_NUM][ERF_MAX_RX_ANT_NUM_V3];    /**< RSSI value measured in each channel and antenna. */
    unsigned char   lna_mode[ERF_MAX_RX_ANT_NUM_V3];                        /**< LNA mode of each antenna. */
}ERfStartRssiV3_Sc_RxOutput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain by gain RX value measured by RSSI command
 */
typedef struct
{
   short            rssi[MAX_RX_RFTOOL_FERQ_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];  /**< RSSI value measured in each channel, path, and antenna. */
   unsigned char    lna_mode[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];                      /**< LNA mode of each antenna and path. */
}ERfStartRssiV3_gbg_RxOutput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX value measured by RSSI command
 */
typedef union
{
    ERfStartRssiV3_Sc_RxOutput_T    sc_rxoutput;    /**< Partial-on RSSI output. */
    ERfStartRssiV3_gbg_RxOutput_T   gbg_rxoutput;   /**< Gain by gain RSSI output. */
}ERfStartRssiV3_RxOutput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of RSSI command
 */
typedef struct
{
   unsigned char                num_freq;                           /**< Channel number (range: 1 to 5). */
   unsigned short               dl_freq[MAX_RX_RFTOOL_FERQ_NUM];    /**< Channel frequency (up to 5 channel). */
   ERfStartRssiV3_RxOutput_U    rssi_start_output;                  /**< Measured RSSI output. */
} ERfTestCmd_StartRssiV3_CnfPdu_T;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartRssiV3_r
 */
META_RESULT __stdcall META_ERf_StartRssiV3(const unsigned int ms_timeout, const ERfTestCmd_StartRssiV3_ReqParam_T* req, ERfTestCmd_StartRssiV3_CnfPdu_T* cnf);
 /**
 * \ingroup LTE
 * \details This API is for starting RSSI measurement.
 *
 * \param [in]  meta_handle         context handle to specific DUT
 * \param [in]  ms_timeout          API transaction timeout value in micro-seconds
 * \param [in]  req                 Request parameter
 * \param [out] cnf                 Confirm message
 *
 * \retval  META_SUCCESS            Successful
 * \retval  META_TIMEOUT            DUT not responding, DUT may be in exception state
 * \retval  META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval  META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_StartRssiV3_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmd_StartRssiV3_ReqParam_T* req, ERfTestCmd_StartRssiV3_CnfPdu_T* cnf);

/*******************************************************************************
 * ERF_TEST_CMD_GET_RX_GAIN_INFO_V3
 ******************************************************************************/

typedef enum
{
    ERF_TEST_GET_RX_Gain_INFO_STATUS_INVALID = 0,
    ERF_TEST_GET_RX_Gain_INFO_STATUS_OK      = 1,  // get success
    ERF_TEST_GET_RX_Gain_INFO_STATUS_ERR     = 2,  // can not search coverage gain for this combination
    ERF_TEST_GET_RX_Gain_INFO_STATUS_MAX,
}ERfTestGetRxGainInfoV3Status;

/**
 * \ingroup LTEStruct
 * \details This structure is the Partial-on input of RX gain information command
 */
typedef struct
{
    unsigned char   elna_bypass[ERF_MAX_RX_ANT_NUM_V3]; /**< Specify if each antenna is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
    unsigned char   lna_mode[ERF_MAX_RX_ANT_NUM_V3];    /**< LNA mode of each antenna. */
}ERfTestGetRxGainInfoV3_Sc_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain by gain input of RX gain information command
 */
typedef struct
{
    unsigned char   elna_bypass[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3];  /**< Specify if each path is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
    unsigned char   lna_mode[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3];     /**< LNA mode of each path. */
}ERfTestGetRxGainInfoV3_Gbg_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX input argument of RX gain information command
 */
typedef union
{
    ERfTestGetRxGainInfoV3_Sc_RxInput_T  sc_rxinput;    /**< Partial-on input of RX gain information command. */
    ERfTestGetRxGainInfoV3_Gbg_RxInput_T gbg_rxinput;   /**< Gain by gain input of RX gain information command. */
}ERfTestGetRxGainInfoV3_RxInput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is the request of RX gain information command
 */
typedef struct
{
    ERfTestRxPowerMode_E                powermode;          /**< Specify which power mode to use. */
    unsigned char                       ant_sel;            /**< Antenna mask (1 for main, 2 for diversity, and 3 for both). */
    unsigned short                      routeidx;           /**< Acutal RX route index. */
    unsigned char                       is_partialon;       /**< Specify if only need partial on path (0 for No, and 1 for Yes). */
    ERfTestGetRxGainInfoV3_RxInput_U    rxgaininfo_input;   /**< RX input argument of RX gain information command. */
}ERfTestCmd_GetRxGainInfoV3_ReqParam_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain information output of partial-on path
 */
typedef struct
{
    short   rf_gain[ERF_MAX_RX_ANT_NUM_V3];         /**< RF gain of each antenna. */
    short   digital_gain[ERF_MAX_RX_ANT_NUM_V3];    /**< Digital gain of each antenna. */
}ERfTestGetRxGainInfoV3_Sc_RxOutput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain information output of gain by gain path
 */
typedef struct
{
    short   rf_gain[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];       /**< RF gain of each antenna and path. */
    short   digital_gain[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];  /**< Digital gain of each antenna and path. */
}ERfTestGetRxGainInfoV3_Gbg_RxOutput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX gain information output of RX gain information command
 */
typedef union
{
    ERfTestGetRxGainInfoV3_Sc_RxOutput_T    sc_rxoutput;    /**< Gain information output of partial-on path. */
    ERfTestGetRxGainInfoV3_Gbg_RxOutput_T   gbg_rxoutput;   /**< Gain information output of gain by gain path. */
}ERfTestGetRxGainInfoV3_RxOutput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of RX gain information command
 */
typedef struct
{
   short                                dl_power;           /**< Advised downlink power. */
   ERfTestGetRxGainInfoV3_RxOutput_U    rxgaininfo_output;  /**< RX gain information output. */
}ERfTestCmd_GetRxGainInfoV3_CnfPdu_T;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetRxGainInfoV3_r
 */
META_RESULT __stdcall META_ERf_GetRxGainInfoV3(const unsigned int ms_timeout, const ERfTestCmd_GetRxGainInfoV3_ReqParam_T* req, ERfTestCmd_GetRxGainInfoV3_CnfPdu_T* cnf);
 /**
 * \ingroup LTE
 * \details Get RX gain information (gain calculator).
 *
 * \param [in]  meta_handle         context handle to specific DUT
 * \param [in]  ms_timeout          API transaction timeout value in micro-seconds
 * \param [in]  req                 Request parameter
 * \param [out] cnf                 Confirm message
 *
 * \retval  META_SUCCESS            Successful
 * \retval  META_TIMEOUT            DUT not responding, DUT may be in exception state
 * \retval  META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval  META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_GetRxGainInfoV3_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmd_GetRxGainInfoV3_ReqParam_T* req, ERfTestCmd_GetRxGainInfoV3_CnfPdu_T* cnf);

/*******************************************************************************
 * ERF_TEST_CMD_START_CONT_RX_V3
 ******************************************************************************/

/**
 * \ingroup LTEStruct
 * \details This structure is the partial-on input of force mode continuous RX command
 */
typedef struct
{
    unsigned char   elna_bypass[ERF_MAX_RX_ANT_NUM_V3]; /**< Specify if each antenna is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
    short           rf_gain[ERF_MAX_RX_ANT_NUM_V3];     /**< RF gain of each antenna. */
}ERfContRxV3_Sc_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain by gain input of force mode continuous RX command
 */
typedef struct
{
    unsigned char    elna_bypass[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];  /**< Specify if each antenna and path is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
    short            rf_gain[ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_ANT_NUM_V3];      /**< RF gain of each antenna and path. */
}ERfContRxV3_Gbg_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX input of force mode continuous RX command
 */
typedef union
{
    ERfContRxV3_Sc_RxInput_T  sc_rxinput;   /**< Partial-on input. */
    ERfContRxV3_Gbg_RxInput_T gbg_rxinput;  /**< Gain by gain input. */
}ERfStartContRxV3_RxInput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is used for force mode continuous RX command
 */
typedef struct
{
    ERfTestRxPowerMode_E        powermode;      /**< Specify which power mode to use. */
    unsigned short              routeidx;       /**< Acutal RX route index. */
    unsigned char               is_partialon;   /**< Specify if only need partial on path (0 for No, and 1 for Yes). */
    unsigned char               partialon_path; /**< Partial on path when "is_partialon" is on. */
    ERfStartContRxV3_RxInput_U  cont_rx_input;  /**< RX input. */
    ERfTestDlFrequency_U        rx_freq;        /**< Downlink frequency. */
    unsigned short              rx_band;        /**< LTE band number (spec. defined). */
    ERfTestBwE                  rx_bw;          /**< Measure bandwidth. */
}ErfContRxRfForcedMode_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for normal mode continuous RX command
 */
typedef struct
{
    ERfTestRxPowerMode_E    powermode;                      /**< Specify which power mode to use. */
    unsigned char           rx_cc_num;                      /**< RX carrier number. */
    ERfTestDlFrequency_U    rx_freq[ERF_MAX_RX_CC_NUM_V3];  /**< Downlink frequency (Support up to 2 carrier). */
    unsigned short          rx_band[ERF_MAX_RX_CC_NUM_V3];  /**< LTE band number (spec. defined) (Support up to 2 carrier). */
    ERfTestBwE              rx_bw[ERF_MAX_RX_CC_NUM_V3];    /**< Measure bandwidth (Support up to 2 carrier). */
}ErfContRxRfNormalMode_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RF arguments of continuous RX command
 */
typedef union
{
    ErfContRxRfForcedMode_T   forcedmode;   /**< Force mode arguments. */
    ErfContRxRfNormalMode_T   normalmode;   /**< Normal mode arguments. */
} ErfContRx_Rf_Param_U;

/**
 * \ingroup LTEStruct
 * \details This structure is used for starting continuous RX command
 */
typedef struct
{
   unsigned char        is_forcedmode;  /**< Specify if measure in force mode (0 for No, and 1 for Yes). */
   ErfContRx_Rf_Param_U contrx_param;   /**< RF arguments. */
} ERfTestCmd_StartContRxV3_ReqParam_T;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartContRxV3_r
 */
META_RESULT __stdcall META_ERf_StartContRxV3(const unsigned int ms_timeout, const ERfTestCmd_StartContRxV3_ReqParam_T* req);
 /**
 * \ingroup LTE
 * \details This API is for starting continuous RX measurement.
 *
 * \param [in]  meta_handle         context handle to specific DUT
 * \param [in]  ms_timeout          API transaction timeout value in micro-seconds
 * \param [in]  req                 Request parameter
 *
 * \retval  META_SUCCESS            Successful
 * \retval  META_TIMEOUT            DUT not responding, DUT may be in exception state
 * \retval  META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval  META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_StartContRxV3_r(const int meta_handle, const unsigned int ms_timeout, const  ERfTestCmd_StartContRxV3_ReqParam_T* req);

/********************* MT6293 Structure Definitions *********************/

/********************* MT6295 Structure Definitions *********************/

/*******************************************************************************
 * ERF_TEST_CMD_QUERY_CA_CONFIG_TABLE_V5
 ******************************************************************************/
#define ERF_TEST_GXM_FLAG_NUM               2
#define ERF_MAX_RX_TYPE2_GBG_PATH_NUM       2
#define LTE_PORT_ASCII_ARRAY_SIZE_V5        16
#define ERF_MAX_MIMO_LAYER_PAIR_V5          2
#define ERF_MAX_BAND_NUM_V5                 25
#define ERF_MAX_TX_CCA_BAND_NUM_V5          ERF_MAX_BAND_NUM_V5
#define ERF_MAX_FHC_RX_FREQ_NUM_V5          15
#define ERF_MAX_FHC_TX_FREQ_NUM_V5          (15)
#define ERF_MAX_RX_T1_T2_ANT_NUM_V5         2
#define ERF_MAX_RX_CC_NUM_V5                4
#define ERF_MAX_TX_CC_NUM_V5                3

#define ERF_MAX_TX_TYPE1_CATEGORY_NUM_V5    (6)
#define ERF_MAX_TX_CATEGORY_NUM_V5          ERF_MAX_TX_TYPE1_CATEGORY_NUM_V5
#define ERF_MAX_RX_TYPE1_CATEGORY_NUM_V5    20
#define ERF_MAX_RX_TYPE2_CATEGORY_NUM_V5    16
#define ERF_MAX_RX_CATEGORY_NUM_V5          ERF_MAX_RX_TYPE1_CATEGORY_NUM_V5 + ERF_MAX_RX_TYPE2_CATEGORY_NUM_V5

#define ERF_MAX_TX_TYPE1_ROUTE_NUM_V5       150
#define ERF_MAX_RX_TYPE1_ROUTE_NUM_V5       450
#define ERF_RX_TYPE2_START_ROUTE_NUM_V5     512
#define ERF_MAX_RX_TYPE2_ROUTE_NUM_V5       350
#define ERF_MAX_TX_ROUTE_NUM_V5             ERF_MAX_TX_TYPE1_ROUTE_NUM_V5
#define ERF_MAX_RX_ROUTE_NUM_V5             ERF_RX_TYPE2_START_ROUTE_NUM_V5 + ERF_MAX_RX_TYPE2_ROUTE_NUM_V5
#define ERF_MAX_RX_MIMO_COMP_ROUTE_PAIRS_V5 5

typedef  enum
{
    ERF_TEST_MIMO_INVALID    = 0,
    ERF_TEST_MIMO_1X         = 1,
    ERF_TEST_MIMO_2X         = 2,  //2X2
    ERF_TEST_MIMO_4X         = 3,  //4X4
    ERF_TEST_MIMO_8X         = 4,
    ERF_TEST_MIMO_LAYERS_NUM,
    ERF_TEST_MIMO_LAYERS_MAX = 0xFF
} ERfTestRxMIMOLayer_E;

/**
 * \ingroup LTEStruct
 * \details TX route information of a band.
 */
typedef struct
{
    unsigned short  band;                               /**< LTE band number (spec. defined). */
    unsigned short  comp_route_idx;                     /**< Route number. */
    unsigned short  FE_route_idx;                       /**< Front end route number. */
    unsigned char   port[LTE_PORT_ASCII_ARRAY_SIZE_V5]; /**< Port name. */
    unsigned char   stx;                                /**< . */
} ERfTestTxType1CaInfoV5_T;

typedef struct
{
    unsigned short          band;           /**< LTE band number (spec. defined). */
    unsigned short          comp_route_idx; /**< Route number. */
    unsigned short          ant_mask;       /**< Antenna mask. */
    unsigned short          FE_route_idx;   /**< Front end route number. */
    unsigned char           port[ERF_MAX_RX_T1_T2_ANT_NUM_V5][LTE_PORT_ASCII_ARRAY_SIZE_V5];/**< Port name. */
    unsigned char           elna_gain[ERF_MAX_RX_T1_T2_ANT_NUM_V5];                         /**< eLNA gain mode. */
    unsigned char           elna_type[ERF_MAX_RX_T1_T2_ANT_NUM_V5];                         /**< eLNA type. */
    unsigned char           gain_table_idx;                                                 /**< eLNA gain table index. */
    unsigned char           srx;                                                            /**< . */
    unsigned char           mimo_type;                                                      /**< MIMO type. */ // ERfTestRxMIMOLayer_E
    unsigned char           mimo_pair_route_num;                                            /**< MIMO pair route number. */
    unsigned short          mimo_comp_route_pair[ERF_MAX_RX_MIMO_COMP_ROUTE_PAIRS_V5];      /**< MIMO pair routes. */
} ERfTestRxType1CaInfoV5_T;

/**
 * \ingroup LTEStruct
 * \details RX type 2 route information of a band.
 */
typedef struct
{
    unsigned short          band;           /**< LTE band number (spec. defined). */
    unsigned short          comp_route_idx; /**< Route number. */
    unsigned short          ant_mask;       /**< Antenna mask. */
    unsigned char           FE_route_idx;   /**< Front end route number. */
    unsigned char           port[ERF_MAX_RX_T1_T2_ANT_NUM_V5][LTE_PORT_ASCII_ARRAY_SIZE_V5];/**< Port name. */
    unsigned char           elna_gain[ERF_MAX_RX_T1_T2_ANT_NUM_V5];                         /**< eLNA gain mode. */
    unsigned char           elna_type[ERF_MAX_RX_T1_T2_ANT_NUM_V5];                         /**< eLNA type. */
    unsigned char           gain_table_idx [ERF_MAX_RX_T1_T2_ANT_NUM_V5];                   /**< eLNA gain table index. */
    unsigned char           srx[ERF_MAX_RX_TYPE2_GBG_PATH_NUM];                             /**< . */
    unsigned char           mimo_type[ERF_MAX_RX_TYPE2_GBG_PATH_NUM];                       /**< MIMO type. */ // ERfTestRxMIMOLayer_E
    unsigned char           mimo_pair_route_num;                                            /**< MIMO pair route number. */
    unsigned short          mimo_comp_route_pair[ERF_MAX_RX_MIMO_COMP_ROUTE_PAIRS_V5];      /**< MIMO pair routes. */
} ERfTestRxType2CaInfoV5_T;

/**
 * \ingroup LTEStruct
 * \details TX RX route information.
 */
typedef struct
{
    ERfTestTxType1CaInfoV5_T    tx_type1_ca_info[ERF_MAX_TX_TYPE1_ROUTE_NUM_V5];    /**< TX route information. */
    ERfTestRxType1CaInfoV5_T    rx_type1_ca_info[ERF_MAX_RX_TYPE1_ROUTE_NUM_V5];    /**< RX type 1 route information. */
    ERfTestRxType2CaInfoV5_T    rx_type2_ca_info[ERF_MAX_RX_TYPE2_ROUTE_NUM_V5];    /**< RX type 2 route information. */
} ERfTestTRxCaInfoV5_T;

typedef enum
{
    ERF_TEST_ELNA_OFF_V5                        = 0,
    ERF_TEST_ELNA_BYPASS_LOW_TX_ISO             = 1,
    ERF_TEST_ELNA_BYPASS_HIGH_TX_ISO            = 2,
    ERF_TEST_ELNA_ALWAYS_ON_LOW_TX_ISO          = 3,
    ERF_TEST_ELNA_ALWAYS_ON_HIGH_TX_ISO            = 4,
    ERF_TEST_ELNA_BYPASS_LOW_TX_ISO_R_MATCHING  = 5,
    ERF_TEST_ELNA_TYPE_NUM_V5,
    ERF_TEST_ELNA_MAX_V5                        = 0xFF
} ERfTestRxELNAType_V5_E;

typedef enum
{
    ELNA_GAIN_18_DB         = 0,
    ELNA_GAIN_13_DB         = 1,        
    ELNA_GAIN_MAX_V5        = 0xFF
} ERfTestRxELNAGain_V5_E;

/**
 * \ingroup LTEStruct
 * \details Band information and calibration capability
 */
typedef struct
{
    unsigned short band;        /**< LTE band number (spec. defined). */
    unsigned short cal_item;    /**< Calibration item mask supported by band. */
} ERfTestBandCalItemV5_T;

/**
 * \ingroup LTEStruct
 * \details TX CCA route information of a band.
 */
typedef struct
{
   unsigned char   total_route_num;                                 /**< Total number of TX CCA routes in this band. */
   unsigned char   padding[3];                                      /**< Memory padding (not used). */
   unsigned short  band;                                            /**< LTE band number (spec. defined). */
   unsigned short  route_idx[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V5];     /**< Route number. */ //take considerate FE route + RFIC routee considerate FE route + RFIC route
} ERfTestTxCCARouteInfoV5_T;

/**
 * \ingroup LTEStruct
 * \details TX CCA route information.
 */
typedef struct
{
   unsigned char                total_band_num;                                 /**< Total number of bands. */
   ERfTestTxCCARouteInfoV5_T    tx_cca_route_info[ERF_MAX_TX_CCA_BAND_NUM_V5];  /**< TX CCA route information of each band. */
} ERfTestTxCCAInfoV5_T;

/**
 * \ingroup LTEStruct
 * \details RX type 1 eLNA information.
 */
typedef struct
{
   unsigned char   elna_gain [ERF_MAX_RX_T1_T2_ANT_NUM_V5];                                                             /**< eLNA gain mode. */
   unsigned char   elna_type [ERF_MAX_RX_T1_T2_ANT_NUM_V5];                                                             /**< eLNA type. */
   unsigned char   gain_table_idx;                                                                                      /**< eLNA gain table index. */
   unsigned char   seq_num[ERF_TEST_RX_POWER_MODE_NUM];                                                                 /**< Number of point that need to be calibrated. */
   short           dlpow_default[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                              /**< Suggested downlink power. */ // resolution 1/32
   short           dlpow_lbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                               /**< Lower bound of downlink power. */ // resolution 1/32
   short           dlpow_hbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                               /**< Higer bound of downlink power. */ // resolution 1/32
   unsigned char   dlpow_lna_mode[ERF_MAX_RX_ANT_NUM_V3][ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];      /**< Corresponding LNA mode. */
   unsigned char   dlpow_elna_bypass[ERF_MAX_RX_ANT_NUM_V3][ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];   /**< Is in bypass gain mode. */ //1:bypass(elna off)
   unsigned char   nvram_idx[ERF_MAX_RX_ANT_NUM_V3][ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];           /**< Corresponding NVRAM index to store calibrated data. */
} ERfTestElnaInfoT1V5_T;

/**
 * \ingroup LTEStruct
 * \details RX type 2 eLNA information.
 */
typedef struct
{
   unsigned char   elna_gain;                                                                                                       /**< eLNA gain mode. */
   unsigned char   elna_type;                                                                                                       /**< eLNA type. */
   unsigned char   gain_table_idx;                                                                                                  /**< eLNA gain table index. */
   unsigned char   gbg_seq_num[ERF_TEST_RX_POWER_MODE_NUM];                                                                         /**< Number of gain by gain point that need to be calibrated. */
   short           gbg_dlpow_default[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];                                      /**< Suggested downlink power. */ // resolution 1/32
   short           gbg_dlpow_lbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];                                       /**< Lower bound of downlink power. */ // resolution 1/32
   short           gbg_dlpow_hbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];                                       /**< Higer bound of downlink power. */ // resolution 1/32
   unsigned char   gbg_dlpow_lna_mode[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];   /**< Corresponding LNA mode. */
   unsigned char   gbg_dlpow_elna_bypass[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];/**< Is in bypass gain mode. */ //1:bypass(elna off)
   unsigned char   gbg_nvram_idx[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE2_GBG_PATH_NUM_V3][ERF_MAX_RX_TYPE2_SEQ_NUM_V3];        /**< Corresponding NVRAM index to store gain by gain calibrated data. */
   unsigned char   sc_seq_num[ERF_TEST_RX_POWER_MODE_NUM];                                                                          /**< Number of partial-on point that need to be calibrated. */
   short           sc_dlpow_default[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                       /**< Suggested downlink power. */ // resolution 1/32
   short           sc_dlpow_lbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                        /**< Lower bound of downlink power. */ // resolution 1/32
   short           sc_dlpow_hbound[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                        /**< Higer bound of downlink power. */ // resolution 1/32
   unsigned char   sc_dlpow_lna_mode[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                      /**< Corresponding LNA mode. */
   unsigned char   sc_dlpow_elna_bypass[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                   /**< Is in bypass gain mode. */ //1:bypass(elna off)
   unsigned char   sc_nvram_idx[ERF_TEST_RX_POWER_MODE_NUM][ERF_MAX_RX_TYPE1_SEQ_NUM_V3];                                           /**< Corresponding NVRAM index to store partial-on calibrated data. */
} ERfTestElnaInfoT2V5_T;

#define ERF_MAX_RX_TYPE1_COMBINATION_NUM_V5 36
#define ERF_MAX_RX_TYPE2_COMBINATION_NUM_V5 6

/**
 * \ingroup LTEStruct
 * \details RX eLNA information.
 */
typedef struct
{
    ERfTestElnaInfoT1V5_T elna_info_t1 [ERF_MAX_RX_TYPE1_COMBINATION_NUM_V5];
    ERfTestElnaInfoT2V5_T elna_info_t2 [ERF_MAX_RX_TYPE2_COMBINATION_NUM_V5];
} ERfTestElnaCalInfoV5_T;

/**
 * \ingroup LTEStruct
 * \details CA configuration information of M50 series.
 */
typedef struct
{
    ERfTestBandCalItemV5_T  band_cal_item_info [ERF_MAX_BAND_NUM_V5];   /**< LTE band information. */
    ERfTestTRxCaInfoV5_T    trx_ca_info;                                /**< TX RX route information. */
    ERfTestTxCCAInfoV5_T    tx_cca_info;                                /**< TX CCA route information. */
    ERfTestElnaCalInfoV5_T  elna_cal_info;                              /**< RX eLNA information. */ // Should be filled from dynamic part
} ERfTestCmdCaConfig_V5;

/**
 * \ingroup     LTE
 * \sa non-reentrant version of META_ERf_QueryCaConfigTableV5_r
 */
META_RESULT  __stdcall META_ERf_QueryCaConfigTableV5( const unsigned int ms_timeout, ERfTestCmdCaConfig_V5* resp);
/**
 * \details     Get CA config table from target
 * \ingroup     LTE
 * \sa ERF_TEST_CMD_QUERY_CA_CONFIG_TABLE_V5
 * 
 * \param       meta_handle     meta handle
 * \param       ms_timeout      time out in ms
 * \param[out]  resp            CA config table
 *              
 * \retval      META_SUCCESS    Successful
 * \retval      META_TIMEOUT    DUT not responding, DUT maybe in exception state
 **/
META_RESULT  __stdcall META_ERf_QueryCaConfigTableV5_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdCaConfig_V5* resp);

/*******************************************************************************
 * ERF_TEST_CMD_GET_RX_GAIN_INFO_V5
 ******************************************************************************/

/**
 * \ingroup LTEStruct
 * \details This structure is the Partial-on input of RX gain information command
 */
typedef struct
{
   unsigned char elna_bypass[ERF_MAX_RX_T1_T2_ANT_NUM_V5];  /**< Specify if each antenna is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
   unsigned char lna_mode[ERF_MAX_RX_T1_T2_ANT_NUM_V5];     /**< LNA mode of each antenna. */
} ERfTestGetRxGainInfoV5_Sc_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain by gain input of RX gain information command
 */
typedef struct
{
   unsigned char elna_bypass[ERF_MAX_RX_TYPE2_GBG_PATH_NUM];    /**< Specify if each path is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
   unsigned char lna_mode[ERF_MAX_RX_TYPE2_GBG_PATH_NUM];       /**< LNA mode of each path. */
} ERfTestGetRxGainInfoV5_Gbg_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX input argument of RX gain information command
 */
typedef union
{
   ERfTestGetRxGainInfoV5_Sc_RxInput_T  sc_rxinput;     /**< Partial-on input of RX gain information command. */
   ERfTestGetRxGainInfoV5_Gbg_RxInput_T gbg_rxinput;    /**< Gain by gain input of RX gain information command. */
} ERfTestGetRxGainInfoV5_RxInput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is the request of RX gain information command
 */
typedef struct
{
    ERfTestRxPowerMode_E                powermode;                                  /**< Specify which power mode to use. */
    unsigned char                       is_partialon;                               /**< Specify if only need partial on path (0 for No, and 1 for Yes). */
    unsigned char                       elna_type [ERF_MAX_RX_T1_T2_ANT_NUM_V5];    /**< eLNA type of each antenna. */
    unsigned short                      routeidx;                                   /**< Acutal RX route index. */
    ERfTestGetRxGainInfoV5_RxInput_U    rxgaininfo_input;                           /**< RX input argument of RX gain information command. */
} ERfTestCmd_GetRxGainInfoV5_ReqParam;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain information output of partial-on path
 */
typedef struct
{
    short rf_gain [ERF_MAX_RX_T1_T2_ANT_NUM_V5];        /**< RF gain of each antenna. */
    short digital_gain [ERF_MAX_RX_T1_T2_ANT_NUM_V5];   /**< Digital gain of each antenna. */
} ERfTestGetRxGainInfoV5_Sc_RxOutput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain information output of gain by gain path
 */
typedef struct
{
    short rf_gain  [ERF_MAX_RX_TYPE2_GBG_PATH_NUM] [ERF_MAX_RX_T1_T2_ANT_NUM_V5];       /**< RF gain of each antenna and path. */
    short digital_gain [ERF_MAX_RX_TYPE2_GBG_PATH_NUM] [ERF_MAX_RX_T1_T2_ANT_NUM_V5];   /**< Digital gain of each antenna and path. */
} ERfTestGetRxGainInfoV5_Gbg_RxOutput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX gain information output of RX gain information command
 */
typedef struct
{
    ERfTestGetRxGainInfoV5_Sc_RxOutput_T    sc_rxoutput;    /**< Gain information output of partial-on path. */
    ERfTestGetRxGainInfoV5_Gbg_RxOutput_T   gbg_rxoutput;   /**< Gain information output of gain by gain path. */
} ERfTestGetRxGainInfoV5_RxOutput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of RX gain information command
 */
typedef struct
{
   short                                dl_power;           /**< Advised downlink power. */
   ERfTestGetRxGainInfoV5_RxOutput_U    rxgaininfo_output;  /**< RX gain information output. */
} ERfTestCmd_GetRxGainInfoV5_CnfPdu;

/**
 * \ingroup     LTE
 * \sa non-reentrant version of META_ERf_GetRxGainInfoV5_r
 */
META_RESULT __stdcall META_ERf_GetRxGainInfoV5(const unsigned int ms_timeout, const ERfTestCmd_GetRxGainInfoV5_ReqParam* req, ERfTestCmd_GetRxGainInfoV5_CnfPdu* cnf);
/**
 * \details     Get RX gain information (gain calculator)
 * \ingroup     LTE
 * \sa          ERF_TEST_CMD_GET_RX_GAIN_INFO_V5
 *
 * \param       meta_handle             meta handle
 * \param       ms_timeout              time out in ms
 * \param       req                     request parameter
 * \param[out]  cnf                     gain information result
 *              
 * \retval      META_SUCCESS            Successful
 * \retval      META_TIMEOUT            DUT not responding, DUT maybe in exception state
 * \retval      META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval      META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_GetRxGainInfoV5_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmd_GetRxGainInfoV5_ReqParam* req, ERfTestCmd_GetRxGainInfoV5_CnfPdu* cnf);

/*******************************************************************************
 * ERF_TEST_CMD_GET_TXRX_ROUTE_INFO_V5
 ******************************************************************************/
typedef enum
{
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_VALID                             = 0,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_INVALID_RX_TX_MISMATCH            = 1,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_EQUAL_FREQUENCIES                 = 2,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_CH_BW_OVERLAP                     = 3,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_RX_CC_LIST_NOT_IN_USAGE_TBL       = 4,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_TX_CC_LIST_NOT_IN_USAGE_TBL       = 5,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_REGION_MISMATCH_WITH_SPUR_BANDS   = 6,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_RX_USAGE_CHANGED_IN_SPUR_CANCEL   = 7,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_TX_USAGE_CHANGED_IN_SPUR_CANCEL   = 8,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_MANY_REGIONS_WITH_SAME_SRX        = 9,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_RX_ROUTE_TBL_CC_LIST_NOT_ALIGN    = 10,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_TX_ROUTE_TBL_CC_LIST_NOT_ALIGN    = 11,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_TX_CC_FREQ_TOO_CLOSE              = 12,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_TX_CC_FREQ_TOO_FAR                = 13,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_NO_PCC_TX_BAND                    = 14,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_RX_MIMO_MISMATCH                  = 15,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_NUM,
   ERF_TEST_GET_TXRX_ROUTE_INFO_V5_STATUS_NUM_MAX                           = 0xFF
}ERfTestGetTxRxRouteInfoV5Status;

/**
 * \ingroup LTEStruct
 * \details This structure is the request of route information command and start continuous RX command
 */
typedef struct
{
   unsigned char   rx_cc_num;                                   /**< RX carrier number. */
   unsigned short  rx_freq [ERF_MAX_RX_CC_NUM_V5];              /**< DL frequency for each RX carrier. */
   unsigned short  rx_band [ERF_MAX_RX_CC_NUM_V5];              /**< LTE band for each RX carrier. */
   ERfTestBwE  rx_bw [ERF_MAX_RX_CC_NUM_V5];                    /**< DL bandwidth for each RX carrier. */
   ERfTestRxMIMOLayer_E   rx_mimo_layer [ERF_MAX_RX_CC_NUM_V5]; /**< MIMO type for each RX carrier. */
   unsigned char   tx_cc_num;                                   /**< TX carrier number. */
   unsigned short  tx_freq [ERF_MAX_TX_CC_NUM_V5];              /**< UL frequency for each TX carrier. */
   unsigned short  tx_band [ERF_MAX_TX_CC_NUM_V5];              /**< LTE band for each TX carrier. */
   ERfTestBwE  tx_bw [ERF_MAX_TX_CC_NUM_V5];                    /**< UL bandwidth for each TX carrier. */
} ERfTestCmd_GetTxRxRouteInfoV5_ReqParam;

/**
 * \ingroup LTEStruct
 * \details This structure is the TX route information of a TX route
 */
typedef struct
{
   unsigned short  comp_route_idx;                      /**< Acutal TX route index. */
   unsigned short  FE_route_idx;                        /**< TX front-end route index. */
   unsigned char   port [LTE_PORT_ASCII_ARRAY_SIZE_V5]; /**< Port number for this route. */
   unsigned char   stx;                                 /**< STX number for this route. */
}ERfTestTxRouteInfoV5;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX route information of a RX route
 */
typedef struct
{
   unsigned short  comp_route_idx;                                                      /**< Acutal RX route index. */
   unsigned short  FE_route_idx;                                                        /**< RX front-end route index. */
   unsigned char   port [ERF_MAX_RX_T1_T2_ANT_NUM_V5][LTE_PORT_ASCII_ARRAY_SIZE_V5];    /**< Port number for each antenna. */
   unsigned char   elna [ERF_MAX_RX_T1_T2_ANT_NUM_V5];                                  /**< eLNA type for each antenna. */
   unsigned char   srx;                                                                 /**< SRX number for this route. */
}ERfTestRxRouteInfoV5;

/**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of route information command
 * \sa      ERfTestGetTxRxRouteInfoV5Status
 */
typedef struct
{
   unsigned char   get_status;                                                                  /**< Return status of get request, please see ERfTestGetTxRxRouteInfoV5Status. */
   ERfTestTxRouteInfoV5   tx_route_info [ERF_MAX_TX_CC_NUM_V5];                                 /**< TX route information for each carrier. */
   ERfTestRxRouteInfoV5   rx_route_info [ERF_MAX_RX_CC_NUM_V5] [ERF_MAX_MIMO_LAYER_PAIR_V5];    /**< TX route information for each carrier and MIMO type. */
}ERfTestCmd_GetTxRxRouteInfoV5_CnfPdu;

/**
 * \ingroup     LTE
 * \sa non-reentrant version of META_ERf_GetTxRxRouteInfoV5_r
 */
META_RESULT __stdcall META_ERf_GetTxRxRouteInfoV5(const unsigned int ms_timeout, const ERfTestCmd_GetTxRxRouteInfoV5_ReqParam* req, ERfTestCmd_GetTxRxRouteInfoV5_CnfPdu* cnf);
/**
 * \details     Get route information (route calculator)
 * \ingroup     LTE
 * \sa          ERF_TEST_CMD_GET_TXRX_ROUTE_INFO_V5
 *
 * \param       meta_handle             meta handle
 * \param       ms_timeout              time out in ms
 * \param       req                     request parameter
 * \param[out]  cnf                     route information result
 *              
 * \retval      META_SUCCESS            Successful
 * \retval      META_TIMEOUT            DUT not responding, DUT maybe in exception state
 * \retval      META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval      META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_GetTxRxRouteInfoV5_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmd_GetTxRxRouteInfoV5_ReqParam* req, ERfTestCmd_GetTxRxRouteInfoV5_CnfPdu* cnf);

/*******************************************************************************
 * ERF_TEST_CMD_START_CONT_RX_V5
 ******************************************************************************/

/**
 * \ingroup LTEStruct
 * \details This structure is the partial-on input of force mode continuous RX command
 */
typedef struct
{
   unsigned char   elna_bypass [ERF_MAX_RX_T1_T2_ANT_NUM_V5];   /**< Specify if each antenna is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
   short   rf_gain [ERF_MAX_RX_T1_T2_ANT_NUM_V5];               /**< RF gain of each antenna. */
} ERfContRxV5_Sc_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the gain by gain input of force mode continuous RX command
 */
typedef struct
{
   unsigned char   elna_bypass [ERF_MAX_RX_TYPE2_GBG_PATH_NUM][ERF_MAX_RX_T1_T2_ANT_NUM_V5];    /**< Specify if each antenna and path is in eLNA bypass mode (0 stands for No and 1 stands for Yes). */
   short   rf_gain [ERF_MAX_RX_TYPE2_GBG_PATH_NUM][ERF_MAX_RX_T1_T2_ANT_NUM_V5];                /**< RF gain of each antenna and path. */
}ERfContRxV5_Gbg_RxInput_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RX input of force mode continuous RX command
 */
typedef union
{
   ERfContRxV5_Sc_RxInput_T     sc_rxinput;     /**< Partial-on input. */
   ERfContRxV5_Gbg_RxInput_T    gbg_rxinput;    /**< Gain by gain input. */
}ERfStartContRxV5_RxInput_U;

/**
 * \ingroup LTEStruct
 * \details This structure is used for force mode continuous RX command
 */
typedef struct
{
    ERfTestRxPowerMode_E        rx_powermode;   /**< Specify which power mode to use. */
    unsigned short              routeidx;       /**< Acutal RX route index. */
    unsigned char               is_partialon;   /**< Specify if only need partial on path (0 for No, and 1 for Yes). */
    unsigned char               partialon_path; /**< Partial on path when "is_partialon" is on. */
    ERfStartContRxV5_RxInput_U  cont_rx_input;  /**< RX input. */
    ERfTestDlFrequency_U        rx_freq;        /**< Downlink frequency. */
    unsigned short              rx_band;        /**< LTE band number (spec. defined). */
    ERfTestBwE                  rx_bw;          /**< Measure bandwidth. */
} ErfContRxV5RfForcedMode_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for normal mode continuous RX command
 */
typedef struct
{
   ERfTestRxPowerMode_E                     rx_powermode;   /**< Specify which power mode to use. */
   ERfTestCmd_GetTxRxRouteInfoV5_ReqParam   cont_rx_param;  /**< TX and RX settings. */
} ErfContRxV5RfNormalMode_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the RF arguments of continuous RX command
 */
typedef union
{
  ErfContRxV5RfForcedMode_T  forcedmode;    /**< Force mode arguments. */
  ErfContRxV5RfNormalMode_T  normalmode;    /**< Normal mode arguments. */
} ErfContRxV5_Rf_Param_T;

/**
 * \ingroup LTEStruct
 * \details This structure is used for starting continuous RX command
 */
typedef struct
{
   unsigned char            is_forcedmode;  /**< Specify if measure in force mode (0 for No, and 1 for Yes). */
   ErfContRxV5_Rf_Param_T   contrx_param;   /**< RF arguments. */
} ERfTestCmd_StartContRxV5_ReqParam;

/**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of continuous RX command
 * \sa      ERfTestGetTxRxRouteInfoV5Status
 */
typedef struct
{
   unsigned char   get_status;  /**< Return status of start request, please see ERfTestGetTxRxRouteInfoV5Status. */
} ERfTestCmd_StartContRxV5_Cnf;

/**
 * \ingroup     LTE
 * \sa non-reentrant version of META_ERf_StartContRxV5_r
 */
META_RESULT __stdcall META_ERf_StartContRxV5(const unsigned int ms_timeout, const ERfTestCmd_StartContRxV5_ReqParam* req, ERfTestCmd_StartContRxV5_Cnf* cnf);
/**
 * \details     Continuous RX test function
 * \ingroup     LTE
 * \sa          ERF_TEST_CMD_START_CONT_RX_V5
 *
 * \param       meta_handle             meta handle
 * \param       ms_timeout              time out in ms
 * \param       req                     request parameter
 * \param[out]  cnf                     operation result
 *              
 * \retval      META_SUCCESS            Successful
 * \retval      META_TIMEOUT            DUT not responding, DUT maybe in exception state
 * \retval      META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval      META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_StartContRxV5_r(const int meta_handle, const unsigned int ms_timeout, const  ERfTestCmd_StartContRxV5_ReqParam* req, ERfTestCmd_StartContRxV5_Cnf* cnf);

/*******************************************************************************
 * ERF_TEST_CMD_START_MIX_RX_CA_V5
 ******************************************************************************/

/**
 * \ingroup LTEStruct
 * \details This structure is the RX parameters for RSRP/RSRQ RX command
 */
typedef struct
{
    /* Common params */
    unsigned char   measCnt;        /**< Measure number, support up to 10. */
    unsigned short  dlFrequency;    /**< DL frequency (100KHz unit). */
    unsigned char   band;           /**< LTE band number (spec. defined). */
    unsigned char   duplexMode;     /**< Duplex mode - 0:tdd, 1:fdd */
    unsigned char   tddConfig;      /**< . */ // range 0~7
    unsigned char   tddSfConfig;    /**< . */ // range 0~8
    unsigned char   dlBandwidth;    /**< DL bandwidth, 0:6RB, 1:15RB, 2:25RB, 3:50RB, 4:75RB, 5:100RB. */

    /* Pseudo TRX only */
    unsigned short  ulFrequency;    /**< UL frequency (100KHz unit). */
    short           txPowerValue;   /**< TX power, with format S(8,8). */
    unsigned char   vrbStart;       /**< . */
    unsigned char   vrbLength;      /**< . */
    unsigned char   mcsMode;        /**< MCS mode, 0: QPSK, 1: 16QAM, 2: 64QAM, 3: 256QAM. */
} Mix_Rx_Dl_Ul_Ca_Normal_Mode_ParamV5;

/**
 * \ingroup LTEStruct
 * \details This structure is the normal mode parameters for RSRP/RSRQ RX command
 */
typedef struct
{
    unsigned char                       mode;                               /**< Operation mode, 0:DL_RX, 1:PSEUDO_TRX. */
    unsigned char                       rxLayer;                            /**< MIMO type, 0: 2X2, 1: 4X4. */
    Mix_Rx_Dl_Ul_Ca_Normal_Mode_ParamV5 mix_rx_dl_ul_ca_normal_mode_param;  /**< RX parameters. */
} Mix_Rx_Dl_Ul_Ca_Normal_Mode_V5;

/**
 * \ingroup LTEStruct
 * \details This structure is the force mode parameters for RSRP/RSRQ RX command
 */
typedef struct
{
    unsigned char   mode;           /**< Operation mode, 0:DL_RX, 1:PSEUDO_TRX. */
    unsigned char   measCnt;        /**< Measure number, support up to 10. */
    unsigned short  dlFrequency;    /**< DL frequency (100KHz unit). */
    unsigned char   band;           /**< LTE band number (spec. defined). */
    unsigned char   duplexMode;     /**< Duplex mode - 0:tdd, 1:fdd */
    unsigned char   tddConfig;      /**< . */ // range 0~7 
    unsigned char   tddSfConfig;    /**< . */ // range 0~8
    unsigned char   dlBandwidth;    /**< DL bandwidth, 0:6RB, 1:15RB, 2:25RB, 3:50RB, 4:75RB, 5:100RB. */
    unsigned short  rxRoute;        /**< RX route number. */
    unsigned char   lpmHpmConfig;   /**< Power mode configuration, 0:auto 1:hpm 2:lpmdata 3:lpmlowmcs 4:lpmhighmcs. */

    /* Pseudo Tx-Rx only */
    unsigned short  ulFrequency;    /**< UL frequency (100KHz unit). */
    short           txPowerValue;   /**< TX power, with format S(8,8). */
    unsigned char   vrbStart;       /**< . */
    unsigned char   vrbLength;      /**< . */
    unsigned char   mcsMode;        /**< MCS mode, 0: QPSK, 1: 16QAM, 2: 64QAM, 3: 256QAM. */
    unsigned short  txRoute;        /**< TX route number, not used in M50 series. */
} Mix_Rx_Tx_Force_Mode_V5;

/**
 * \ingroup LTEStruct
 * \details This structure is RF parameters of RSRP/RSRQ RX command
 */
typedef union
{
    Mix_Rx_Dl_Ul_Ca_Normal_Mode_V5  mix_rx_dl_ul_ca_normal_mode;    /**< Normal mode parameters. */
    Mix_Rx_Tx_Force_Mode_V5         mix_rx_tx_force_mode;           /**< Force mode parameters. */
} Mix_Rx_Dl_Ul_Ca_Mode_V5;

/**
 * \ingroup LTEStruct
 * \details This structure is the request parameters of RSRP/RSRQ RX command
 */
typedef struct
{
    unsigned char           opMode;     /**< Operation mode, 0:normal mode 1:force mode. */
    Mix_Rx_Dl_Ul_Ca_Mode_V5 reqParam;   /**< RF parameters. */
} ERFTestCmd_StartMixRxCaV5_ReqParam;

/**
 * \ingroup     LTE
 * \sa non-reentrant version of META_ERf_StartMixRx_CaMode_V5_r
 */
META_RESULT __stdcall META_ERf_StartMixRx_CaMode_V5( const unsigned int ms_timeout, const ERFTestCmd_StartMixRxCaV5_ReqParam* req );
/**
 * \details     RSRP/RSRQ RX test function
 * \ingroup     LTE
 * \sa          ERF_TEST_CMD_START_MIX_RX_CA_V5
 *
 * \param       meta_handle             meta handle
 * \param       ms_timeout              time out in ms
 * \param       req                     request parameter
 *                              
 * \retval      META_SUCCESS            Successful
 * \retval      META_TIMEOUT            DUT not responding, DUT maybe in exception state
 * \retval      META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval      META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_StartMixRx_CaMode_V5_r( const int meta_handle, const unsigned int ms_timeout, const ERFTestCmd_StartMixRxCaV5_ReqParam* req);

/*******************************************************************************
 * ERF_TEST_CMD_GET_MIX_RX_CA_RPT_V5
 ******************************************************************************/

 /**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of RSRP/RSRQ RX command
 */
typedef struct
{
    unsigned char measRptCnt;   /**< Measure number, support up to 10. */
    short rssiPath0[10];        /** The RSSI measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rssiPath1[10];        /** The RSSI measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rssiPath2[10];        /** The RSSI measurement results in RX path 2. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rssiPath3[10];        /** The RSSI measurement results in RX path 3. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrpPath0[10];        /** The RSRP measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrpPath1[10];        /** The RSRP measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrpPath2[10];        /** The RSRP measurement results in RX path 2. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrpPath3[10];        /** The RSRP measurement results in RX path 3. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrqPath0[10];        /** The RSRQ measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrqPath1[10];        /** The RSRQ measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrqPath2[10];        /** The RSRQ measurement results in RX path 2. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */
    short rsrqPath3[10];        /** The RSRQ measurement results in RX path 3. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal. */

    unsigned int crcOK_cnt;     /** The number of successful PDSCH decoding.*/
    unsigned int crcNG_cnt;     /** The number of fail PDSCH decoding.*/
} ERfTestResultGetMixRxRpt_CaMode_V5;

/**
 * \ingroup     LTE
 * \sa non-reentrant version of META_ERf_GetMixRxReport_CaMode_V5_r
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode_V5( const unsigned int ms_timeout, ERfTestResultGetMixRxRpt_CaMode_V5* resp );
/**
 * \details     Get report for RSRP/RSRQ RX
 * \ingroup     LTE
 * \sa          ERF_TEST_CMD_GET_MIX_RX_CA_RPT_V5
 *
 * \param       meta_handle             meta handle
 * \param       ms_timeout              time out in ms
 * \param[out]  resp                    result report
 *              
 * \retval      META_SUCCESS            Successful
 * \retval      META_TIMEOUT            DUT not responding, DUT maybe in exception state
 * \retval      META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval      META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode_V5_r( const int meta_handle, const unsigned int ms_timeout, ERfTestResultGetMixRxRpt_CaMode_V5* resp );

/*******************************************************************************
 * ERF_TEST_CMD_START_PUSCH_TX_CA_V5
 ******************************************************************************/

 /**
 * \ingroup LTEStruct
 * \details This structure is the TX parameters of PUSCH TX command
 */
typedef struct
{
    unsigned char   band;               /**< LTE band number (spec. defined). */
    unsigned char   duplexMode;         /**< Duplex mode - 0:tdd, 1:fdd */
    unsigned char   tddConfig;          /**< . */ // range 0~7 
    unsigned char   tddSfConfig;        /**< . */ // range 0~8
    unsigned short  ulFrequency;        /**< UL frequency (100KHz unit). */
    unsigned short  cellId;             /**< Cell ID. */
    unsigned char   ulBandwidth;        /**< DL bandwidth, 0:6RB, 1:15RB, 2:25RB, 3:50RB, 4:75RB, 5:100RB. */
    unsigned char   vrbStart;           /**< . */
    unsigned char   vrbLength;          /**< . */
    unsigned char   mcsMode;            /**< MCS mode, 0: QPSK, 1: 16QAM, 2: 64QAM, 3: 256QAM. */
    short           txPowerValue;       /**< TX power, with format S(8,8). */
    unsigned char   networkSelection;   /**< Network selection, range 0 to 31. */
    unsigned char   txCloseLoopDisbl;   /**< . */
    unsigned char   amprEnbl;           /**< . */
    unsigned short  txRoute;            /**< TX route number. */
    unsigned char   enableMultiCluster; /**< . */ // only for 1CC
    unsigned char   vrbStart2;          /**< . */ // only for enableMultiCluster
    unsigned char   vrbLength2;         /**< . */ // only for enableMultiCluster
    unsigned char   enableCsr;          /**< . */ // 0: Don't enable CSR, 1: Enable Csr
    unsigned short  dlFrequency;        /**< . */ // only for enableCsr
} ERfTestCmdPuschTxParamV5;

 /**
 * \ingroup LTEStruct
 * \details This structure is the request parameters of PUSCH TX command
 */
typedef struct
{
    unsigned char               ulCCNum;                            /**< UL carrier number, support up to 3 in M50 series. */
    short                       afcdac;                             /**< AFC DAC value. */
    unsigned char               isforcemode;                        /**< Specify if execute in force mode, not used in M50 series. */
    ERfTestCmdPuschTxParamV5    puschTxParam[ERF_MAX_TX_CC_NUM_V5]; /**< TX parameters. */
} ERfTestCmd_StartPuschTxCaV5_ReqParam;

/**
 * \ingroup     LTE
 * \sa          non-reentrant version of META_ERf_TxPusch_V5_r
 */
META_RESULT __stdcall META_ERf_TxPusch_V5( const unsigned int ms_timeout, const ERfTestCmd_StartPuschTxCaV5_ReqParam* req, unsigned int* pSyncStatus );
/**
 * \ingroup     LTE
 * \details     PUSCH TX test function
 *
 * \param [in]  meta_handle             context handle to specific DUT
 * \param [in]  ms_timeout              API transaction timeout value in micro-seconds
 * \param [in]  req                     PUSCH TX parameters
 * \param [out] pSyncStatus             the cell search status indicator
 *
 * \retval      META_SUCCESS            Successful
 * \retval      META_TIMEOUT            DUT not responding, DUT maybe in exception state
 * \retval      META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval      META_COMM_FAIL          Send request fail, connection may be broken
 *
 * Example Usage:
 * \code
 *    ERfTestCmd_StartPuschTxCaV5_ReqParam req;
 *    unsigned int sync;
 *    META_RESULT mr = META_ERf_TxPusch_V5(1000, &req, &sync);
 *    if(mr != META_SUCCESS)
 *    {
 *        excpetion handling ...
 *    }
 *    else
 *    {
 *        if(sync != 0)
 *        {
 *            handl sync failed ...
 *        }
 *        else
 *        {
 *            test ...              
 *        }
 *    }
 * \endcode
 */
META_RESULT __stdcall META_ERf_TxPusch_V5_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmd_StartPuschTxCaV5_ReqParam* req, unsigned int* pSyncStatus );

/*******************************************************************************
 * ERF_TEST_CMD_START_SRS_TX_CA_V5
 ******************************************************************************/

 /**
 * \ingroup LTEStruct
 * \details This structure is the TX parameters of SRS TX command
 */
typedef struct
{
    unsigned char   band;               /**< LTE band number (spec. defined). */
    unsigned char   duplexMode;         /**< Duplex mode - 0:tdd, 1:fdd */
    unsigned short  ulFrequency;        /**< UL frequency (100KHz unit). */
    unsigned short  cellId;             /**< Cell ID. */
    unsigned char   tddCsSrsBwCfg;      /**< . */
    short           txPowerValue;       /**< TX power, with format S(8,8). */
    unsigned char   networkSelection;   /**< Network selection, range 0 to 31. */
    unsigned char   txCloseLoopDisbl;   /**< . */
    unsigned char   amprEnbl;           /**< . */
    unsigned short  txRoute;            /**< TX route number. */
} ERfTestCmdSrsTxParamV5;

 /**
 * \ingroup LTEStruct
 * \details This structure is the request parameters of SRS TX command
 */
typedef struct
{
    unsigned char           ulCCNum;                            /**< UL carrier number, support up to 3 in M50 series. */
    unsigned short          afcdac;                             /**< AFC DAC value. */
    ERfTestCmdSrsTxParamV5  srsTxParam[ERF_MAX_TX_CC_NUM_V5];   /**< TX parameters. */
} ERfTestCmd_StartSrsTxCaV5_ReqParam;

/**
 * \ingroup     LTE
 * \sa non-reentrant version of META_ERf_TxSrs_V5_r
 */
META_RESULT __stdcall META_ERf_TxSrs_V5( const unsigned int ms_timeout, const ERfTestCmd_StartSrsTxCaV5_ReqParam* req );
/**
 * \details     SRS TX test function
 * \ingroup     LTE
 * \sa          ERF_TEST_CMD_START_SRS_TX_CA_V5
 *
 * \param [in]  meta_handle             context handle to specific DUT
 * \param [in]  ms_timeout              API transaction timeout value in micro-seconds
 * \param [in]  req                     SRS TX parameters
 *
 * \retval      META_SUCCESS            Successful
 * \retval      META_TIMEOUT            DUT not responding, DUT maybe in exception state
 * \retval      META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval      META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_TxSrs_V5_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmd_StartSrsTxCaV5_ReqParam* req );

/*******************************************************************************
 * MMRF DPD CONSTANT DEFINITION V5 START
 ******************************************************************************/
#define ERF_MAX_TX_CCA_BAND_NUM_V5                ERF_MAX_BAND_NUM_V5
#define ERF_BAND_MAP_SIZE_V5                     (2)
#define MAX_TEMP_SECTION_NUM_V5                    (8)
#define LTE_DPD_MAX_CBW_NUM_V5                    (6)
#define LTE_DPD_MAX_PA_LEVEL_NUM_V5                (8)
#define LTE_DPD_MAX_SET_ALL_DATA_NUM_V5            (11)
#define LTE_DPD_MAX_GET_ALL_DATA_NUM_V5            (LTE_DPD_MAX_SET_ALL_DATA_NUM_V5)
#define LTE_DPD_MAX_SET_PARTIAL_DATA_NUM_V5        (120)
#define LTE_DPD_DEPTH_NUM_V5                    (3)

#define MAX_SUPPORTED_BAND_INDEX_V5                (8)
/*******************************************************************************
 * MMRF_TEST_CMD_SET_DPD_FAC_CAL_ALL_V5
 ******************************************************************************/
typedef struct
{
    unsigned short  num_of_route_and_ps;  
} ERfTestCmdSetDpdAllReqInfoV5;

typedef union
{
    ERfTestCmdSetDpdAllReqInfoV5    lte_dpd_req;
    URfTestCmdSetDpdAllReqInfoV3    wcdma_dpd_req; 
} MMRfTestCmdSetMmDpdAllReqInfoV5;

typedef struct
{
    /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned short                        rat_idx;
    MMRfTestCmdSetMmDpdAllReqInfoV5     mm_dpd_info;   
} MMRfTestCmdSetDpdPaAndDpdFacCalAllReqParamV5;

typedef struct
{
    unsigned short    rf_band;
    unsigned short    comp_route;
    unsigned short    path_select;                          
    unsigned char    paControlLevel; /* 2~8 */
    unsigned char    calRoomTempIdx;
    short            pRf[LTE_DPD_MAX_PA_LEVEL_NUM_V5];
    unsigned short    paGain[LTE_DPD_MAX_PA_LEVEL_NUM_V5];
    unsigned char    dc2dcLevel[LTE_DPD_MAX_PA_LEVEL_NUM_V5]; /* voltage map by chip, TODO */
    short            paGainSbWeight[MAX_TEMP_SECTION_NUM_V5][ERF_MAX_FHC_TX_FREQ_NUM_V5]; 
    unsigned short  ulFrequency[ERF_MAX_FHC_TX_FREQ_NUM_V5];
    unsigned char   dpd_cal_done;             
    short            dpd_tr[ERF_MAX_FHC_TX_FREQ_NUM_V5][LTE_DPD_MAX_CBW_NUM_V5];
} ERfTestCmdSetGetDpdTpcPeerV5;

typedef struct
{
   unsigned short    dpd_p;
   unsigned int     dpd_i_0;
   unsigned int        dpd_q_0;
} LTE_DPD_V5_T;

typedef struct
{
    LTE_DPD_V5_T    dpd_depth[LTE_DPD_DEPTH_NUM_V5];
} LTE_DPD_DEPTH_3_V5_T;

typedef struct
{
    LTE_DPD_DEPTH_3_V5_T    lut[LTE_DPD_MAX_PA_LEVEL_NUM_V5];
} ERfTestCmdDpdLutSubBandV5;

typedef struct
{
    short                        norm[ERF_MAX_FHC_TX_FREQ_NUM_V5][LTE_DPD_MAX_PA_LEVEL_NUM_V5]; 
    ERfTestCmdDpdLutSubBandV5   dpd_lut_subband[ERF_MAX_FHC_TX_FREQ_NUM_V5];
} ERfTestCmdSetGetDpdDpdPeerV5;

typedef struct
{
    ERfTestCmdSetGetDpdTpcPeerV5    dpdtpc_peer;
    ERfTestCmdSetGetDpdDpdPeerV5    dpd_peer;
} ERfTestCmdSetDpdPaAndDpdFacCalAllOneRouteV5;

typedef struct
{
   MMRfTestCmdSetDpdPaAndDpdFacCalAllReqParamV5 reqParam;
   union
   {
        ERfTestCmdSetDpdPaAndDpdFacCalAllOneRouteV5 lteReqPeer[LTE_DPD_MAX_SET_ALL_DATA_NUM_V5];
        URfTestCmdSetDpdPaAndDpdFacCalAllOneBandV3  wcdmaReqPeer[MAX_SUPPORTED_BAND_INDEX_V5];
   };
} MMRfTestCmdSetDpdPaAndDpdFacCalAllReqV5;

typedef enum
{
    ERF_TEST_SET_DPD_COARSE_INVALID = 0,
    ERF_TEST_SET_DPD_COARSE_OK        = 1,
    ERF_TEST_SET_DPD_COARSE_PEER_SIZE_MISMATCH = 2  /* count/offset mismatch */   
} ERfTestSetDpdFacCalCoarseStatusV5;

typedef enum
{
    ERF_TEST_SET_DPD_ROUTE_INVALID          = 0,
    ERF_TEST_SET_DPD_ROUTE_OK                = 1,
    ERF_TEST_SET_DPD_ROUTE_BAND_MISMATCH    = 2,
    ERF_TEST_SET_DPD_ROUTE_HPUE_MISMATCH    = 3
} ERfTestSetDpdFacCalRouteStatusV5;

typedef struct
{
    unsigned short    num_of_route_and_ps;
    unsigned char     coarse_status; /* ERfTest_SetDpdFacCal_CoarseStatus_V5 */
    unsigned char   route_status[LTE_DPD_MAX_SET_ALL_DATA_NUM_V5]; /* ERfTest_SetDpdFacCal_RouteStatus_V5 */
} ERfTestResultSetDpdAllCnfInfoV5;

typedef union
{
   ERfTestResultSetDpdAllCnfInfoV5  lte_dpd_cnf;
   URfTestResultSetDpdAllCnfInfoV3  wcdma_dpd_cnf;
} MMRfTestResultSetMmDpdAllCnfInfoV5;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                       rat_idx;
   MMRfTestResultSetMmDpdAllCnfInfoV5   mm_dpd_cnf;
} MMRfTestResultSetDpdPaAndDpdFacCalAllCnfParamV5;

typedef struct
{
   MMRfTestResultSetDpdPaAndDpdFacCalAllCnfParamV5  cnfParam;
} MMRfTestResultSetDpdPaAndDpdFacCalAllCnfV5;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPaAndDpdFacCalAll_V5_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalAll_V5( const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalAllReqV5 *req, MMRfTestResultSetDpdPaAndDpdFacCalAllCnfV5 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalAll_V5_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalAllReqV5 *req, MMRfTestResultSetDpdPaAndDpdFacCalAllCnfV5 *cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_SET_DPD_FAC_CAL_PARTIAL_V5 
 ******************************************************************************/
typedef struct
{
    unsigned short  num_of_route_and_ps;
} ERfTestCmdSetDpdPartialReqInfoV5;

typedef union
{
    ERfTestCmdSetDpdPartialReqInfoV5    lte_dpd_req;
    URfTestCmdSetDpdPartialReqInfoV3    wcdma_dpd_req;
} MMRfTestCmdSetMmDpdPartialReqInfoV5;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                       rat_idx;
   MMRfTestCmdSetMmDpdPartialReqInfoV5  mm_dpd_info;
} MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqParamV5;

typedef struct
{
    ERfTestCmdSetGetDpdTpcPeerV5    dpdtpc_peer;
} ERfTestCmdSetDpdPaAndDpdFacCalPartialOneRouteV5;

typedef struct
{
    MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqParamV5 reqParam;
    union
    {
        ERfTestCmdSetDpdPaAndDpdFacCalPartialOneRouteV5 lteReqPeer[LTE_DPD_MAX_SET_PARTIAL_DATA_NUM_V5];
        URfTestCmdSetDpdPaAndDpdFacCalPartialOneBandV3  wcdmaReqPeer[MAX_SUPPORTED_BAND_INDEX_V5];
    };
} MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqV5;

typedef struct
{
    unsigned short  num_of_route_and_ps;
    unsigned char    coarse_status; 
    unsigned char    route_status[LTE_DPD_MAX_SET_PARTIAL_DATA_NUM_V5]; 
} ERfTestResultSetDpdPartialCnfInfoV5;

typedef union
{
    ERfTestResultSetDpdPartialCnfInfoV5 lte_dpd_cnf;
    URfTestResultSetDpdPartialCnfInfoV3 wcdma_dpd_cnf;
} MMRfTestResultSetMmDpdPartialCnfInfoV5;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                           rat_idx;
   MMRfTestResultSetMmDpdPartialCnfInfoV5   mm_dpd_cnf;
}MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfParamV5;

typedef struct
{
   MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfParamV5 cnfParam;
} MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfV5;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPaAndDpdFacCalPartial_V5_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalPartial_V5( const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqV5 *req, MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfV5 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalPartial_V5_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqV5 *req, MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfV5 *cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_GET_DPD_FAC_CAL_ALL_V5 
 ******************************************************************************/
typedef struct
{
    unsigned short            comp_route;
    unsigned short            path_select;    
} ERfTestCmdRouteInfoV5;

typedef struct
{
    unsigned short            num_of_route_and_ps;             
    ERfTestCmdRouteInfoV5   route_info[LTE_DPD_MAX_GET_ALL_DATA_NUM_V5];
} ERfTestCmdGetDpdAllReqInfoV5;

typedef struct
{
    unsigned short            num_of_band;
    unsigned short            band_num[MAX_SUPPORTED_BAND_INDEX_V5];             
} URfTestCmdGetDpdAllReqInfoV5;

typedef union
{
   ERfTestCmdGetDpdAllReqInfoV5 lte_dpd_req;
   URfTestCmdGetDpdAllReqInfoV5 wcdma_dpd_req;
}MMRfTestCmdGetMmDpdAllReqInfoV5;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                   rat_idx;
   MMRfTestCmdGetMmDpdAllReqInfoV5  mm_dpd_req;
} MMRfTestCmdGetDpdPaAndDpdFacCalAllReqParamV5;

typedef struct
{
    MMRfTestCmdGetDpdPaAndDpdFacCalAllReqParamV5 reqParam;
} MMRfTestCmdGetDpdPaAndDpdFacCalAllReqV5;

typedef struct
{
    unsigned char            get_status; /* ERfTest_GetDpdFacCal_Status_V5 */                
    unsigned short            num_of_route_and_ps;
} ERfTestResultGetDpdAllCnfInfoV5;

typedef struct
{
    unsigned char       get_status; 
    unsigned short      num_of_band;
} URfTestResultGetDpdAllCnfInfoV5;

typedef union
{
   ERfTestResultGetDpdAllCnfInfoV5  lte_dpd_cnf;
   URfTestResultGetDpdAllCnfInfoV5  wcdma_dpd_cnf;
} MMRfTestResultGetMmDpdAllCnfInfoV5;

typedef struct
{
    /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned short                      rat_idx;
    MMRfTestResultGetMmDpdAllCnfInfoV5  mm_dpd_cnf;
} MMRfTestResultGetDpdPaAndDpdFacCalAllCnfParamV5;

typedef struct
{
    ERfTestCmdSetGetDpdTpcPeerV5    dpdtpc_peer;
    ERfTestCmdSetGetDpdDpdPeerV5    dpd_peer;
} ERfTestResultGetDpdPaAndDpdFacCalAllOneRouteV5;

typedef struct
{
    MMRfTestResultGetDpdPaAndDpdFacCalAllCnfParamV5 cnfParam;
    union
    {
        ERfTestResultGetDpdPaAndDpdFacCalAllOneRouteV5  lteCnfPeer[LTE_DPD_MAX_GET_ALL_DATA_NUM_V5];
        URfTestResultGetDpdPaAndDpdFacCalAllOneBandV3   wcdmaCnfPeer[MAX_SUPPORTED_BAND_INDEX_V5];
    };
} MMRfTestResultGetDpdPaAndDpdFacCalAllCnfV5;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdPaAndDpdFacCalAll_V5_r
 */
META_RESULT __stdcall META_MMRf_GetDpdPaAndDpdFacCalAll_V5( const unsigned int ms_timeout, MMRfTestCmdGetDpdPaAndDpdFacCalAllReqV5 *req, const MMRfTestResultGetDpdPaAndDpdFacCalAllCnfV5 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetDpdPaAndDpdFacCalAll_V5_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdGetDpdPaAndDpdFacCalAllReqV5 *req, const MMRfTestResultGetDpdPaAndDpdFacCalAllCnfV5 *cnf);

/*******************************************************************************
 * 
 ******************************************************************************/

// Define request struct
typedef struct
{
    unsigned short      num_of_band;
    unsigned short      cal_band[MAX_SUPPORTED_BAND_INDEX_V5];
} URfTestCmdStartDpdReqInfoV5;

typedef union
{
   URfTestCmdStartDpdReqInfoV5  wcdma_dpd_req;
} MMRfTestCmdStartMmDpdReqInfoV5;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                   rat_idx;
   MMRfTestCmdStartMmDpdReqInfoV5   mm_dpd_info;
} MMRfTestCmdStartDpdPaAndDpdFacCalReqParamV5;

typedef struct
{
   MMRfTestCmdStartDpdPaAndDpdFacCalReqParamV5 reqParam;
   union
   {
        URfTestCmdAptRefChannelOneBandV3    wcdmaReqPeer[MAX_SUPPORTED_BAND_INDEX_V5];
   };
} MMRfTestCmdStartDpdPaAndDpdFacCalReqV5;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdPaAndDpdFacCal_V5_r
 */
META_RESULT __stdcall META_MMRf_StartDpdPaAndDpdFacCal_V5( const unsigned int ms_timeout, const MMRfTestCmdStartDpdPaAndDpdFacCalReqV5 *req, MMRfTestResultStartDpdPaAndDpdFacCalCnfV3 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartDpdPaAndDpdFacCal_V5_r( const int meta_handle, const unsigned int ms_timeout , const MMRfTestCmdStartDpdPaAndDpdFacCalReqV5 *req, MMRfTestResultStartDpdPaAndDpdFacCalCnfV3 *cnf);

/*******************************************************************************
 * ERF_TEST_CMD_GET_DPD_RF_CAPABILITY_V5
 ******************************************************************************/

typedef enum
{
    ERF_TEST_DPD_HIGH_POWER_MODE    = 0,
    ERF_TEST_DPD_MID_HIGH_POWER_MODE    = 1
} ERfTest_Dpd_Power_Mode_V5;

 /**
 * \ingroup LTEStruct
 * \details This structure is the route information of DPD capability
 */
typedef struct
{
    unsigned short  rf_band;                                          /**< LTE band number (spec. defined). */
    unsigned short  total_route_num;                                  /**< Total TX route number. */
    unsigned short  comp_route[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V5];     /**< Route number of each TX route. */
    unsigned short  dpd_switch_on[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V5];  /**< Specify whether DPD is supported for each TX route. */
}ERfTestDpdRouteInfoV5;

 /**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of query DPD RF capability command since M50 series
 */
typedef struct
{
    unsigned short          dpd_power_mode;                             /**< Power mode used in DPD. */
    unsigned short          total_band_num;                             /**< Total number of LTE band. */
    unsigned short          total_cca_band_num;                         /**< Total number of LTE CCA band. */
    unsigned short          total_hpue_band_num;                        /**< Total number of LTE HPUE band. */
    ERfTestDpdRouteInfoV5   dpd_info[ERF_MAX_BAND_NUM_V5];              /**< Route information for each band. */
    ERfTestDpdRouteInfoV5   dpd_cca_info[ERF_MAX_TX_CCA_BAND_NUM_V5];   /**< CCA route information for each CCA band. */
    unsigned short          hpue_band[ERF_MAX_BAND_NUM_V5];             /**< LTE band number (spec. defined) for HPUE band. */
} ERfTestResultGetDpdRfCapabilityV5;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetDpdRfCapability_V5_r
 */
META_RESULT __stdcall META_ERf_GetDpdRfCapability_V5( const unsigned int ms_timeout, ERfTestResultGetDpdRfCapabilityV5* cnf);
 /**
 * \ingroup LTE
 * \details Get DPD RF capability since M50 series
 * \param   meta_handle             meta handle
 * \param   ms_timeout              time out in ms
 * \param   cnf                     confirm message of query DPD RF capability command
 * \retval  META_SUCCESS            Successful
 * \retval  META_TIMEOUT            DUT not responding, DUT may be in exception state
 * \retval  META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval  META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_GetDpdRfCapability_V5_r( const int meta_handle, const unsigned int ms_timeout, ERfTestResultGetDpdRfCapabilityV5* cnf);
/*******************************************************************************
 * MMRF DPD CONSTANT DEFINITION V5 END
 ******************************************************************************/

/*******************************************************************************
 * MMRF ET CONSTANT DEFINITION V5
 ******************************************************************************/
#define LTE_MAX_TX_COMP_ROUTE_NUM               (50) 
#define LTE_TARGET_MAX_SUPPORT_BAND_NUM         (25)
#define LTE_ET_NUM_SUBBAND                      (ERF_MAX_ET_NUM_SUBBAND_V5)
#define LTE_ET_RB_CASE                          (ERF_MAX_ET_NUM_RB_IDX_V5)
#define LTE_ET_LUT_SET_NUM_V5                   (3)
#define LTE_ET_DEFINE_CBW                       (ERF_MAX_ET_NUM_CBW_V5)
#define LTE_ET_DPD_DEPTH_NUM_V5                 (3)           
#define LTE_ET_VIN_NUM                          (ERF_MAX_ET_LUT_PWR_NUM_V5)
#define LTE_ET_STEP2_DEFINE_CBW                 (2)
#define LTE_ET_STEP2_DEFINE_NUM_DELAY           (3)
#define LTE_TARGET_MAX_SUPPORT_BAND_NUM_V5      (25)
#define LTE_ET_CA_TYPE_NUM_V5                   (2)


#define ERF_MAX_ET_NUM_SUBBAND_V5               (8)
#define ERF_MAX_ET_NUM_RB_IDX_V5                (44)
#define ERF_MAX_ET_LUT_PWR_NUM_V5               (16)
#define ERF_MAX_ET_NUM_CBW_V5                   (10)
#define ERF_MAX_ET_STEP2_DEFINE_CBW_V5          (2)
#define ERF_MAX_ET_STEP2_DEFINE_NUM_DELAY_V5    (3)
#define ERF_MAX_LTE_ET_SET_DATA_NUM_V5          (27)  /* floor(MMRF_MAX_TOOL_PEER_SIZE_PER_CMD /                                                                                                                                     sizeof(MMRfTestCmd_SetLteEtFacCalAll_ReqPdu)) */
#define ERF_MAX_LTE_ET_GET_DATA_NUM_V5          (ERF_MAX_LTE_ET_SET_DATA_NUM_V5)
#define ERF_MAX_LTE_ET_GET_PARTIAL_DATA_NUM_V5  (43)
#define ERF_MAX_LTE_ET_START_CAL_DATA_NUM_V5    (74)    
#define ERF_MAX_ET_NUM_ROUTE_V5                 (LTE_MAX_TX_COMP_ROUTE_NUM + LTE_MAX_TX_COMP_ROUTE_NUM)
#define ERF_MAX_ET_NUM_ROUTE_TYPE_V5            (3)

typedef enum
{
    LTE_ETK_POST_PROCESSING_ALGO_INVALID      = 0,
    LTE_ETK_POST_PROCESSING_ALGO_1            = 1,
    LTE_ETK_POST_PROCESSING_ALGO_2            = 2,
    LTE_ETK_POST_PROCESSING_ALGO_3            = 3,
    LTE_ETK_POST_PROCESSING_ALGO_4            = 4,
    LTE_ETK_POST_PROCESSING_ALGO_5            = 5,
    LTE_ETK_POST_PROCESSING_ALGO_6            = 6,
    LTE_ETK_POST_PROCESSING_ALGO_7            = 7,
    LTE_ETK_POST_PROCESSING_ALGO_8            = 8,
    LTE_ETK_POST_PROCESSING_ALGO_9            = 9,
    LTE_ETK_POST_PROCESSING_ALGO_10           = 10,
    LTE_ETK_POST_PROCESSING_ALGO_11           = 11,
    LTE_ETK_POST_PROCESSING_ALGO_12           = 12,
    LTE_ETK_POST_PROCESSING_ALGO_13           = 13,
    LTE_ETK_POST_PROCESSING_ALGO_14           = 14,
    LTE_ETK_POST_PROCESSING_ALGO_15           = 15,
    LTE_ETK_POST_PROCESSING_ALGO_16           = 16,
    LTE_ETK_POST_PROCESSING_ALGO_NON_USED     = 0xFFFFFFFF
} LTE_ETK_POST_PROCESSING_ALGO_E;

/*******************************************************************************
 * MMRF ET COMMON STRUCTURE DEFINITION V5
 ******************************************************************************/

/* LTE_ET_FAC_PARAMETER_NVRAM_INI_V5_T */
typedef struct
{
    char   GainComp[LTE_ET_LUT_SET_NUM_V5];
} LTE_ET_LAB_GC_SUBBAND_V5_T;

typedef struct
{
    LTE_ET_LAB_GC_SUBBAND_V5_T      GainComp_dB_subband[LTE_ET_NUM_SUBBAND];       /* gain compression from lab k    */
    short                           GroupDelay[LTE_ET_NUM_SUBBAND][LTE_ET_RB_CASE];
} LTE_ET_FAC_PARAMETER_NVRAM_INI_V5_T;
/* LTE_ET_FAC_PARAMETER_NVRAM_INI_V5_T */


/* LTE_ET_GAINIDX_LABK_NVRAM_INI_V5_T */
typedef struct
{
    unsigned char   txrf_gain_idx[LTE_ET_LUT_SET_NUM_V5];
} LTE_ET_LAB_GAIN_IDX_SUBBAND_V5_T;

typedef struct
{
    LTE_ET_LAB_GAIN_IDX_SUBBAND_V5_T    txrf_gain_idx_subband[LTE_ET_NUM_SUBBAND];     /* TXRF PGA gain index from lab k */
} LTE_ET_GAINIDX_LABK_NVRAM_INI_V5_T;
/* LTE_ET_GAINIDX_LABK_NVRAM_INI_V5_T */


/* LTE_ET_FAC_PARAMETER_NONNVRAM_INI_V5_T */
typedef struct
{
    short                           cca_poutgain[LTE_ET_NUM_SUBBAND];
    short                           step2_define_cal_dly[LTE_ET_STEP2_DEFINE_CBW][LTE_ET_STEP2_DEFINE_NUM_DELAY];
    unsigned short                  step2_define_cal_cbw[LTE_ET_NUM_SUBBAND]; /*bitmap for different cbw.bit0:1.4M ~ bit9:40M*/
    LTE_ETK_POST_PROCESSING_ALGO_E  ETK_algorithm;                            /*1 for normal, 2 for smooth LUT*/
} LTE_ET_FAC_PARAMETER_NONNVRAM_INI_V5_T;
/* LTE_ET_FAC_PARAMETER_NONNVRAM_INI_V5_T */


/* LTE_ET_FAC_CALDATA_NVRAM_V5_T */
typedef struct
{
    unsigned char   VinVpaLut[LTE_ET_VIN_NUM];
} LTE_ET_VPALUT_SET_V5_T;

typedef struct
{
    LTE_ET_VPALUT_SET_V5_T      VinVpaLut_set[LTE_ET_LUT_SET_NUM_V5];
} LTE_ET_VPALUT_SUBBAND_V5_T;


typedef struct
{
    unsigned short  etdpd_p;
    unsigned int    etdpd_i_0;
    unsigned int    etdpd_q_0;
    unsigned int    etdpd_i_1;
    unsigned int    etdpd_q_1;
} LTE_ET_DPD_V5_T;

typedef struct
{
    LTE_ET_DPD_V5_T     etdpd_hp[LTE_ET_DPD_DEPTH_NUM_V5];
    LTE_ET_DPD_V5_T     etdpd_hp_srb;
    LTE_ET_DPD_V5_T     etdpd_norm;
} LTE_ET_DPD_SUBBAND_V5_T;



typedef struct
{
   short    Pout_max[LTE_ET_LUT_SET_NUM_V5];
} LTE_ET_POUT_SUBBAND_V5_T;


typedef struct
{
   short    PaGainFineTuneStep1[LTE_ET_LUT_SET_NUM_V5];
} LTE_ET_PA_GAIN_TUNE_SUBBAND_V5_T;


typedef struct
{
    char                                PathDelay[LTE_ET_NUM_SUBBAND][LTE_ET_DEFINE_CBW]; /* step2 ET delay calibration result */
    LTE_ET_VPALUT_SUBBAND_V5_T          VinVpaLut_subband[LTE_ET_NUM_SUBBAND];            /* step1 ET VPA LUT */
    LTE_ET_DPD_SUBBAND_V5_T             etdpd_subband[LTE_ET_NUM_SUBBAND];                /* step2 ETDPD PM LUT */
    LTE_ET_POUT_SUBBAND_V5_T            Pout_max_subband[LTE_ET_NUM_SUBBAND];             /* step1 ET Pout */
    LTE_ET_PA_GAIN_TUNE_SUBBAND_V5_T    PaGainFineTune_subband[LTE_ET_NUM_SUBBAND];       /* Sx.5 step1 the ET PA gain diff with APT */   
} LTE_ET_FAC_CALDATA_NVRAM_V5_T;
/* LTE_ET_FAC_CALDATA_NVRAM_V5_T */

/*******************************************************************************
 * MMRF_TEST_CMD_GET_ET_CAL_RESULT_V5
 ******************************************************************************/
typedef struct
{
    unsigned short  route_idx;
    unsigned short  path_select;
} ERfTestEtRouteInfo;

typedef struct
{
    unsigned short          route_num;
    ERfTestEtRouteInfo      route_info[ERF_MAX_LTE_ET_GET_PARTIAL_DATA_NUM_V5];
} ERfTestCmdGetEtCalResultPartialV5;

typedef struct
{
    union
    {
        ERfTestCmdGetEtCalResultPartialV5   lte_get_req_info;
    };
} MMRfTestCmdGetEtCalResultPartialV5;


typedef struct
{
    unsigned short          route_num;
    ERfTestEtRouteInfo      route_info[ERF_MAX_LTE_ET_GET_DATA_NUM_V5];
} ERfTestCmdGetEtCalResultAllV5;

typedef struct
{
    union
    {
        ERfTestCmdGetEtCalResultAllV5       lte_get_req_info;
    };  
} MMRfTestCmdGetEtCalResultAllV5;


typedef struct
{
    union
    {
        MMRfTestCmdGetEtCalResultPartialV5  get_partial_req_info;
        MMRfTestCmdGetEtCalResultAllV5      get_all_req_info;
    };
} MMRfTestCmdGetEtCalResultInfoV5;

typedef struct
{
    /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned char                       is_get_all;        /* 0:get partial(for K), 1:get all(for update parameter), 2:get gain idx labk*/
    unsigned short                      rat_idx;
    MMRfTestCmdGetEtCalResultInfoV5     get_req_info;
} MMRfTestCmdGetEtCalResultReqParamV5;

typedef struct
{
    MMRfTestCmdGetEtCalResultReqParamV5 reqParam;
} MMRfTestCmdGetEtCalResultReqV5;


typedef struct
{   
    unsigned short  route_num;
    unsigned char   get_status;
} ERfTestGetEtCalResultInfoV5;

typedef struct
{
    union
    {
        ERfTestGetEtCalResultInfoV5     lte_get_cnf_info;
    };
} MMRfTestResultGetEtCalResultInfoV5;

typedef struct
{
    unsigned char                       is_get_all;        
    unsigned short                      rat_idx;
    MMRfTestResultGetEtCalResultInfoV5  get_cnf_info;
} MMRfTestResultGetEtCalResultCnfParamV5;


typedef struct
{
    /*92 increase */
    unsigned short                          rf_band;
    unsigned short                          comp_route;
    unsigned short                          path_select;  /* 0:bypass 1:filter 2:CCA 3: filter CCA */
   
    /* all entries in this struct are "per band" */
    unsigned int                            EtCalDoneFlag;
    LTE_ET_FAC_CALDATA_NVRAM_V5_T           cal_result;
    LTE_ET_FAC_PARAMETER_NVRAM_INI_V5_T     labk_result;
    LTE_ET_GAINIDX_LABK_NVRAM_INI_V5_T      labk_gain_idx;
    LTE_ET_FAC_PARAMETER_NONNVRAM_INI_V5_T  control_data;
} ERfTestEtOneRouteAllDataV5;

typedef struct
{
    /* 92 increase */
    unsigned short                  rf_band;
    unsigned short                  comp_route;
    unsigned short                  path_select;  /* 0:bypass 1:filter 2:CCA 3: filter CCA */
   
    /* all entries in this struct are "per band" */
    unsigned int                    EtCalDoneFlag;
    LTE_ET_FAC_CALDATA_NVRAM_V5_T   cal_result;
} ERfTestEtOneRoutePartialDataV5;

typedef struct
{
    union
    {
        ERfTestEtOneRoutePartialDataV5  etPartialData[ERF_MAX_LTE_ET_GET_PARTIAL_DATA_NUM_V5];
        ERfTestEtOneRouteAllDataV5      etAllData[ERF_MAX_LTE_ET_GET_DATA_NUM_V5];
    };
} ERfTestGetEtCalResultCnfPeerV5;

typedef struct
{
    MMRfTestResultGetEtCalResultCnfParamV5 cnfParam;
    union
    {
        ERfTestGetEtCalResultCnfPeerV5  lteCnfPeer;
    };
} MMRfTestResultGetEtCalResultCnfV5;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtCalResult_V5_r
 */
META_RESULT __stdcall META_MMRf_GetEtCalResult_V5( const unsigned int ms_timeout, MMRfTestCmdGetEtCalResultReqV5 *req, const MMRfTestResultGetEtCalResultCnfV5 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetEtCalResult_V5_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdGetEtCalResultReqV5 *req, const MMRfTestResultGetEtCalResultCnfV5 *cnf);


/*******************************************************************************
 * MMRF_TEST_CMD_SET_ET_CAL_RESULT_V5
 ******************************************************************************/
typedef struct
{
    unsigned short                      route_num;
} ERfTestCmdSetEtCalResultV5;

typedef union
{
    ERfTestCmdSetEtCalResultV5          lte_set_req_info;
} MMRfTestCmdSetEtCalResultInfoV5;

typedef struct
{
    
    unsigned short                      rat_idx;
    MMRfTestCmdSetEtCalResultInfoV5     set_req_info;
} MMRfTestResultSetEtCalResultReqParamV5;

typedef struct
{
    ERfTestEtOneRouteAllDataV5      etAllData[ERF_MAX_LTE_ET_GET_DATA_NUM_V5];
} ERfTestSetEtCalResultReqPeerV5;

typedef struct
{
    MMRfTestResultSetEtCalResultReqParamV5 reqParam;
    union
    {
        ERfTestSetEtCalResultReqPeerV5  lteReqPeer;
    };
} MMRfTestCmdSetEtCalResultReqV5;


typedef struct
{
    unsigned short      route_num; 
    unsigned char       route_status[ERF_MAX_LTE_ET_SET_DATA_NUM_V5];
} ERfTestResultSetEtCalResultV5;

typedef union
{
    ERfTestResultSetEtCalResultV5   lte_set_cnf_info;
} MMRfTestResultSetEtCalResultInfoV5;

typedef struct
{
    unsigned short                          rat_idx;
    MMRfTestResultSetEtCalResultInfoV5      set_cnf_info;
} MMRfTestResultSetEtCalResultCnfParamV5;

typedef struct
{
    MMRfTestResultSetEtCalResultCnfParamV5 cnfParam;    
} MMRfTestResultSetEtCalResultCnfV5;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetEtCalResult_V5_r
 */
META_RESULT __stdcall META_MMRf_SetEtCalResult_V5( const unsigned int ms_timeout, MMRfTestCmdSetEtCalResultReqV5 *req, const MMRfTestResultSetEtCalResultCnfV5 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetEtCalResult_V5_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdSetEtCalResultReqV5 *req, const MMRfTestResultSetEtCalResultCnfV5 *cnf);


/*******************************************************************************
 * MMRF_TEST_CMD_START_ET_FAC_CAL_V5
 ******************************************************************************/
typedef enum
{
   ETK_INVALID          = 0,
   ETK_NORMAL           = 1,
   ETK_RF_GAIN_IDX      = 2,
   ETK_GC_SEARCH        = 3,
   ETK_DELAY_SEARCH     = 4,
   ETK_UNUSED           = 0xFFFF,
} Erf_ET_K_Type;

typedef struct
{
    unsigned short  route_num;    /* The number of route in this start command */   
    unsigned short  cmd_set_done;  /* last start command indicator. 0:No, 1:Yes*/
    Erf_ET_K_Type   etk_type;
} ERfTestCmdStartEtCalV5;

typedef union
{
    ERfTestCmdStartEtCalV5      lte_start_info;
} MMRfTestCmdStartEtCalInfoV5;

typedef struct
{
    unsigned short                  rat_idx; /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    MMRfTestCmdStartEtCalInfoV5     start_info;
} MMRfTestCmdStartEtCalReqParamV5;


typedef struct
{
    /*92ET increase*/
    unsigned short                          rf_band;
    unsigned short                          comp_route;
    unsigned short                          path_select;    /* 0:bypass 1:filter 2:CCA 3: filter CCA */
    /*95ET*/
    LTE_ET_FAC_PARAMETER_NVRAM_INI_V5_T     labk_result;
    LTE_ET_GAINIDX_LABK_NVRAM_INI_V5_T      labk_gain_idx;
    /*ETK step2 */
    LTE_ET_FAC_PARAMETER_NONNVRAM_INI_V5_T  control_data;
} ERfTestStartEtCalOneRouteV5;

typedef struct
{
    ERfTestStartEtCalOneRouteV5 lteStartEtKData[ERF_MAX_LTE_ET_START_CAL_DATA_NUM_V5];
} ERfTestStartEtCalResultReqPeerV5;

typedef struct
{
    MMRfTestCmdStartEtCalReqParamV5 reqParam;
    union
    {
        ERfTestStartEtCalResultReqPeerV5  lteReqPeer;
    };
} MMRfTestCmdStartEtCalReqV5;


typedef struct
{
    unsigned char   status;    
    unsigned short  band;
    unsigned short  route;
    unsigned short  subband;
} ERfTestResultStartEtCalV5;

typedef union
{
    ERfTestResultStartEtCalV5       lte_et_error_msg;
} MMRfTestResultStartEtCalInfoV5;

typedef struct
{
    unsigned short                      et_rat_idx;
    MMRfTestResultStartEtCalInfoV5      et_error_msg;
} MMRfTestResultStartEtCalCnfParamV5;

typedef struct
{
    MMRfTestResultStartEtCalCnfParamV5 cnfParam;    
} MMRfTestResultStartEtCalCnfV5;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtCal_V5_r
 */
META_RESULT __stdcall META_MMRf_StartEtCal_V5( const unsigned int ms_timeout, MMRfTestCmdStartEtCalReqV5 *req, const MMRfTestResultStartEtCalCnfV5 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartEtCal_V5_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdStartEtCalReqV5 *req, const MMRfTestResultStartEtCalCnfV5 *cnf);


/*******************************************************************************
 * MMRF_TEST_CMD_CHECK_ET_PATH_DELAY_SEARCH_V5
 ******************************************************************************/
// REQ
typedef struct
{
    unsigned short rat_idx;
} MMRfTestCmdGetEtLabTuningRouteTestInfoReqParamV5;

typedef struct
{
    MMRfTestCmdGetEtLabTuningRouteTestInfoReqParamV5 reqParam;
} MMRfTestCmdGetEtLabTuningRouteTestInfoReqV5;


// CNF
typedef struct
{
    unsigned short  rat_idx;
    union
    {
        unsigned char   lteStatus;
    };

} MMRfTestResultGetEtLabTuningRouteTestInfoCnfParamV5;

typedef struct
{
    unsigned short  Tx_rb_num  [LTE_TARGET_MAX_SUPPORT_BAND_NUM][LTE_ET_CA_TYPE_NUM_V5][LTE_ET_LUT_SET_NUM_V5];             /*number of rb*/
    unsigned char   Tx_power   [LTE_TARGET_MAX_SUPPORT_BAND_NUM][LTE_ET_CA_TYPE_NUM_V5][LTE_ET_LUT_SET_NUM_V5];             /*Tx power*/
    unsigned short  SubbandFreq[LTE_TARGET_MAX_SUPPORT_BAND_NUM][ERF_MAX_ET_NUM_SUBBAND_V5][ ERF_MAX_ET_NUM_CBW_V5];     /*subband frequency*/
    unsigned short  Band_array [LTE_TARGET_MAX_SUPPORT_BAND_NUM];
} ERfTestResultGetEtLabTuningRouteTestInfoCnfPeerV5;

typedef struct
{
    MMRfTestResultGetEtLabTuningRouteTestInfoCnfParamV5     cnfParam;
    union
    {
        ERfTestResultGetEtLabTuningRouteTestInfoCnfPeerV5   cnfPeer;
    };
} MMRfTestResultGetEtLabTuningRouteTestInfoCnfV5;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtLabTuningRouteTestInfo_V5_r
 */
META_RESULT __stdcall META_MMRf_GetEtLabTuningRouteTestInfo_V5( const unsigned int ms_timeout, const MMRfTestCmdGetEtLabTuningRouteTestInfoReqV5* req, MMRfTestResultGetEtLabTuningRouteTestInfoCnfV5* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetEtLabTuningRouteTestInfo_V5_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetEtLabTuningRouteTestInfoReqV5* req, MMRfTestResultGetEtLabTuningRouteTestInfoCnfV5* cnf);


/*******************************************************************************
 * ERF_TEST_CMD_GET_ET_RF_CAPABILITY_V5
 ******************************************************************************/

 /**
 * \ingroup LTEStruct
 * \details This structure is the route information of ET capability
 */
typedef struct
{
    unsigned short  rf_band;                                        /**< LTE band number (spec. defined). */
    unsigned short  total_route_num;                                /**< Total TX route number. */
    unsigned short  comp_route[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V5];   /**< Route number of each TX route. */
    unsigned short  et_switch_on[ERF_MAX_TX_TYPE1_CATEGORY_NUM_V5]; /**< Specify whether ET is supported for each TX route. */
} ERfTestEtRouteInfoV5;

 /**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of query ET RF capability command since M50 series
 */
typedef struct
{
    unsigned short          total_band_num;                             /**< Total number of LTE band. */
    unsigned short          total_cca_band_num;                         /**< Total number of LTE CCA band. */
    ERfTestEtRouteInfoV5    et_info[ERF_MAX_BAND_NUM_V5];               /**< Route information for each band. */
    ERfTestEtRouteInfoV5    et_cca_info[ERF_MAX_TX_CCA_BAND_NUM_V5];    /**< CCA route information for each CCA band. */
} ERfTestResultGetEtRfCapability;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetEtRfCapability_V5_r
 */
META_RESULT __stdcall META_ERf_GetEtRfCapability_V5( const unsigned int ms_timeout, ERfTestResultGetEtRfCapability* cnf);
 /**
 * \ingroup LTE
 * \details Get ET RF capability since M50 series
 * \param   meta_handle             meta handle
 * \param   ms_timeout              time out in ms
 * \param   cnf                     confirm message of query ET RF capability command
 * \retval  META_SUCCESS            Successful
 * \retval  META_TIMEOUT            DUT not responding, DUT may be in exception state
 * \retval  META_INVALID_ARGUMENTS  Invalid argument, "req" or "cnf" pointer may be NULL
 * \retval  META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_GetEtRfCapability_V5_r( const int meta_handle, const unsigned int ms_timeout, ERfTestResultGetEtRfCapability* cnf);

/********************* MT6295 Structure Definitions *********************/

/********************* MT6297 Structure Definitions *********************/

/*================== LTE/NR General Definition ==================*/    

#define MMTST_MAX_TEMP_SECTION_NUM      8
#define MMTST_MAX_RX_RFTOOL_FERQ_NUM    5

#define MMTST_ANT_NONE_MASK 0x00
#define MMTST_ANT_0_MASK    0x01
#define MMTST_ANT_1_MASK    0x02
#define MMTST_ANT_2_MASK    0x04
#define MMTST_ANT_3_MASK    0x08

#define MMTST_MAX_RX_T2_GBG_PATH_NUM    2

#define MMTST_MAX(m,n)                      (((m)>(n))?(m):(n))
#define MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE    61440 //60*1024
#define MMTST_MAX_PEER_BUF_CNF_WORD_SIZE    (MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE >> 2)

#define MMTST_MAX_META_CMD_NUM              1024
#define MMTST_MAX_META_CMD_NUM_BY_WORD      (MMTST_MAX_META_CMD_NUM >> 5 )
#define MMTST_ROUTE_INVALID                 0xFFFE

/*================== LTE/NR Constant Definition ==================*/    

#define MMTST_MAX_TX_CENTER_PA_LEVEL_NUM_V7 10
#define MMTST_MAX_TX_SUBBAND_MODE_NUM_V7    3 //Center CPL & Subband CPL & Subband PA used num

#define MMTST_MAX_BAND_NUM_V7   25

#define MMTST_MAX_RX_CC_NUM_V7  6
#define MMTST_MAX_TX_CC_NUM_V7  4

#define MMTST_RX_TYPE2_START_ROUTE_NUM_V7   512
#define MMTST_MAX_MIMO_COMP_ROUTE_PAIRS_V7  5

#define MMTST_MAX_TX_NUM_V7     100
#define MMTST_MAX_RX_T1_NUM_V7  100
#define MMTST_MAX_RX_T2_NUM_V7  100
#define MMTST_MAX_RX_NUM_V7     (MMTST_RX_TYPE2_START_ROUTE_NUM_V7 + MMTST_MAX_RX_T2_NUM_V7)

#define MMTST_MAX_TX_PARTIAL_BAND_ROUTE_NUM_V7 14
#define MMTST_MAX_RX_PARTIAL_BAND_ROUTE_NUM_V7 14

#define MMTST_MAX_TX_BW_SEGMENT_V7  4

#define MMTST_STATUS_ASCII_ARRAT_SIZE_V7    64
#define MMTST_PORT_ASCII_ARRAY_SIZE_V7      16

#define MMTST_RX_ELNA_MODE_NUM_V7           7
#define MMTST_RX_ILNA_MODE_NUM_V7           3
#define MMTST_RX_LNA_MODE_NUM_V7            8

#define MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7      10
#define MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7     48
#define MMTST_MAX_FHC_RX_SEQ_NUM_V7         MMTST_MAX(MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7, MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7)

#define MMTST_MAX_FHC_FREQ_NUM_V7           64
#define MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7    16
#define MMTST_MAX_BLK_FOR_ROUTE_V7          ( MMTST_MAX_FHC_FREQ_NUM_V7 / MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7)

#define MMTST_MAX_RX_T1_CAL_DATA_ACCESS_NUM_V7      ( MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(MMTST_RX_PL_T1_V7_FOR_BLK_T) )
#define MMTST_MAX_RX_T2_CAL_DATA_ACCESS_NUM_V7      ( MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(MMTST_RX_PL_T2_V7_FOR_BLK_T) )
#define MMTST_MAX_TX_CAL_DATA_ACCESS_NUM_V7         ( MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(MMTST_TX_TPC_V7_FOR_BLK_T) )

#define MMTST_MAX_RX_T1_ROUTE_INFO_ACCESS_NUM_V7    ( MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(MMTST_QUERY_RX_T1_ROUTE_INFO_T) )
#define MMTST_MAX_RX_T2_ROUTE_INFO_ACCESS_NUM_V7    ( MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(MMTST_QUERY_RX_T2_ROUTE_INFO_T) )
#define MMTST_MAX_TX_ROUTE_INFO_ACCESS_NUM_V7       ( MMTST_MAX_PEER_BUF_CNF_BYTE_SIZE/sizeof(MMTST_QUERY_TX_ROUTE_INFO_T) )

/*================== LTE/NR Enum & Struct Definition ==================*/    

typedef enum
{
    MMTST_RAT_LTE   = 0, 
    MMTST_RAT_NR    = 1, 
    MMTST_RAT_MAX   = 0x7FFFFFFF
} MMTST_RAT_E;

typedef enum
{
    MMTST_RX_HPM            = 0,
    MMTST_RX_LPM            = 1,
    MMTST_RX_PWR_MODE_NUM,
    MMTST_RX_PWR_MODE_MAX   = 0x7FFFFFFF
}MMTST_PWR_MODE_E;

typedef enum
{
    MMTST_RX_PARTIAL_ON_PATH0     = 0,
    MMTST_RX_PARTIAL_ON_PATH1     = 1,
    MMTST_RX_PARTIAL_ON_PATH_NUM,
    MMTST_RX_PARTIAL_ON_INVLAID,
    MMTST_RX_PARTIAL_ON_MAX       = 0x7FFFFFFF
} MMTST_RX_PARTIAL_ON_PATH_E;

typedef enum
{
    MMTST_MIMO_PAIR_INVALID     = 0,
    MMTST_MIMO_PAIR_1X          = 1,
    MMTST_MIMO_PAIR_2X          = 1, // 2X2
    MMTST_MIMO_PAIR_4X          = 2, // 4X4
    MMTST_MIMO_PAIR_8X          = 4,
    MMTST_MIMO_PAIR_LAYERS_NUM,
    MMTST_MIMO_PAIR_LAYERS_MAX  =  0x7FFFFFFF
} MMTST_MIMO_PAIR_E;

typedef enum
{
    MMTST_MIMO_ANT_NUM_INVALID      = 0,
    MMTST_MIMO_ANT_NUM_1X           = 1,
    MMTST_MIMO_ANT_NUM_2X           = 2, // 2X2
    MMTST_MIMO_ANT_NUM_4X           = 4, // 4X4
    MMTST_MIMO_ANT_NUM_8X           = 8,
    MMTST_MIMO_ANT_NUM_NUM,
    MMTST_MIMO_ANT_NUM_MAX          =  0x7FFFFFFF
} MMTST_MIMO_ANT_NUM_E;

/*================== LTE/NR L1 command ==================*/    
/*******************************************************************************
 * MMRF_TEST_CMD_EN_SET_TRX_SETTING
 ******************************************************************************/
typedef  struct
{
    unsigned char       pa_mode_idx;
    unsigned char       dc2dc_lvl;
    short               prf;
    unsigned short      pa_gain;
    bool                is_256qam_used;
} MMTST_PA_LEVHANDLE_T;

typedef struct
{
    short           coupler_loss;
} MMTST_CPL_LEVHANDLE_T;

typedef struct
{
    unsigned char   pa_level_idx;//calibration used, indicate which Prf used for cpl calibration
    short           pa_sub_compensate_value [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    short           pa_temp_compensate_value [MMTST_MAX_TEMP_SECTION_NUM];
    short           cpl_sub_compensate_value [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    short           cpl_temp_compensate_value [MMTST_MAX_TEMP_SECTION_NUM];
} MMTST_SUBBAND_PA_CPL_COMP_T;

typedef struct
{
    unsigned short              bandIndex;
    unsigned char               calroomtempIdx;
    unsigned char               pa_section_used;
    unsigned char               pa_mode_used;
    unsigned int                subband_freq_khz [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];

    MMTST_PA_LEVHANDLE_T        pa_level_handle [MMTST_MAX_TX_CENTER_PA_LEVEL_NUM_V7];// real number of sections, 8 is maximum
    MMTST_CPL_LEVHANDLE_T       cpl_level_handle [MMTST_MAX_TX_SUBBAND_MODE_NUM_V7];
    MMTST_SUBBAND_PA_CPL_COMP_T sub_pa_cpl_comp [MMTST_MAX_TX_SUBBAND_MODE_NUM_V7];
} MMTST_TX_TPC_V7_FOR_BLK_T;

typedef struct
{
    short   lna_mode_lpm;
    short   lna_mode_hpm;
} MMTST_RX_RAW_DATA_V7_T;

typedef struct
{
    short   temp_comp [MMTST_MAX_TEMP_SECTION_NUM];
} MMTST_TEMP_OFFSET_TABLE_V7_T;

typedef struct
{
    MMTST_RX_RAW_DATA_V7_T        pathloss_raw [MMTST_RX_LNA_MODE_NUM_V7];
} MMTST_RX_PL_SUBBAND_T1_V7_T;

typedef struct
{
    unsigned short                  bandIndex;
    unsigned int                    subbandFrequency [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    MMTST_RX_PL_SUBBAND_T1_V7_T     pathlossData [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7][MMTST_MIMO_ANT_NUM_2X];//0: RXM, 1: RXD
    MMTST_TEMP_OFFSET_TABLE_V7_T    pathlossTempComp;
} MMTST_RX_PL_T1_V7_FOR_BLK_T;

typedef struct
{
    MMTST_RX_RAW_DATA_V7_T      pathloss_raw_sc[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_RX_LNA_MODE_NUM_V7];
} MMTST_RX_PL_SUBBAND_T2A_V7_T;

typedef struct
{
    MMTST_RX_RAW_DATA_V7_T      pathloss_raw_gbg [MMTST_RX_ELNA_MODE_NUM_V7][MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_RX_ILNA_MODE_NUM_V7][MMTST_RX_ILNA_MODE_NUM_V7];
} MMTST_RX_PL_SUBBAND_T2B_V7_T;

typedef struct
{
    MMTST_RX_PL_SUBBAND_T2A_V7_T     pathlossData_sc;
    MMTST_RX_PL_SUBBAND_T2B_V7_T     pathlossData_gbg;
} MMTST_RX_PL_SUBBAND_T2_V7_T;

typedef struct
{
    unsigned short               bandIndex;
    unsigned int                 subbandFrequency [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    MMTST_RX_PL_SUBBAND_T2_V7_T  pathlossData [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7][MMTST_MIMO_ANT_NUM_2X];
    MMTST_TEMP_OFFSET_TABLE_V7_T pathlossTempComp;
} MMTST_RX_PL_T2_V7_FOR_BLK_T;


typedef struct
{
    unsigned short  route_count;
    unsigned short  total_blk;
} MMTST_TRX_SETIING_ENTRY_T;

typedef struct
{
	unsigned short  total_blk_num;   
	unsigned short  route_idx;
} MMTST_RX_T1_SET_DATA_INFO_BY_ROUTE_T;

typedef struct
{
	unsigned short 	total_blk_num;   
	unsigned short  used_blk_this_round;
	unsigned short  blk_idx [MMTST_MAX_BLK_FOR_ROUTE_V7];   
	unsigned short  route_idx;
} MMTST_RX_T2_SET_DATA_INFO_BY_ROUTE_T;

typedef struct
{
    unsigned int 	agg_bw_khz;
	unsigned short 	total_blk_num;   
	unsigned short 	route_idx;
} MMTST_TX_SET_DATA_INFO_BY_ROUTE_T;

typedef struct
{
	MMTST_RX_T1_SET_DATA_INFO_BY_ROUTE_T	rx_t1 [MMTST_MAX_RX_T1_CAL_DATA_ACCESS_NUM_V7];
    MMTST_RX_T2_SET_DATA_INFO_BY_ROUTE_T    rx_t2 [MMTST_MAX_RX_T2_CAL_DATA_ACCESS_NUM_V7];
    MMTST_TX_SET_DATA_INFO_BY_ROUTE_T 	    tx [MMTST_MAX_TX_CAL_DATA_ACCESS_NUM_V7];
} MMTST_TRX_SET_DATA_INFO_BY_ROUTE_T;


typedef struct
{
    MMTST_RAT_E    rat;
    bool                            last_cal_data;
    MMTST_TRX_SETIING_ENTRY_T       rx_t1_entry;
    MMTST_TRX_SETIING_ENTRY_T       rx_t2_entry;
    MMTST_TRX_SETIING_ENTRY_T       tx_entry;
    MMTST_TRX_SET_DATA_INFO_BY_ROUTE_T  data_info;

    MMTST_RX_PL_T1_V7_FOR_BLK_T     rx_t1_blk_data [MMTST_MAX_RX_T1_CAL_DATA_ACCESS_NUM_V7];
    MMTST_RX_PL_T2_V7_FOR_BLK_T     rx_t2_blk_data [MMTST_MAX_RX_T2_CAL_DATA_ACCESS_NUM_V7];
    MMTST_TX_TPC_V7_FOR_BLK_T       tx_blk_data [MMTST_MAX_TX_CAL_DATA_ACCESS_NUM_V7];
} MMRfTestCmd_EN_SetTRxSettingV7;

typedef struct
{
    bool            status;// 1: Pass, 0: Fail
    unsigned char   rx_t1_status_code [MMTST_STATUS_ASCII_ARRAT_SIZE_V7];
    unsigned char   rx_t2_status_code [MMTST_STATUS_ASCII_ARRAT_SIZE_V7];
    unsigned char   tx_status_code [MMTST_STATUS_ASCII_ARRAT_SIZE_V7];
} MMRfTestResult_EN_SetTRxSettingV7;

/* for k flow & UI used */
typedef struct
{
    unsigned short                  band;
    unsigned short                  compRoute;
    unsigned int                    subbandFrequency [MMTST_MAX_FHC_FREQ_NUM_V7];
    MMTST_RX_PL_SUBBAND_T1_V7_T     pathlossData [MMTST_MAX_FHC_FREQ_NUM_V7][MMTST_MIMO_ANT_NUM_2X];//0: RXM, 1: RXD
    MMTST_TEMP_OFFSET_TABLE_V7_T    pathlossTempComp;
} MMTST_RX_PL_T1_V7_FOR_ROUTE_T; // for k flow & UI used

typedef struct
{
    unsigned short               band;
    unsigned short               compRoute;
    unsigned int                 subbandFrequency [MMTST_MAX_FHC_FREQ_NUM_V7];
    MMTST_RX_PL_SUBBAND_T2_V7_T  pathlossData [MMTST_MAX_FHC_FREQ_NUM_V7][MMTST_MIMO_ANT_NUM_2X];
    MMTST_TEMP_OFFSET_TABLE_V7_T pathlossTempComp;
} MMTST_RX_PL_T2_V7_FOR_ROUTE_T; // for k flow & UI used

typedef struct
{
    unsigned char   pa_level_idx;//calibration used, indicate which Prf used for cpl calibration
    short           pa_sub_compensate_value [MMTST_MAX_FHC_FREQ_NUM_V7];
    short           pa_temp_compensate_value [MMTST_MAX_TEMP_SECTION_NUM];
    short           cpl_sub_compensate_value [MMTST_MAX_FHC_FREQ_NUM_V7];
    short           cpl_temp_compensate_value [MMTST_MAX_TEMP_SECTION_NUM];
} MMTST_SUBBAND_PA_CPL_COMP_FOR_ROUTE_T;

typedef struct
{
    unsigned short              band;
    unsigned short              compRoute;
    unsigned char               txAggBwIdx;
    unsigned char               calroomtempIdx;
    unsigned char               pa_section_used;
    unsigned char               pa_mode_used;
    unsigned int                subband_freq_khz [MMTST_MAX_FHC_FREQ_NUM_V7];

    MMTST_PA_LEVHANDLE_T                    pa_level_handle [MMTST_MAX_TX_CENTER_PA_LEVEL_NUM_V7];// real number of sections, 8 is maximum
    MMTST_CPL_LEVHANDLE_T                   cpl_level_handle [MMTST_MAX_TX_SUBBAND_MODE_NUM_V7];
    MMTST_SUBBAND_PA_CPL_COMP_FOR_ROUTE_T   sub_pa_cpl_comp [MMTST_MAX_TX_SUBBAND_MODE_NUM_V7];
} MMTST_TX_TPC_T1_V7_FOR_ROUTE_T; // for k flow & UI used

META_RESULT __stdcall META_MMRf_EN_SetTRxSetting_V7( const unsigned int ms_timeout, const MMRfTestCmd_EN_SetTRxSettingV7 *req, MMRfTestResult_EN_SetTRxSettingV7 *cnf);
META_RESULT __stdcall META_MMRf_EN_SetTRxSetting_V7_r(  const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_EN_SetTRxSettingV7 *req, MMRfTestResult_EN_SetTRxSettingV7 *cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_EN_QUERY_CONFIG
 ******************************************************************************/

typedef struct
{
    MMTST_RAT_E rat;
} MMRfTestCmd_EN_QueryConfigV7;

typedef struct
{
    unsigned short  band;
    unsigned short  comp_route;
} MMTST_RX_T1_INFO_T;

typedef struct
{
    unsigned short  band;
   	unsigned short 	comp_route;
	unsigned short  t1_route_for_path0;
   	unsigned short 	t2_route_for_path1;
    bool    	    is_en_route;
} MMTST_RX_T2_INFO_T;

typedef struct
{
    unsigned short  	band;
   	unsigned short 	    comp_route;
   	unsigned short      bw_segment;
  	unsigned int        bw_boundary_khz [MMTST_MAX_TX_BW_SEGMENT_V7];
} MMTST_TX_INFO_T;

typedef struct
{
    unsigned short  	    tx_comp_route_used;
   	unsigned short  	    rx_t1_comp_route_used;
   	unsigned short  	    rx_t2_comp_route_used;
    MMTST_TX_INFO_T         tx_info [MMTST_MAX_TX_NUM_V7];
    MMTST_RX_T1_INFO_T      rx_t1_info [MMTST_MAX_RX_T1_NUM_V7];
    MMTST_RX_T2_INFO_T      rx_t2_info [MMTST_MAX_RX_T2_NUM_V7];
} MMTST_TRX_ROUTE_INFO_T;

typedef struct
{
    bool        t1[MMTST_RX_ELNA_MODE_NUM_V7][MMTST_RX_ILNA_MODE_NUM_V7];//[G][g]
    bool        t2[MMTST_RX_ELNA_MODE_NUM_V7][MMTST_RX_ILNA_MODE_NUM_V7][MMTST_RX_ILNA_MODE_NUM_V7]; //[G][g_path0][g_path1]
} MMTST_RX_USED_INFO_T;

typedef struct
{
   	unsigned char  	elna_idx;
   	unsigned char  	ilna_idx;
} MMTST_RX_T1_NV_INFO_T; 

typedef struct
{
    unsigned char       G_idx;
    unsigned char       g_p0_idx;
    unsigned char       g_p1_idx;
} MMTST_RX_T2_NV_INFO_T; 

typedef struct
{
    unsigned short          seq_t1_num;
    unsigned short          seq_t2_num;

    short                   t1_dlpow_default[MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];
    short                   t1_dlpow_max[MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];
    short                   t1_dlpow_min[MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];
    MMTST_RX_T1_NV_INFO_T   t1_lna_idx[MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];// for cal file print
    unsigned char           t1_nv_idx[MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7]; //T1 NVRAM position:[8]

    short                   t2_dlpow_default[MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
    short                   t2_dlpow_max[MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
    short                   t2_dlpow_min[MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
    MMTST_RX_T2_NV_INFO_T   t2_nv_idx[MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
} MMTST_RX_CAL_INFO_T;

typedef struct
{
    MMTST_RX_USED_INFO_T       rx_used_info; //UI expression used
    MMTST_RX_CAL_INFO_T        rx_cal_info;
} MMTST_RX_GM_INFO_T;

typedef struct
{
   unsigned char    route_num;
   unsigned short   band [MMTST_MAX_RX_PARTIAL_BAND_ROUTE_NUM_V7];
   unsigned short   comp_route [MMTST_MAX_RX_PARTIAL_BAND_ROUTE_NUM_V7];
   unsigned int     start_freq_khz [MMTST_MAX_RX_PARTIAL_BAND_ROUTE_NUM_V7];
   unsigned int     end_freq_khz [MMTST_MAX_RX_PARTIAL_BAND_ROUTE_NUM_V7];
}MMTST_RX_PARTIAL_FERQ_INFO_T;

typedef struct
{
   unsigned char   	route_num;
   unsigned short  	band [MMTST_MAX_TX_PARTIAL_BAND_ROUTE_NUM_V7];
   unsigned short  	comp_route [MMTST_MAX_TX_PARTIAL_BAND_ROUTE_NUM_V7];
   unsigned int 	start_freq_khz [MMTST_MAX_TX_PARTIAL_BAND_ROUTE_NUM_V7];
   unsigned int  	end_freq_khz [MMTST_MAX_TX_PARTIAL_BAND_ROUTE_NUM_V7];
} MMTST_TX_PARTIAL_FERQ_INFO_T;

typedef struct
{
    MMTST_TX_PARTIAL_FERQ_INFO_T    tx;
    MMTST_RX_PARTIAL_FERQ_INFO_T    rx;
} MMTST_TRX_PARTIAL_FERQ_INFO_T;

typedef struct
{
   	unsigned short  band;
   	bool            is_rx_only; //belong to RX only band
   	bool            is_sul; //belong to supplementary uplink (SUL)  band
} MMTST_TRX_BAND_INFO_T;

typedef struct
{
    unsigned int            band_used_num;
   	MMTST_TRX_BAND_INFO_T   trx_band_info [MMTST_MAX_BAND_NUM_V7];
} MMTST_BAND_INFO_T;

typedef struct
{
    MMTST_BAND_INFO_T 		        band_info ;
	MMTST_TRX_PARTIAL_FERQ_INFO_T 	partial_freq_info;
	MMTST_TRX_ROUTE_INFO_T	        route_info;
	MMTST_RX_GM_INFO_T	    	    rx_gm_info [MMTST_RX_PWR_MODE_NUM]; //rx gain mode info
} MMRfTestResult_EN_QueryConfigV7;

META_RESULT __stdcall META_MMRf_EN_QueryConfig_V7( const unsigned int ms_timeout, const MMRfTestCmd_EN_QueryConfigV7 *req, MMRfTestResult_EN_QueryConfigV7 *cnf);
META_RESULT __stdcall META_MMRf_EN_QueryConfig_V7_r(  const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_EN_QueryConfigV7 *req, MMRfTestResult_EN_QueryConfigV7 *cnf);


/*******************************************************************************
 * MMRF_TEST_CMD_EN_FHC
 ******************************************************************************/
typedef struct
{
   /** LTE band number (spec. defined) for this route information element
    */
    unsigned short                    band;

   /** Total block of RX type-1 route for this band
    */
    unsigned char                     rx_type1_blk;

   /** Total block of RX type-2 route for this band
    */
    unsigned char                     rx_type2_blk;

   /** Total block of TX route for this band
    */
    unsigned char                     tx_type1_blk;

   /** TX sub-band number (sub-band count for different routes should be all the same)
    */
    unsigned char                     rx_freq_num;

    /** RX sub-band number (sub-band count for different routes should be all the same)
    */
    unsigned char                     tx_freq_num;

   /** Memory padding (not used)
    */
    unsigned char                     padding;
} FHC_V7_Band_Usage_Param_T;

typedef struct
{
    unsigned short    blk_count;
    unsigned short    raw_data_offset;
} MMTST_FHC_ENTRY_T;


typedef struct
{
    unsigned short      band;
    unsigned short      route_idx;
    unsigned short      freq_num;
    unsigned int        agg_bw_khz;
} MMTST_FHC_CMD_TX_SC_1X_INFO_T;

typedef struct
{
    unsigned char                   used_pwr_step_num[MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];;
    unsigned int                    ul_freq [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    short                           prf [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7][MMTST_MAX_TX_CENTER_PA_LEVEL_NUM_V7];
    MMTST_TX_TPC_V7_FOR_BLK_T       tpc_settings;
} MMTST_FHC_CMD_TX_SC_1X_RAW_T;

typedef struct
{
    unsigned short              band;
    unsigned short              route_idx;
    unsigned short              freq_num;
    MMTST_RX_PARTIAL_ON_PATH_E  partial_on_path;
} MMTST_FHC_CMD_RX_SC_2X_INFO_T;

typedef struct
{
    unsigned char   used_seq_num;
    unsigned char   rx_cal_step [MMTST_RX_PWR_MODE_NUM];
    unsigned int    dl_freq [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    short           temp_offset [MMTST_MAX_TEMP_SECTION_NUM];
    short           dl_power [MMTST_RX_PWR_MODE_NUM][MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];
} MMTST_FHC_CMD_RX_SC_2X_RAW_T;

typedef struct
{
    unsigned short      band;
    unsigned short      route_idx;
    unsigned short      freq_num;
} MMTST_FHC_CMD_RX_GBG_2X_INFO_T;

typedef struct
{
    unsigned char   used_seq_num;
    unsigned char   rx_cal_step [MMTST_RX_PWR_MODE_NUM];
    unsigned int    dl_freq [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    short           temp_offset [MMTST_MAX_TEMP_SECTION_NUM];
    short           dl_power [MMTST_RX_PWR_MODE_NUM][MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
} MMTST_FHC_CMD_RX_GBG_2X_RAW_T;

typedef struct
{
    unsigned short              band;
    unsigned short              route_idx [MMTST_MIMO_PAIR_4X];
    unsigned short              freq_num;   
    MMTST_RX_PARTIAL_ON_PATH_E  partial_on_path;
} MMTST_FHC_CMD_RX_SC_4X_INFO_T;

typedef struct
{
    unsigned char   used_seq_num;
    unsigned char   rx_cal_step [MMTST_RX_PWR_MODE_NUM];
    unsigned int    dl_freq [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    short           temp_offset [MMTST_MIMO_PAIR_4X][MMTST_MAX_TEMP_SECTION_NUM];
    short           dl_power [MMTST_RX_PWR_MODE_NUM][MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];
} MMTST_FHC_CMD_RX_SC_4X_RAW_T;

typedef struct
{
    unsigned short      band;
    unsigned short      route_idx [MMTST_MIMO_PAIR_4X];
    unsigned short      freq_num;
} MMTST_FHC_CMD_RX_GBG_4X_INFO_T;

typedef struct
{
    unsigned char   used_seq_num;
    unsigned char   rx_cal_step [MMTST_RX_PWR_MODE_NUM];
    unsigned int    dl_freq [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
    short           temp_offset [MMTST_MIMO_PAIR_4X][MMTST_MAX_TEMP_SECTION_NUM];
    short           dl_power [MMTST_RX_PWR_MODE_NUM][MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
} MMTST_FHC_CMD_RX_GBG_4X_RAW_T;

typedef struct
{
    MMTST_FHC_CMD_TX_SC_1X_INFO_T   tx_sc_1x_info;
    MMTST_FHC_CMD_TX_SC_1X_RAW_T    tx_sc_1x_raw;
} MMTST_FHC_CMD_TX_SC_1X_BLK_T;

typedef struct
{
    MMTST_FHC_CMD_RX_SC_2X_INFO_T   rx_sc_2x_info;
    MMTST_FHC_CMD_RX_SC_2X_RAW_T    rx_sc_2x_raw;
} MMTST_FHC_CMD_RX_SC_2X_BLK_T;

typedef struct
{
    MMTST_FHC_CMD_RX_GBG_2X_INFO_T  rx_gbg_2x_info;
    MMTST_FHC_CMD_RX_GBG_2X_RAW_T   rx_gbg_2x_raw;
} MMTST_FHC_CMD_RX_GBG_2X_BLK_T;

typedef struct
{
    MMTST_FHC_CMD_RX_SC_4X_INFO_T    rx_sc_4x_info;
    MMTST_FHC_CMD_RX_SC_4X_RAW_T     rx_sc_4x_raw;
} MMTST_FHC_CMD_RX_SC_4X_BLK_T;

typedef struct
{
    MMTST_FHC_CMD_RX_GBG_4X_INFO_T    rx_gbg_4x_info;
    MMTST_FHC_CMD_RX_GBG_4X_RAW_T     rx_gbg_4x_raw;
} MMTST_FHC_CMD_RX_GBG_4X_BLK_T;

typedef struct
{
    MMTST_RAT_E                     rat; 
    unsigned char                   switch_time; //ms unit
    unsigned char                   tx_rx_switch_time; //ms unit
    unsigned short                  rx_instrument_meas_start_offset;
    MMTST_FHC_ENTRY_T               tx_sc_1x_entry;
    MMTST_FHC_ENTRY_T               rx_sc_2x_entry;
    MMTST_FHC_ENTRY_T               rx_gbg_2x_entry;
    MMTST_FHC_ENTRY_T               rx_sc_4x_entry; //rx_t1 + rx_t1
    MMTST_FHC_ENTRY_T               rx_gbg_4x_entry;  //rx_t2 + rx_t2
    MMTST_FHC_CMD_TX_SC_1X_BLK_T    tx_sc_1x_route[MMTST_MAX_TX_NUM_V7];    
    MMTST_FHC_CMD_RX_SC_2X_BLK_T    rx_sc_2x_route[MMTST_MAX_RX_T1_NUM_V7];
    MMTST_FHC_CMD_RX_GBG_2X_BLK_T   rx_gbg_2x_route[MMTST_MAX_RX_T2_NUM_V7];
    MMTST_FHC_CMD_RX_SC_4X_BLK_T    rx_sc_4x_route[MMTST_MAX_RX_T1_NUM_V7];
    MMTST_FHC_CMD_RX_GBG_4X_BLK_T   rx_gbg_4x_route[MMTST_MAX_RX_T2_NUM_V7];
} MMRfTestCmd_EN_StartFHCV7;

typedef struct
{
    short   tx_pd_value [MMTST_MAX_TX_CENTER_PA_LEVEL_NUM_V7];
} MMTST_FHC_RPT_TX_SC_1X_T;

typedef struct
{
    MMTST_FHC_RPT_TX_SC_1X_T    tx_sc_1x_rpt [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
} MMTST_FHC_RPT_TX_SC_1X_BLK_T;

typedef struct
{
    short      rssi [MMTST_MIMO_ANT_NUM_2X] [MMTST_RX_PWR_MODE_NUM] [MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];
} MMTST_FHC_RPT_RX_SC_2X_T;

typedef struct
{
    MMTST_FHC_RPT_RX_SC_2X_T    rx_sc_2x_rpt [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
} MMTST_FHC_RPT_RX_SC_2X_BLK_T;

typedef struct
{
    short   rssi [MMTST_MIMO_ANT_NUM_2X][MMTST_RX_PWR_MODE_NUM][MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
} MMTST_FHC_RPT_RX_GBG_2X_T;

typedef struct
{
   MMTST_FHC_RPT_RX_GBG_2X_T    rx_gbg_2x_rpt [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
} MMTST_FHC_RPT_RX_GBG_2X_BLK_T;

typedef struct
{
    short       rssi [MMTST_MIMO_ANT_NUM_4X][MMTST_RX_PWR_MODE_NUM][MMTST_MAX_FHC_RX_SC_SEQ_NUM_V7];
} MMTST_FHC_RPT_RX_SC_4X_T;

typedef struct
{
   MMTST_FHC_RPT_RX_SC_4X_T    rx_sc_4x_rpt [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
} MMTST_FHC_RPT_RX_SC_4X_BLK_T;

typedef struct
{
    short       rssi [MMTST_MIMO_ANT_NUM_4X][MMTST_RX_PWR_MODE_NUM][MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MAX_FHC_RX_GBG_SEQ_NUM_V7];
} MMTST_FHC_RPT_RX_GBG_4X_T;

typedef struct
{
   MMTST_FHC_RPT_RX_GBG_4X_T    rx_gbg_4x_rpt [MMTST_MAX_FHC_FREQ_NUM_IN_BLK_V7];
} MMTST_FHC_RPT_RX_GBG_4X_BLK_T;

typedef struct
{
    MMTST_FHC_ENTRY_T               tx_sc_t1_entry;
    MMTST_FHC_ENTRY_T               rx_sc_2x_entry;
    MMTST_FHC_ENTRY_T               rx_gbg_2x_entry;
    MMTST_FHC_ENTRY_T               rx_sc_4x_entry;      
    MMTST_FHC_ENTRY_T               rx_gbg_4x_entry;
    MMTST_FHC_RPT_TX_SC_1X_BLK_T    tx_sc_1x_route[MMTST_MAX_TX_NUM_V7];
    MMTST_FHC_RPT_RX_SC_2X_BLK_T    rx_sc_2x_route[MMTST_MAX_RX_T1_NUM_V7];
    MMTST_FHC_RPT_RX_GBG_2X_BLK_T   rx_gbg_2x_route[MMTST_MAX_RX_T2_NUM_V7];
    MMTST_FHC_RPT_RX_SC_4X_BLK_T    rx_sc_4x_route[MMTST_MAX_RX_T1_NUM_V7];
    MMTST_FHC_RPT_RX_GBG_4X_BLK_T   rx_gbg_4x_route[MMTST_MAX_RX_T2_NUM_V7];
} MMRfTestResult_EN_StartFHCV7;

META_RESULT __stdcall META_MMRf_EN_FHC_V7( const unsigned int ms_timeout, const MMRfTestCmd_EN_StartFHCV7 *req, MMRfTestResult_EN_StartFHCV7 *cnf);
META_RESULT __stdcall META_MMRf_EN_FHC_V7_r(  const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_EN_StartFHCV7 *req, MMRfTestResult_EN_StartFHCV7 *cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_EN_STOP
 ******************************************************************************/


META_RESULT __stdcall META_MMRf_EN_TestStop_V7( const unsigned int ms_timeout, const MMTST_RAT_E rat);
META_RESULT __stdcall META_MMRf_EN_TestStop_V7_r( const int meta_handle, const unsigned int ms_timeout, const MMTST_RAT_E rat);
/*******************************************************************************
 * MMRF_TEST_CMD_EN_TRX_ROUTE_CALCULATOR 
 ******************************************************************************/
 typedef enum
{
    MMTST_BW_5M =   5000,           //5MHz
       MMTST_BW_10M =  10000,     //10MHz
       MMTST_BW_15M =  15000,      //15MHz
      MMTST_BW_20M =  20000,      //20MHz
       MMTST_BW_25M =  25000,      //25MHz
      MMTST_BW_30M =  30000,      //30MHz
       MMTST_BW_40M =  40000,      //40MHz
       MMTST_BW_50M =  50000,      //50MHz
       MMTST_BW_60M =  60000,      //60MHz
       MMTST_BW_80M =  80000,      //80MHz
       MMTST_BW_100M = 100000,      //100MHz
       MMTST_BW_MAX = 0x7FFFFFFF
} MMTST_BW_KHZ_E;


typedef enum
{
    MMTST_MIMO_INVALID      = 0,
       MMTST_MIMO_1X           = 1,
       MMTST_MIMO_2X           = 2, // 2X2
       MMTST_MIMO_4X           = 3, // 4X4
       MMTST_MIMO_8X           = 4,
       MMTST_MIMO_LAYERS_NUM,
       MMTST_MIMO_LAYERS_MAX  =  0x7FFFFFFF
}MMTST_MIMO_LAYER_E;

typedef struct
{
       MMTST_RAT_E     rat;
    unsigned char      rx_cc_num;
       unsigned int    rx_freq [MMTST_MAX_RX_CC_NUM_V7]; //frequency in 1kHz
       unsigned short  rx_band [MMTST_MAX_RX_CC_NUM_V7];
       MMTST_BW_KHZ_E  rx_bw [MMTST_MAX_RX_CC_NUM_V7];
       MMTST_MIMO_LAYER_E    rx_mimo_layer[MMTST_MAX_RX_CC_NUM_V7];
       unsigned char       tx_cc_num;
       unsigned int        tx_freq [MMTST_MAX_TX_CC_NUM_V7]; //frequency in 1kHz
       unsigned short      tx_band [MMTST_MAX_TX_CC_NUM_V7];
       MMTST_BW_KHZ_E        tx_bw [MMTST_MAX_TX_CC_NUM_V7];
} MMRfTestCmd_En_TrxRouteCalculatorV7;


typedef struct
{
       unsigned short  comp_route;
       unsigned short  FE_route;
       unsigned char   port[MMTST_PORT_ASCII_ARRAY_SIZE_V7];
       unsigned char   stx;
}MMTST_TX_ROUTE_INFO_T;

typedef struct
{
   unsigned short   comp_route;
   unsigned short   FE_route;
   unsigned char    port [MMTST_MIMO_ANT_NUM_2X][MMTST_PORT_ASCII_ARRAY_SIZE_V7];//main & diversity may have different port
   unsigned char    srx;
}MMTST_RX_ROUTE_INFO_T;

typedef struct
{
    unsigned char   status; // 0:Valid 1:invlad
       unsigned char   status_msg [MMTST_STATUS_ASCII_ARRAT_SIZE_V7];
    MMTST_TX_ROUTE_INFO_T     tx_route_info[MMTST_MAX_TX_CC_NUM_V7];
    MMTST_RX_ROUTE_INFO_T     rx_route_info[MMTST_MAX_RX_CC_NUM_V7][MMTST_MIMO_PAIR_4X];
} MMRfTestResult_En_TrxRouteCalculatorV7;

META_RESULT __stdcall META_MMRf_EN_TRxRouteCalculator_V7( const unsigned int ms_timeout, const MMRfTestCmd_En_TrxRouteCalculatorV7 *req, MMRfTestResult_En_TrxRouteCalculatorV7* cnf);
META_RESULT __stdcall META_MMRf_EN_TRxRouteCalculator_V7_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_En_TrxRouteCalculatorV7 *req, MMRfTestResult_En_TrxRouteCalculatorV7* cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_EN_START_CW_TX_TONE 
 ******************************************************************************/
typedef enum
{
       MMTST_AFC_DATA_TYPE_USED_CAL_RESULT = 0, // use calibration data
       MMTST_AFC_DATA_TYPE_USED_UI_SETTING = 1  // use setting in UI
}MMTST_AFC_DATA_TYPE_E;

typedef enum
{
       MMTST_TTG_FERQ_OFFSET_M_540KHZ      = 0xFFFFFFDC, // -36
       MMTST_TTG_FERQ_OFFSET_M_450KHZ      = 0xFFFFFFE2, // -30
       MMTST_TTG_FERQ_OFFSET_M_360KHZ      = 0xFFFFFFE8, // -24
       MMTST_TTG_FERQ_OFFSET_M_270KHZ      = 0xFFFFFFEE, // -18
       MMTST_TTG_FERQ_OFFSET_M_180KHZ      = 0xFFFFFFF4, // -12
       MMTST_TTG_FERQ_OFFSET_M_90KHZ       = 0xFFFFFFFA, // -6
       MMTST_TTG_FERQ_OFFSET_ZERO          = 0x00000000, // 0
       MMTST_TTG_FERQ_OFFSET_P_90KHZ       = 0x00000006, // 6
       MMTST_TTG_FERQ_OFFSET_P_180KHZ      = 0x0000000C, // 12
       MMTST_TTG_FERQ_OFFSET_P_270KHZ      = 0x00000012, // 18
       MMTST_TTG_FERQ_OFFSET_P_360KHZ      = 0x00000018, // 24
       MMTST_TTG_FERQ_OFFSET_P_450KHZ      = 0x0000001E, // 30
       MMTST_TTG_FERQ_OFFSET_P_540KHZ      = 0x00000024, // 36
       MMTST_TTG_FERQ_OFFSET_MAX           = 0x7FFFFFFF
}MMTST_TTG_FERQ_OFFSET_E;


typedef struct
{
    MMTST_RAT_E      rat;
    unsigned short      band;
    unsigned short      routeidx;
    unsigned short      afcdac;
    short                    txPowerValue;/*S(8,8), x dB * 256.0 */
    unsigned int          ul_freq_khz;
    unsigned int          agg_bw_khz;
    MMTST_TTG_FERQ_OFFSET_E     ul_freq_offset;
    MMTST_AFC_DATA_TYPE_E        afcDataType;
}MMRfTestCmd_En_SartTxCwToneV7;


META_RESULT __stdcall META_MMRf_EN_StartSingleToneTx_V7( const unsigned int ms_timeout, const MMRfTestCmd_En_SartTxCwToneV7 *req);
META_RESULT __stdcall META_MMRf_EN_StartSingleToneTx_V7_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_En_SartTxCwToneV7 *req);
/*******************************************************************************
 * MMRF_TEST_CMD_EN_FETCH_CW_TX_PD_VALUE 
 ******************************************************************************/

META_RESULT __stdcall META_MMRf_EN_FetchTxPdValue_V7 ( const unsigned int ms_timeout, const MMTST_RAT_E rat, short* pdValue );
META_RESULT __stdcall META_MMRf_EN_FetchTxPdValue_V7_r( const int meta_handle, const unsigned int ms_timeout, const MMTST_RAT_E rat, short* pdValue );

/*******************************************************************************
 * MMRF_TEST_CMD_EN_GET_RX_GAIN_INFO 
 ******************************************************************************/

typedef struct
{
       unsigned char      elna_mode[MMTST_MIMO_ANT_NUM_2X];
       unsigned char      ilna_mode[MMTST_MIMO_ANT_NUM_2X];
}MMTST_GET_RX_GAIN_INFO_SC_INPUT_T;

typedef struct
{
       unsigned char    elna_mode[MMTST_MIMO_ANT_NUM_2X];
       unsigned char    ilna_mode[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];
}MMTST_GET_RX_GAIN_INFO_GBG_INPUT_T;



typedef enum
{
       MMTST_GET_RX_GAIN_INFO_STATUS_INVALID     = 0,
       MMTST_GET_RX_GAIN_INFO_STATUS_OK          = 1,     
    MMTST_GET_RX_GAIN_INFO_STATUS_ERR         = 2,     
    MMTST_GET_RX_GAIN_INFO_STATUS_MAX         = 0x7FFFFFFF
}MMTST_GET_RX_GAIN_INFO_STATUS_E;

typedef struct
{
       short        rf_gain[MMTST_MIMO_ANT_NUM_2X]; // 0:No , 1:Yes
       short        digital_gain[MMTST_MIMO_ANT_NUM_2X];
}MMTST_GET_RX_GAIN_INFO_SC_OUTPUT_T;

typedef struct
{
   unsigned char    rf_gain_idx[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];
   short    rf_gain[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X]; //  resolution 1/32 
   short    digital_gain[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X]; // resolution 1/32 
}MMTST_GET_RX_GAIN_INFO_GBG_OUTPUT_T;


typedef struct
{
    MMTST_RAT_E           rat;  
       MMTST_PWR_MODE_E      powermode;
       unsigned char         is_partialon;    // 0:No , 1:Yes
      unsigned short        routeidx;      
    union // type + partial on flag
    {
          MMTST_GET_RX_GAIN_INFO_SC_INPUT_T      sc;
          MMTST_GET_RX_GAIN_INFO_GBG_INPUT_T     gbg;
    }; 
} MMRfTestCmd_En_GetRxGainInfoV7;

typedef struct
{
       short               dl_power;
      unsigned short      routeidx;         
      unsigned char       is_partialon;    
    union
    {
           MMTST_GET_RX_GAIN_INFO_SC_OUTPUT_T      sc;
           MMTST_GET_RX_GAIN_INFO_GBG_OUTPUT_T     gbg;
    }; 
} MMRfTestResult_En_GetRxGainInfoV7;

META_RESULT __stdcall META_MMRf_EN_GetRxGainInfo_V7 ( const unsigned int ms_timeout, const MMRfTestCmd_En_GetRxGainInfoV7 *req, MMRfTestResult_En_GetRxGainInfoV7* cnf );
META_RESULT __stdcall META_MMRf_EN_GetRxGainInfo_V7_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_En_GetRxGainInfoV7 *req, MMRfTestResult_En_GetRxGainInfoV7* cnf );

/*******************************************************************************
 * MMRF_TEST_CMD_EN_CW_RSSI 
 ******************************************************************************/
typedef struct
{
       short    rf_gain[MMTST_MIMO_ANT_NUM_2X];// resolution 1/32 
       short    digital_gain[MMTST_MIMO_ANT_NUM_2X];
}MMTST_CW_RSSI_SC_INPUT_T;

typedef struct
{
   unsigned char    rf_gain_idx[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];
   short            rf_gain[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];// resolution 1/32 
   short            digital_gain[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];
}MMTST_CW_RSSI_GBG_INPUT_T;

typedef struct
{
   short           rssi[MMTST_MAX_RX_RFTOOL_FERQ_NUM][MMTST_MIMO_ANT_NUM_2X];
   unsigned char   elna_mode[MMTST_MIMO_ANT_NUM_2X];
   unsigned char   ilna_mode[MMTST_MIMO_ANT_NUM_2X];
}MMTST_CW_RSSI_SC_OUTPUT_T;

typedef struct
{
   short            rssi[MMTST_MAX_RX_RFTOOL_FERQ_NUM][MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];// resolution 1/32 
   unsigned char    elna_mode[MMTST_MIMO_ANT_NUM_2X];
   unsigned char    ilna_mode[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];
}MMTST_CW_RSSI_GBG_OUTPUT_T;

typedef struct
{
    MMTST_RAT_E            rat;
       MMTST_PWR_MODE_E       powermode;
       unsigned int           dl_freq [MMTST_MAX_RX_RFTOOL_FERQ_NUM];
       unsigned short         band;
       unsigned short         routeidx;
       unsigned char          is_partialon; // 0:No , 1:Yes
       unsigned char          num_freq;// 1~5
    MMTST_RX_PARTIAL_ON_PATH_E       partialon_path;
    union // type + partial on flag
    {
        MMTST_CW_RSSI_SC_INPUT_T      sc;
           MMTST_CW_RSSI_GBG_INPUT_T     gbg;
    }; 
} MMRfTestCmd_En_RssiV7;

typedef struct
{
       unsigned char     num_freq;
       unsigned int      dl_freq[MMTST_MAX_RX_RFTOOL_FERQ_NUM];
    unsigned short    routeidx;
    unsigned char     is_partialon;
    union // type + partial on flag
    {
           MMTST_CW_RSSI_SC_OUTPUT_T      sc;
           MMTST_CW_RSSI_GBG_OUTPUT_T     gbg;
    }; 
} MMRfTestResult_En_RssiV7;

META_RESULT __stdcall META_MMRf_EN_Rssi_V7 ( const unsigned int ms_timeout, const MMRfTestCmd_En_RssiV7 *req, MMRfTestResult_En_RssiV7* cnf );
META_RESULT __stdcall META_MMRf_EN_Rssi_V7_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_En_RssiV7 *req, MMRfTestResult_En_RssiV7* cnf );
/*******************************************************************************
 * MMRF_TEST_CMD_EN_START_CW_CONT_RX 
 ******************************************************************************/
typedef struct
{
       short   rf_gain[MMTST_MIMO_ANT_NUM_2X];    // resolution 1/32 
}MMTST_START_CW_CONTRX_SC_OUTPUT_T;

typedef struct
{
       unsigned char     rf_gain_idx[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];
       short           rf_gain[MMTST_MAX_RX_T2_GBG_PATH_NUM][MMTST_MIMO_ANT_NUM_2X];
}MMTST_START_CW_CONTRX_GBG_OUTPUT_T;


typedef struct
{
    MMTST_RAT_E                rat;
       MMTST_PWR_MODE_E           powermode;
       unsigned int               bw;
       unsigned short             band;
       unsigned short             routeidx;
       unsigned char              is_partialon; //0:No , 1:Yes
       MMTST_RX_PARTIAL_ON_PATH_E       partialon_path;
    union // type + partial on flag
    {
           MMTST_START_CW_CONTRX_SC_OUTPUT_T     sc;
           MMTST_START_CW_CONTRX_GBG_OUTPUT_T     gbg;
    }; 
       unsigned int               dl_freq;  // frequency in 1kHz
} MMRfTestCmd_En_SartCwContRxV7;

META_RESULT __stdcall META_MMRf_EN_ContRx_V7 ( const unsigned int ms_timeout, const MMRfTestCmd_En_SartCwContRxV7 *req );
META_RESULT __stdcall META_MMRf_EN_ContRx_V7_r ( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_En_SartCwContRxV7 *req );
/*******************************************************************************
 * MMRF_TEST_CMD_EN_QUERY_TRX_ROUTE_INFO 
 ******************************************************************************/
typedef struct
{
    unsigned short    route_idx;
    unsigned int      agg_bw_khz;
}MMTST_TX_PARAM_INFO_T;



typedef struct
{
    unsigned int        ant_mask;// told tool comp_route corresponding ant_mask
    unsigned short      fe_route_idx;
    unsigned char       port[MMTST_PORT_ASCII_ARRAY_SIZE_V7];
    unsigned char       stx;
    unsigned char       mimo_pair_route_num;
    unsigned short      mimo_comp_route_pair [MMTST_MAX_MIMO_COMP_ROUTE_PAIRS_V7];
}MMTST_QUERY_TX_ROUTE_INFO_T;

typedef struct
{
    unsigned int        ant_mask;// told tool comp_route corresponding ant_mask
    unsigned short      fe_route_idx;
    unsigned char       port[MMTST_MIMO_ANT_NUM_2X][MMTST_PORT_ASCII_ARRAY_SIZE_V7];
    unsigned char       srx;
    unsigned char       mimo_pair_route_num;
    unsigned short      mimo_comp_route_pair [MMTST_MAX_MIMO_COMP_ROUTE_PAIRS_V7];
}MMTST_QUERY_RX_T1_ROUTE_INFO_T;

typedef struct
{
    unsigned int        ant_mask;// told tool comp_route corresponding ant_mask
    unsigned short      fe_route_idx;
    unsigned char       port[MMTST_MIMO_ANT_NUM_2X][MMTST_PORT_ASCII_ARRAY_SIZE_V7];
    unsigned char       srx[MMTST_MAX_RX_T2_GBG_PATH_NUM];
    unsigned char       mimo_pair_route_num;
    unsigned short      mimo_comp_route_pair [MMTST_MAX_MIMO_COMP_ROUTE_PAIRS_V7];
}MMTST_QUERY_RX_T2_ROUTE_INFO_T;

typedef struct
{
    MMTST_RAT_E         rat;
    unsigned char       rx_t1_access_route_num;
    unsigned char       rx_t2_access_route_num;
    unsigned char       tx_access_route_num;
    unsigned short      rx_t1_route_idx[MMTST_MAX_RX_T1_ROUTE_INFO_ACCESS_NUM_V7];
    unsigned short      rx_t2_route_idx[MMTST_MAX_RX_T2_ROUTE_INFO_ACCESS_NUM_V7];
    MMTST_TX_PARAM_INFO_T   tx_route_idx[MMTST_MAX_TX_ROUTE_INFO_ACCESS_NUM_V7];
} MMRfTestCmd_EnQueryTrxRouteHwSettingV7;


typedef struct
{
    unsigned char       rx_t1_access_route_num;
    unsigned char       rx_t2_access_route_num;
    unsigned char       tx_access_route_num;
    unsigned short      rx_t1_route_idx[MMTST_MAX_RX_T1_ROUTE_INFO_ACCESS_NUM_V7];
    unsigned short      rx_t2_route_idx[MMTST_MAX_RX_T2_ROUTE_INFO_ACCESS_NUM_V7];
    MMTST_TX_PARAM_INFO_T   tx_route_idx[MMTST_MAX_TX_ROUTE_INFO_ACCESS_NUM_V7];

    MMTST_QUERY_RX_T1_ROUTE_INFO_T rx_t1_route_hwSetting[MMTST_MAX_RX_T1_ROUTE_INFO_ACCESS_NUM_V7];
    MMTST_QUERY_RX_T2_ROUTE_INFO_T rx_t2_route_hwSetting[MMTST_MAX_RX_T2_ROUTE_INFO_ACCESS_NUM_V7];
    MMTST_QUERY_TX_ROUTE_INFO_T tx_route_hwSetting[MMTST_MAX_RX_T1_ROUTE_INFO_ACCESS_NUM_V7];
} MMRfTestResult_EnQueryTrxRouteHwSettingV7;


META_RESULT __stdcall META_MMRf_EN_QueryTxRxRouteHwSetting_V7 ( const unsigned int ms_timeout, const MMRfTestCmd_EnQueryTrxRouteHwSettingV7 *req, const MMRfTestResult_EnQueryTrxRouteHwSettingV7* cnf );
META_RESULT __stdcall META_MMRf_EN_QueryTxRxRouteHwSetting_V7_r ( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmd_EnQueryTrxRouteHwSettingV7 *req, const MMRfTestResult_EnQueryTrxRouteHwSettingV7* cnf );
/********************* MT6297 Structure Definitions *********************/

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_AfcSingleToneTx_V2_r
 */
META_RESULT __stdcall META_ERf_AfcSingleToneTx_V2(const unsigned int ms_timeout, const ERfTestCmdAfcSingleToneTxV2* req);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_AfcSingleToneTx_V2_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdAfcSingleToneTxV2* req);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TpcSingleToneTx_V2_r
 */
META_RESULT __stdcall META_ERf_TpcSingleToneTx_V2(const unsigned int ms_timeout, const ERfTestCmdTpcSingleToneTxV2* req);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TpcSingleToneTx_V2_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdTpcSingleToneTxV2* req);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_Rssi_V2_r
 */
META_RESULT __stdcall META_ERf_Rssi_V2(const unsigned int ms_timeout, const ERfTestCmdRSSIV2* req, ERfTestResultRSSIV2CnfPdu* cnf);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_Rssi_V2_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdRSSIV2* req, ERfTestResultRSSIV2CnfPdu* cnf);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_ContRx_V2_r
 */
META_RESULT __stdcall META_ERf_ContRx_V2(const unsigned int ms_timeout, const ERfTestCmdContRxV2* req);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_ContRx_V2_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdContRxV2* req);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetTxRxRouteInfo_r
 */
META_RESULT __stdcall META_ERf_GetTxRxRouteInfo(const unsigned int ms_timeout, const ERfTestCmdGetTxRxRouteInfo* req, ERfTestResultGetTxRxRouteInfoCnfPdu* cnf);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetTxRxRouteInfo_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdGetTxRxRouteInfo* req, ERfTestResultGetTxRxRouteInfoCnfPdu* cnf);

typedef struct
{
    unsigned char   band;
#define ERF_TX_TEST_COMMAND_CONFIG_TDD 0
#define ERF_TX_TEST_COMMAND_CONFIG_FDD 1
    unsigned char   duplexMode;
    unsigned char   tddConfig;
    unsigned char   tddSfConfig;
    unsigned short  ulFrequency;
    unsigned short  cellId;
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_6RB 0
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_15RB 1
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_25RB 2
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_50RB 3
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_75RB 4
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_100RB 5
    unsigned char   ulBandwidth;
    unsigned char   vrbStart;
    unsigned char   vrbLength;
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_QPSK 0
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_16QAM 1
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_64QAM 2
    unsigned char   mcsMode;
    unsigned char   txPowerMode;
    short           txPowerValue;
    unsigned char   networkSelection;
    unsigned char   txCloseLoopDisbl;
    unsigned char   amprEnbl;
    short           bbBackoff;
    unsigned char   rfGain;
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_HIGH 0
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_MIDDLE 1
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_LOW 2
    unsigned char   paMode;
    unsigned char   paVcc;
    unsigned char   vm0;
    unsigned char   vm1;
    unsigned short  txRoute;
    unsigned char   enableMultiCluster;
    unsigned char   multiClusterVrbStart;
    unsigned char   multiClustervrbLength;
    unsigned char   enableCsr;
    unsigned short  dlFrequency;
#define ERF_TX_TEST_COMMAND_CONFIG_BYPASS_NONCAA_MODE 0
#define ERF_TX_TEST_COMMAND_CONFIG_FILTER_NONCAA_MODE 1
#define ERF_TX_TEST_COMMAND_CONFIG_BYPASS_CAA_MODE 2
#define ERF_TX_TEST_COMMAND_CONFIG_FILTER_CAA_MODE 3
    unsigned short  txPathSelBitmap;
} ERfTestCmdPuschTxV2Param;

typedef struct
{
     unsigned char   ulCCNum;
     short   afcdac;
     ERfTestCmdPuschTxV2Param   puschTxParam[MAX_TX_CC_NUM];
} ERfTestCmdPuschTxV2;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxPusch_V2
 */
META_RESULT __stdcall META_ERf_TxPusch_V2( const unsigned int ms_timeout, const ERfTestCmdPuschTxV2* req, unsigned int* pSyncStatus );
/**
 * \brief PUSCH test function
 * \ingroup LTE
 *
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req PUSCH TX parameters
 * \param [out] pSyncStatus the cell search status indicator
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 *
 * Example Usage:
 * \code
 *    ERfTestCmdPuschTxV2 req;
 *    unsigned int sync;
 *    META_RESULT mr = META_ERf_TxPusch_V2(1000, &req, &sync);
 *    if(mr != META_SUCCESS)
 *    {
 *        excpetion handling ...
 *    }
 *    else
 *    {
 *        if(sync != 0)
 *        {
 *            handl sync failed ...
 *        }
 *        else
 *        {
 *            test ...
 *        }
 *    }
 * \endcode
 */
META_RESULT __stdcall META_ERf_TxPusch_V2_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdPuschTxV2* req, unsigned int* pSyncStatus );

typedef struct
{
    unsigned char    band;
    unsigned char    duplexMode;
    unsigned char    tddConfig;
    unsigned char    tddSfConfig;
    unsigned short   ulFrequency;
    unsigned short   cellId;
    short            afcdac;
    unsigned char    ulBandwidth;
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1 0
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1A 1
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1B 2
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2 3
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2_CPACK 4
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2A 5
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2B 6
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_3 7
    unsigned char    format;
    short            txPowerValue;
    unsigned char    networkSelection;
    unsigned char    txCloseLoopDisbl;
    unsigned char    amprEnbl;
    unsigned short   txRoute;
    unsigned short   txPathSelBitmap;
} ERfTestCmdPucchTxV2;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxPucch_V2_r
 */
META_RESULT __stdcall META_ERf_TxPucch_V2( const unsigned int ms_timeout, const ERfTestCmdPucchTxV2* req );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TxPucch_V2_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdPucchTxV2* req );

typedef struct
{
    unsigned char    band;
    unsigned char    duplexMode;    /* 0: tdd, 1: fdd */
    unsigned short   ulFrequency;
    unsigned short   cellId;
    unsigned char    tddCsSrsBwCfg;
    short            txPowerValue;
    unsigned char    networkSelection;
    unsigned char    txCloseLoopDisbl;
    unsigned char    amprEnbl;
    unsigned short   txRoute;
    unsigned short   txPathSelBitmap;
} ERfTestCmdSrsTxV2Param;

typedef struct
{
    unsigned char   ulCCNum;
    short   afcdac;
    ERfTestCmdSrsTxV2Param   srsTxParam[MAX_TX_CC_NUM];
} ERfTestCmdSrsTxV2;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxSrs_V2_r
 */
 META_RESULT __stdcall META_ERf_TxSrs_V2( const unsigned int ms_timeout, const ERfTestCmdSrsTxV2* req );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TxSrs_V2_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdSrsTxV2* req );

typedef struct
{
    unsigned char   band;
    unsigned short  ulFrequency;
    unsigned short  cellId;
    short           afcdac;
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_FDD_TIME_MASK 0
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_TDD_TIME_MASK 1
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_FDD_EVM 2
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_TDD_EVM 3
    unsigned char   configIndex;
    short           txPowerValue;
    unsigned char   networkSelection;
    unsigned char   txCloseLoopDisbl;
    unsigned char   amprEnbl;
    unsigned short  txRoute;
    unsigned short  txPathSelBitmap;
} ERfTestCmdPrachTxV2;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxPrach_V2_r
 */
META_RESULT __stdcall META_ERf_TxPrach_V2( const unsigned int ms_timeout, const ERfTestCmdPrachTxV2* req );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_TxPrach_V2_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdPrachTxV2* req );

/**
 * \ingroup LTEStruct
 * This structure is the RX-TX related parameters for each cell.
 */
typedef struct
{
  /** The number of reporting measurement records. The range is from 0 to 10.
   */
   unsigned char            measCnt;

  /** The downlink bandwidth. 0 is 1.4 MHz (6 RB), 1 is 3 MHz (15 RB), 2 is 5 MHz (25 RB), 3 is 10 MHz (50 RB), 4 is 15 MHz (75 RB), and 5 is 20 MHz (100 RB).
   */
   unsigned char            measBandwidth;

  /** The operating downlink frequency. Unit is 100KHz.
   */
   unsigned short           dlFrequency;

  /** The operating band.
   */
   unsigned char            band;

  /** The duplex mode. 0 is TDD, and 1 is FDD.
   */
   unsigned char            duplexMode;

  /** The uplink-downlink configuration. Only valid if the range is 0~6 when TDD.
   */
   unsigned char            tddConfig;

  /** The special subframe configuration. Only valid if the range is 0~8 when TDD.
   */
   unsigned char            tddSfConfig;

  /** The uplink bandwidth. 0 is 1.4 MHz (6 RB), 1 is 3 MHz (15 RB), 2 is 5 MHz (25 RB), 3 is 10 MHz (50 RB), 4 is 15 MHz (75 RB), and 5 is 20 MHz (100 RB).
   */
   unsigned char            bandwidth;

  /** RX route index setting.
   */
   unsigned short           rxRoute;

  /** Route path seting selection. 0 is bypass path, and 1 is filter path.
   */
   unsigned short           routePathSel;

  /** The setting of uplink transmission allow. (Pseudo TX-RX mode only)
   */
   bool                    hasUl;

  /** The operating uplink frequency. Unit is 100KHz. (Pseudo TX-RX mode only)
   */
   unsigned short           ulFrequency;

  /** The value of transmission power. The format is S(8,8), which means the left 8-bit is signed integer and the right 8-bit is decimal. (Pseudo TX-RX mode only)
   */
   unsigned short            txPowerValue;

  /** The start location of resource block. The range is from 0 to 99. (Pseudo TX-RX mode only)
   */
   unsigned char            vrbStart;

  /** The length of resource block for transmission. The range is from 1 to 100. (Pseudo TX-RX mode only)
   */
   unsigned char            vrbLength;

  /** The modulation and coding scheme. 0 is QPSK, 1 is 16 QAM, and 2 is 64 QAM. (Pseudo TX-RX mode only)
   */
   unsigned char            mcsMode;

  /** TX route index setting. (Pseudo TX-RX mode only)
   */
   unsigned short           txRoute;
}Mix_Rx_Dl_Ul_Ca_Normal_Mode_Param;

typedef struct
{
   unsigned char                   mode;//0: DL Rx, 1: Tx-Rx, 2: Pseudo Tx-Rx
   unsigned short                  afcdac;
   unsigned char                   rxPath0Enbl;
   unsigned char                   rxPath1Enbl;
   unsigned char                   numOfDlCC;
   unsigned char                   numOfUlCC;
   Mix_Rx_Dl_Ul_Ca_Normal_Mode_Param mix_rx_dl_ul_ca_normal_mode_param[MAX_RX_CC_NUM_V2];
}Mix_Rx_Dl_Ul_Ca_Normal_Mode;

/**
 * \ingroup LTEStruct
 * This structure is the RX parameters for force mode.
 */
typedef struct
{
  /** Different mode setting for RX measurements. 0 is DL RX mode, and 2 is Pseudo TX-RX mode.
   */
   unsigned char            mode;

  /** The number of reporting measurement records. The range is from 0 to 10.
   */
   unsigned char            measCnt;

  /** The DL bandwidth. 0 is 1.4 MHz (6 RB), 1 is 3 MHz (15 RB), 2 is 5 MHz (25 RB), 3 is 10 MHz (50 RB), 4 is 15 MHz (75 RB), and 5 is 20 MHz (100 RB).
   */
   unsigned char            measBandwidth;

  /** The operating DL frequency. Unit is 100KHz.
   */
   unsigned short           dlFrequency;

  /** The operating band.
   */
   unsigned char            band;

  /** The duplex mode. 0 is TDD, and 1 is FDD.
   */
   unsigned char            duplexMode;

  /** The uplink-downlink configuration. Only valid if the range is 0~6 when TDD.
   */
   unsigned char            tddConfig;

  /** The special subframe configuration. Only valid if the range is 0~8 when TDD.
   */
   unsigned char            tddSfConfig;

  /** The UL bandwidth. 0 is 1.4 MHz (6 RB), 1 is 3 MHz (15 RB), 2 is 5 MHz (25 RB), 3 is 10 MHz (50 RB), 4 is 15 MHz (75 RB), and 5 is 20 MHz (100 RB).
   */
   unsigned char            bandwidth;

  /** The setting to enable RX path 0. 0 is disable, and 1 is enable.
   */
   unsigned char            rxPath0Enbl;

  /** The setting to enable RX path 1. 0 is disable, and 1 is enable.
   */
   unsigned char            rxPath1Enbl;

  /** RX route index setting.
   */
   unsigned char            rxRoute;

  /** Route path setting selection. 0 is bypass path, and 1 is filter path.
   */
   unsigned short           routePathSel;
}Mix_Rx_Force_Mode;

/**
 * \ingroup LTEStruct
 */
typedef union
{
   Mix_Rx_Dl_Ul_Ca_Normal_Mode   mix_rx_dl_ul_ca_normal_mode;
   Mix_Rx_Force_Mode            mix_rx_force_mode;
} Mix_Rx_Dl_Ul_Ca_Mode;

typedef struct
{
   unsigned char       opMode; //0: normal mode, 1: force mode
   Mix_Rx_Dl_Ul_Ca_Mode MixRxCaModeV2Param;
} ERfTestCmdMixRx_CaMode_V2;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartMixRx_CaMode_V2_r
 */
META_RESULT __stdcall META_ERf_StartMixRx_CaMode_V2( const unsigned int ms_timeout, const ERfTestCmdMixRx_CaMode_V2* req );
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_StartMixRx_CaMode_V2_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdMixRx_CaMode_V2* req);

/**
 * \ingroup LTEStruct
 * This structure is the report of LTE RX measurement results.
 */
typedef struct
{
  /** The number of measurement reports which will display. The range is from 0 to 10.
   */
    unsigned char measRptCnt[MAX_RX_CC_NUM_V2];

  /** The RSSI measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short rssiPath0[MAX_RX_CC_NUM_V2][10];

  /** The RSSI measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short rssiPath1[MAX_RX_CC_NUM_V2][10];

  /** The RSRP measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short rsrpPath0[MAX_RX_CC_NUM_V2][10];

  /** The RSRP measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short rsrpPath1[MAX_RX_CC_NUM_V2][10];

  /** The RSRQ measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short rsrqPath0[MAX_RX_CC_NUM_V2][10];

  /** The RSRQ measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short rsrqPath1[MAX_RX_CC_NUM_V2][10];

  /** The number of PDSCH decoding successfully.
   */
    unsigned int crcOK_cnt[MAX_RX_CC_NUM_V2];

  /** The number of PDSCH decoding fail.
   */
    unsigned int crcNG_cnt[MAX_RX_CC_NUM_V2];
} ERfTestCmdGetMixRxRpt_CaMode_V2;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetMixRxReport_CaMode_V2_r
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode_V2( const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt_CaMode_V2* resp );
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode_V2_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt_CaMode_V2* resp );
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_QueryCaConfigTableV2_r
 */
META_RESULT  __stdcall META_ERf_QueryCaConfigTableV2( const unsigned int ms_timeout, ERfTestCmdCaConfig_V2* resp);
/**
 * \ingroup LTE
 * \details To get ca config table from target
 * \param meta_handle meta handle
 * \param ms_timeout: time out in ms
 * \param resp RX ca usage table
 * \sa ERF_TEST_CMD_QUERY_CA_CONFIG_TABLE_V2
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_QueryCaConfigTableV2_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdCaConfig_V2* resp);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_FHC_CaModeV2_r
 */
META_RESULT  __stdcall META_ERf_FHC_CaModeV2( const ERf_FHC_V2_CaMode_Cmd* req, const unsigned int ms_timeout, ERf_FHC_V2_CaMode_Rpt* resp );
/**
 * \ingroup LTE
 * \details Command target to execute CA mode FHC arrangements and blocking until result returns
 * \param meta_handle meta handle
 * \param req CA mode FHC arrangements
 * \param ms_timeout time out in ms
 * \param resp RSSI results and PD values acquired from target
 * \sa ERF_TEST_CMD_START_FHC
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_FHC_CaModeV2_r( const int meta_handle, const ERf_FHC_V2_CaMode_Cmd* req, const unsigned int ms_timeout, ERf_FHC_V2_CaMode_Rpt* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetRxTxSetting_r
 */
META_RESULT  __stdcall META_ERf_GetRxTxSetting( const ERfTestCmdGetRxTxSettingReqParam_T* req, const unsigned int ms_timeout, ERfTestCmdRxTxSetting* resp );
/**
 * \ingroup LTE
 * \details Command target to execute reading TX and RX calibration data and blocking until result returns
 * \param meta_handle meta handle
 * \param req TX and RX route information
 * \param ms_timeout time out in ms
 * \param resp TX and RX calibration data acquired from target
 * \sa ERF_TEST_CMD_GET_RX_TX_SETTING_V2
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_GetRxTxSetting_r( const int meta_handle, const ERfTestCmdGetRxTxSettingReqParam_T* req, const unsigned int ms_timeout, ERfTestCmdRxTxSetting* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetRxTxSetting_r
 */
META_RESULT  __stdcall META_ERf_SetRxTxSetting( const bool update_to_nvram, const ERfTestCmdRxTxSetting* req, const unsigned int ms_timeout, ERfTestResultSetRxTxSettingCnfParam_T* resp );
/**
 * \ingroup LTE
 * \details Command target to execute writing TX and RX calibration data and blocking until result returns
 * \param meta_handle meta handle
 * \param req TX and RX calibration data
 * \param ms_timeout time out in ms
 * \sa ERF_TEST_CMD_SET_RX_TX_SETTING_V2
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_SetRxTxSetting_r( const int meta_handle, const bool update_to_nvram, const ERfTestCmdRxTxSetting* req, const unsigned int ms_timeout, ERfTestResultSetRxTxSettingCnfParam_T* resp );


/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_QueryCaConfigTableV3_r
 */
META_RESULT  __stdcall META_ERf_QueryCaConfigTableV3( const unsigned int ms_timeout, ERfTestCmdCaConfig_V3* resp);
/**
 * \ingroup LTE
 * \details To get CA config table from target
 * \param meta_handle meta handle
 * \param ms_timeout: time out in ms
 * \param resp CA config table
 * \sa ERF_TEST_CMD_QUERY_CA_CONFIG_TABLE_V3
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_QueryCaConfigTableV3_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdCaConfig_V3* resp);
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_FHC_CaModeV3
 */
META_RESULT  __stdcall META_ERf_FHC_CaModeV3( const ERfTestCmd_StartFhcV3_Req_T* req, const unsigned int ms_timeout, ERfTestCmd_StartFhcV3_Cnf_T* resp );
/**
 * \ingroup LTE
 * \details Command target to execute LTE FHC arrangements and blocking until result returns
 * \param [in] meta_handle meta handle
 * \param [in] req Parameters for triggering LTE FHC
 * \param [in] ms_timeout time out in ms
 * \param [out] resp RSSI results and detector reports acquired from target
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_FHC_CaModeV3_r( const int meta_handle, const ERfTestCmd_StartFhcV3_Req_T* req, const unsigned int ms_timeout, ERfTestCmd_StartFhcV3_Cnf_T* resp);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetRxTxSettingV3_r
 */
META_RESULT  __stdcall META_ERf_GetRxTxSettingV3( const ERfTestCmdGetRxTxSettingV3ReqParam_T* req, const unsigned int ms_timeout, ERfTestCmdRxTxSettingV3* resp );
/**
 * \ingroup LTE
 * \details Command target to execute reading TX and RX calibration data and blocking until result returns
 * \param meta_handle meta handle
 * \param req TX and RX route information
 * \param ms_timeout time out in ms
 * \param resp TX and RX calibration data acquired from target
 * \sa ERF_TEST_CMD_GET_RX_TX_SETTING_V3
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_GetRxTxSettingV3_r( const int meta_handle, const ERfTestCmdGetRxTxSettingV3ReqParam_T* req, const unsigned int ms_timeout, ERfTestCmdRxTxSettingV3* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetRxTxSettingV3_r
 */
META_RESULT  __stdcall META_ERf_SetRxTxSettingV3( const bool update_to_nvram, const ERfTestCmdRxTxSettingV3* req, const unsigned int ms_timeout, ERfTestResultSetRxTxSettingV3CnfParam_T* resp );

/**
 * \ingroup LTE
 * \details Command target to execute writing TX and RX calibration data and blocking until result returns
 * \param [in] meta_handle meta handle
 * \param [in] update_to_nvram Indicator to notify L1 driver whether the data needs to update to NVRAM or not
 * \param [in] req TX and RX calibration data to be updated to DUT
 * \param [in] ms_timeout time out in ms
 * \param [out] resp Status of updating TX and RX calibration data to DUT
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_SetRxTxSettingV3_r( const int meta_handle, const bool update_to_nvram, const ERfTestCmdRxTxSettingV3* req, const unsigned int ms_timeout, ERfTestResultSetRxTxSettingV3CnfParam_T* resp );

/**
 * \ingroup LTEStruct
 * This structure is the RX-TX parameters for normal mode.
 */
typedef struct
{
  /** Different mode setting for RX measurements. 0 is DL RX mode, and 2 is Pseudo TX-RX mode.
   */
   unsigned char                   mode;

  /** The setting to enable RX path 0. 0 is disable, and 1 is enable.
   */
   unsigned char                   rxPath0Enbl;

  /** The setting to enable RX path 1. 0 is disable, and 1 is enable.
   */
   unsigned char                   rxPath1Enbl;

  /** The number of cell for DL RX Measurement.
   */
   unsigned char                   numOfDlCC;

  /** The number of cell for UL TX Transmission.
   */
   unsigned char                   numOfUlCC;

  /** The RX-TX related parameters for each cell.
   */
   Mix_Rx_Dl_Ul_Ca_Normal_Mode_Param mix_rx_dl_ul_ca_normal_mode_param[MAX_RX_CC_NUM_V2];
}Mix_Rx_Dl_Ul_Ca_Normal_Mode_V3;

typedef struct
{
  /** The number of reporting measurement records. The range is from 0 to 10.
   */
   unsigned char            measCnt;

  /** The downlink bandwidth. 0 is 1.4 MHz (6 RB), 1 is 3 MHz (15 RB), 2 is 5 MHz (25 RB), 3 is 10 MHz (50 RB), 4 is 15 MHz (75 RB), and 5 is 20 MHz (100 RB).
   */
   unsigned char            measBandwidth;

  /** The operating downlink frequency. Unit is 100KHz.
   */
   unsigned short           dlFrequency;

  /** The operating band.
   */
   unsigned char            band;


  /** The duplex mode. 0 is TDD, and 1 is FDD.
   */
   unsigned char            duplexMode;

  /** The uplink-downlink configuration. Only valid if the range is 0~6 when TDD.
   */
   unsigned char            tddConfig;

  /** The special subframe configuration. Only valid if the range is 0~8 when TDD.
   */
   unsigned char            tddSfConfig;

  /** The uplink bandwidth. 0 is 1.4 MHz (6 RB), 1 is 3 MHz (15 RB), 2 is 5 MHz (25 RB), 3 is 10 MHz (50 RB), 4 is 15 MHz (75 RB), and 5 is 20 MHz (100 RB).
   */
   unsigned char            bandwidth;

  /** 0 is RX path 0 enabled and 1 is is RX path 0 disabled.
   */
   unsigned char            rxPath0Enbl;

  /** 0 is RX path 1 enabled and 1 is is RX path 1 disabled.
   */
   unsigned char            rxPath1Enbl;

  /** RX route index setting.
   */
   unsigned short           rxRoute;

  /** Route path seting selection. 0 is bypass path, and 1 is filter path.
   */
   unsigned short           routePathSel;

  /** Setting for high power mode & lower power mode. 0 is auto, 1 is high power mode, 2 is low power mode data, 3 is low power mode with low MCS, and 4 is low power mode with high MCS.
   */
   unsigned short           lpmHpmConf;

  /** The setting of uplink transmission allow.
   */
   bool                     hasUl;

  /** The operating uplink frequency. Unit is 100KHz.
   */
   unsigned short           ulFrequency;

  /** The value of transmission power. The format is S(8,8), which means the left 8-bit is signed integer and the right 8-bit is decimal.
   */
   unsigned short           txPowerValue;

  /** The start location of resource block. The range is from 0 to 99.
   */
   unsigned char            vrbStart;

  /** The length of resource block for transmission. The range is from 1 to 100.
   */
   unsigned char            vrbLength;

  /** The modulation and coding scheme. 0 is QPSK, 1 is 16 QAM, and 2 is 64 QAM.
   */
   unsigned char            mcsMode;

  /** TX route index setting.
   */
   unsigned short           txRoute;
}Mix_Rx_Tx_Force_Mode_V3;

/**
 * \ingroup LTEStruct
 * This union structure is the test setting parameters based on the operating mode choosed.
 */
typedef union
{
  /** The RX-TX parameters for normal mode.
   */
   Mix_Rx_Dl_Ul_Ca_Normal_Mode_V3   mix_rx_dl_ul_ca_normal_mode;

  /** The RX parameters for force mode.
   */
   Mix_Rx_Force_Mode               mix_rx_force_mode;

  /** The RX parameters for special pseudo Tx-RX force mode.
   */
   Mix_Rx_Tx_Force_Mode_V3         mix_rx_tx_force_mode;
} Mix_Rx_Dl_Ul_Ca_Mode_V3;

/**
 * \ingroup LTEStruct
 * This structure is the test setting parameters for LTE RX Measurements.
 */
typedef struct
{
  /** The operating mode. 0 is normal mode, and 1 is force mode, and 2 is force mode for special pseudo Tx-RX
   */
   unsigned char       opMode;

  /** The RX-TX parameters.
   */
   Mix_Rx_Dl_Ul_Ca_Mode_V3 MixRxCaModeV3Param;
} ERfTestCmdMixRx_CaMode_V3;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartMixRx_CaMode_V3_r
 */
META_RESULT __stdcall META_ERf_StartMixRx_CaMode_V3( const unsigned int ms_timeout, ERfTestCmdMixRx_CaMode_V3* req );
/**
 * \ingroup LTE
 * \details Command target to execute LTE RX measurements until result returns
 * \param [in] meta_handle meta handle
 * \param [in] ms_timeout time out in ms
 * \param [in] req parameters for triggering LTE RX measurements
 * \retval META_SUCCESS successful
 **/
META_RESULT __stdcall META_ERf_StartMixRx_CaMode_V3_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdMixRx_CaMode_V3* req);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetMixRxReport_CaMode_V3_r
 */
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode_V3( const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt_CaMode_V2* resp );
/**
 * \ingroup LTE
 * \details Command target to get LTE RX measurement results and PDSCH decoding results
 * \param [in] meta_handle meta handle
 * \param [in] ms_timeout time out in ms
 * \param [out] resp RX measurement results and PDSCH decoding results
 * \retval META_SUCCESS successful
 **/
META_RESULT __stdcall META_ERf_GetMixRxReport_CaMode_V3_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt_CaMode_V2* resp );

/***********************
 *     LTE TX NSFT
 ***********************/

/**
 * \ingroup LTEStruct
 * This structure is the parameters for the specific tx power configuration.
 */
typedef struct
{
  /** The maximum number of different transmission power level.
   */
#define MAX_NSFT_LIST_TX_PWR_STEP_NUM 8

  /** The number of different transmission power level. The range is from 0 to 8.
   */
    unsigned char    pwr_step_num;

  /** The target transmission power for each power level. The format is S(8,8), which means the left 8-bit is signed integer and the right 8-bit is decimal.
   */
    short            pwr_step_tx_power[MAX_NSFT_LIST_TX_PWR_STEP_NUM];

  /** The start location of resource block in each power level. The range is from 0 to 99.
   */
    unsigned char    pwr_step_VRB_strt[MAX_NSFT_LIST_TX_PWR_STEP_NUM];

  /** The length of resource block in each power level. The range is from 1 to 100.
   */
    unsigned char    pwr_step_VRB_len[MAX_NSFT_LIST_TX_PWR_STEP_NUM];
} ERf_NSFT_List_Tx_Specify_Pwr_Param;

/**
 * \ingroup LTEStruct
 * This structure is the parameters for the ramping transmission power configuration.
 */
typedef struct
{
  /** The first transmission power level in each tx route. The format is S(8,8), which means the left 8-bit is signed integer and the right 8-bit is decimal.
   */
    short            start_power;

  /** The transmission power ramping step. The format is S(8,8), which means the left 8-bit is signed integer and the right 8-bit is decimal.
   */
    short            pwr_step_value;

  /** The number of different transmission power level.
   */
    unsigned char    pwr_step_num;

  /** The start location of resource block for the first choice. The range is from 0 to 99.
   */
    unsigned char    pwr_step_VRB_strt_p1;

  /** The length of resource block for the first choice. The range is from 1 to 100.
   */
    unsigned char    pwr_step_VRB_len_p1;

  /** The start location of resource block for the second choice. The range is from 0 to 99.
   */
    unsigned char    pwr_step_VRB_strt_p2;

  /** The length of resource block for the second choice. The range is from 1 to 100.
   */
    unsigned char    pwr_step_VRB_len_p2;

  /** The step index to change the resource block parameters from the first choice to the second choice. 0 means it only uses the second choice.
   */
    unsigned char    step_for_change_tx_VRB;
} ERf_NSFT_List_Tx_Specify_Step_Param;
// NSFT TX frequency step setting
typedef struct
{
    unsigned short   ul_freq;///<100kHz unit
    unsigned char    ul_bw;///<0(1.4M)~5(20M)
    unsigned char    pwr_step_MCS_mode; ///<0:QPSK, 1:16QAM, 2:64QAM
    char             cmd_type;     ///<0: NSFT_List_Tx_Specify_Pwr_Param, 1: NSFT_List_Tx_Specify_Step_Param
    union
    {
        ERf_NSFT_List_Tx_Specify_Pwr_Param     specify_tx_pwr_cmd;
        ERf_NSFT_List_Tx_Specify_Step_Param    specify_pwr_step_cmd;
    };
} ERf_NSFT_List_Tx_Freq_Param;
// NSFT TX band step setting
typedef struct
{
    unsigned char    band_index;
    unsigned char    freq_num;
    unsigned short   dl_sync_freq;///<100kHz unit
#define MAX_NSFT_LIST_TX_FREQ_NUM 13
    ERf_NSFT_List_Tx_Freq_Param     freq_param[MAX_NSFT_LIST_TX_FREQ_NUM];
} ERf_NSFT_List_Tx_Band_Param;
// NSFT TX configure
typedef struct
{
    unsigned char    fdd_tx_step_width;///<ms unit
    unsigned char    tdd_tx_step_width;///<ms unit
    unsigned char    band_num;
#define MAX_NSFT_LIST_TX_BAND_NUM 10
    ERf_NSFT_List_Tx_Band_Param     band_param[MAX_NSFT_LIST_TX_BAND_NUM];
    short            freq_offst;///<range -32768~32767
    short            afc_dac;
    unsigned char    afc_data_type;///<0: calibration data, 1: from interface value
    unsigned char    close_loop_disable;
} ERf_NSFT_List_Tx_Cfg;

// NSFT TX command
typedef struct
{
    unsigned char           phy_cell_id;///<no used for single tone?
    unsigned char           fdd_band_start_index;
    unsigned char           fdd_band_end_index;
    unsigned char           tdd_band_start_index;
    unsigned char           tdd_band_end_index;
    unsigned char           fdd_to_tdd_switch_time;///<ms unit
    unsigned char           fdd_freq_switch_time;///<ms unit
    unsigned char           tdd_freq_switch_time;///<ms unit
    unsigned char           fdd_band_switch_time;///<ms unit
    unsigned char           tdd_band_switch_time;///<ms unit
    unsigned short          fdd_dl_sync_time;///<ms unit
    unsigned short          tdd_dl_sync_time;///<ms unit
    ERf_NSFT_List_Tx_Cfg    txCmd;
} ERf_NSFT_List_Cmd;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_Start_TxNsft_r
 */
META_RESULT  __stdcall META_ERf_Start_TxNsft( const ERf_NSFT_List_Cmd* req, const unsigned int ms_timeout, unsigned int* p_iTxNsftStatus );
/**
 * \ingroup LTE
 * \details Command target to execute TX NSFT arrangements and blocking until result returns
 * \param meta_handle meta handle
 * \param req TX NSFT arrangements
 * \param ms_timeout time out in ms
 * \param p_iTxNsftStatus: the pointer point to a space to store TX NSFT status
 * \sa ERF_TEST_CMD_START_NSFT_LIST
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_Start_TxNsft_r( const int meta_handle, const ERf_NSFT_List_Cmd* req, const unsigned int ms_timeout, unsigned int* p_iTxNsftStatus );
typedef struct
{
    unsigned short   ul_freq;///<100kHz unit
    unsigned char    ul_bw;///<0(1.4M)~5(20M)
    unsigned char    pwr_step_MCS_mode; ///<0:QPSK, 1:16QAM, 2:64QAM
    char             cmd_type;     ///<0: NSFT_List_Tx_Specify_Pwr_Param, 1: NSFT_List_Tx_Specify_Step_Param
    union
    {
        ERf_NSFT_List_Tx_Specify_Pwr_Param     specify_tx_pwr_cmd;
        ERf_NSFT_List_Tx_Specify_Step_Param    specify_pwr_step_cmd;
    };
    unsigned char    signal_path;  /// 0:normal path 1:hrm path 2: filter path
} ERf_NSFT_List_Tx_Freq_Ex_Param;
// NSFT TX band step setting
typedef struct
{
    unsigned char    band_index;
    unsigned char    freq_num;
    unsigned short   dl_sync_freq;///<100kHz unit
#define MAX_NSFT_LIST_TX_FREQ_NUM 13
    ERf_NSFT_List_Tx_Freq_Ex_Param     freq_param[MAX_NSFT_LIST_TX_FREQ_NUM];
} ERf_NSFT_List_Tx_Band_Ex_Param;
// NSFT TX configure
typedef struct
{
    unsigned char    fdd_tx_step_width;///<ms unit
    unsigned char    tdd_tx_step_width;///<ms unit
    unsigned char    band_num;
#define MAX_NSFT_LIST_TX_BAND_NUM 10
    ERf_NSFT_List_Tx_Band_Ex_Param     band_param[MAX_NSFT_LIST_TX_BAND_NUM];
    short            freq_offst;///<range -32768~32767
    short            afc_dac;
    unsigned char    afc_data_type;///<0: calibration data, 1: from interface value
    unsigned char    close_loop_disable;
} ERf_NSFT_List_Tx_Ex_Cfg;

// NSFT TX command
typedef struct
{
    unsigned char       phy_cell_id;///<no used for single tone?
    unsigned char       fdd_band_start_index;
    unsigned char       fdd_band_end_index;
    unsigned char       tdd_band_start_index;
    unsigned char       tdd_band_end_index;
    unsigned char       fdd_to_tdd_switch_time;///<ms unit
    unsigned char       fdd_freq_switch_time;///<ms unit
    unsigned char       tdd_freq_switch_time;///<ms unit
    unsigned char       fdd_band_switch_time;///<ms unit
    unsigned char       tdd_band_switch_time;///<ms unit
    unsigned short      fdd_dl_sync_time;///<ms unit
    unsigned short      tdd_dl_sync_time;///<ms unit
    ERf_NSFT_List_Tx_Ex_Cfg    txCmd;
} ERf_NSFT_List_Ex_Cmd;

 /**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_Start_TxNsftWithSignalPath
 */
META_RESULT  __stdcall META_ERf_Start_TxNsftWithSignalPath( const ERf_NSFT_List_Ex_Cmd* req, const unsigned int ms_timeout, unsigned int* p_iTxNsftStatus );

/**
 * \ingroup LTE
 * \details Command target to execute TX NSFT arrangements and blocking until result returns
 * \param [in] meta_handle meta handle
 * \param [in] req TX NSFT arrangements
 * \param [in] ms_timeout time out in ms
 * \param [in] p_iTxNsftStatus: the pointer point to a space to store TX NSFT status
 * \sa ERF_TEST_CMD_START_NSFT_LIST
 * \retval META_SUCCESS successful
 */
META_RESULT  __stdcall META_ERf_Start_TxNsftWithSignalPath_r( const int meta_handle, const ERf_NSFT_List_Ex_Cmd* req, const unsigned int ms_timeout, unsigned int* p_iTxNsftStatus );


/**
 * \ingroup LTEStruct
 * This structure is the parameters for each tx route configuration.
 */
typedef struct
{
  /** TX route index.
   */
    unsigned short  tx_route_idx;

  /** Route path setting selection.
   */
    unsigned short  routePathSel;
} ERf_NSFT_List_RxTx_Tx_Route_Info;
/**
 * \ingroup LTEStruct
 * This structure is the parameters for each frequency configuration.
 */
typedef struct
{
  /** The operating uplink frequency. Unit is 100KHz.
   */
    unsigned short ul_freq;

  /** The operating downlink frequency. Unit is 100KHz.
   */
    unsigned short dl_freq;

  /** The uplink bandwidth. 0 is 1.4 MHz (6 RB), 1 is 3 MHz (15 RB), 2 is 5 MHz (25 RB), 3 is 10 MHz (50 RB), 4 is 15 MHz (75 RB), and 5 is 20 MHz (100 RB).
   */
    unsigned char  ul_bw;

  /** The modulation and coding scheme. 0 is QPSK, 1 is 16 QAM, and 2 is 64 QAM.
   */
    unsigned char  pwr_step_MCS_mode;

  /** The type of transmission power level in one single frequency. 0 is for the specific transmission power configuration , and 1 is for the ramping transmission power configuration.
   */
    char           cmd_type;

    union
    {
  /** The parameters for the specific transmission power configuration.
   */
        ERf_NSFT_List_Tx_Specify_Pwr_Param     specify_tx_pwr_cmd;

  /** The parameters for the ramping transmission power configuration.
   */
        ERf_NSFT_List_Tx_Specify_Step_Param    specify_pwr_step_cmd;
    };
} ERf_NSFT_List_RxTx_Freq_Param;
/**
 * \ingroup LTEStruct
 * This structure is the RX-TX parameters for each frequency configuration.
 */
typedef struct
{
  /** The number of tx route.
   */
    unsigned short tx_route_num;

  /** The maximum number of tx route.
   */
#define MAX_NSFT_LIST_TX_ROUTE_NUM         8

  /** The parameters for each tx route configuration.
   */
    ERf_NSFT_List_RxTx_Tx_Route_Info tx_route_path_info[MAX_NSFT_LIST_TX_ROUTE_NUM];

  /** The number of rx route.
   */
    unsigned short rx_route_num;

  /** The maximum number of rx route.
   */
#define MAX_NSFT_LIST_RX_ROUTE_NUM         8

  /** RX route index.
   */
    unsigned short rx_route_idx[MAX_NSFT_LIST_RX_ROUTE_NUM];

  /** The number of different rx power level in one single rx route.
   */
    unsigned short rx_step_num;

  /** The maximum number of different rx power level in one single rx route.
   */
#define MAX_NSFT_LIST_RXTX_PWR_LEVEL_NUM   5

  /** The average number of measurement samples for one measurement report in each rx power level.
   */
    unsigned short rx_step_width[MAX_NSFT_LIST_RXTX_PWR_LEVEL_NUM];

  /** The parameters for each frequency configuration.
   */
    ERf_NSFT_List_RxTx_Freq_Param rxtx_freq_param;
} ERf_NSFT_List_RxTx_Freq;
/**
 * \ingroup LTEStruct
 * This structure is the RX-TX parameters for each band configuration.
 */
typedef struct
{
  /** The operating band index.
   */
    unsigned char  band_index;

  /** The first downlink frequency in the first band for synchronization.
   */
    unsigned short dl_sync_freq;

  /** The total frequency number in one single band for list test.
   */
    unsigned char  freq_num;

  /** The maximum frequency number in one single band for list test.
   */
#define MAX_NSFT_LIST_RXTX_FREQ_NUM        8

  /** The RX-TX parameters for each frequency configuration.
   */
    ERf_NSFT_List_RxTx_Freq freq_param[MAX_NSFT_LIST_RXTX_FREQ_NUM];
} ERf_NSFT_List_RxTx_Band_Param;
/**
 * \ingroup LTEStruct
 */
typedef struct
{
    unsigned char  fdd_tx_step_width;      //ms unit
    unsigned char  tdd_tx_step_width;      //ms unit
    unsigned short freq_offst;             //range -32768~32767
    unsigned short afc_dac;
    unsigned char  afc_data_type;          //0: calibration data, 1: from interface value
    unsigned char  close_loop_disable;
    unsigned char  band_num;
#define MAX_NSFT_LIST_RXTX_BAND_NUM        8
    ERf_NSFT_List_RxTx_Band_Param band_param[MAX_NSFT_LIST_RXTX_BAND_NUM];
} ERf_NSFT_List_RxTx_Cfg;
/**
 * \ingroup LTEStruct
 */
typedef struct
{
    unsigned char  op_mode;                 //0: only tx, 1: tx-rx list mode
    unsigned char  phy_cell_id;
    unsigned char  fdd_band_start_index;
    unsigned char  fdd_band_end_index;
    unsigned char  tdd_band_start_index;
    unsigned char  tdd_band_end_index;
    unsigned char  fdd_to_tdd_switch_time;  //ms unit
    unsigned char  fdd_freq_switch_time;    //ms unit
    unsigned char  tdd_freq_switch_time;    //ms unit
    unsigned char  fdd_band_switch_time;    //ms unit
    unsigned char  tdd_band_switch_time;    //ms unit
    unsigned short fdd_dl_sync_time;        //ms unit
    unsigned short tdd_dl_sync_time;        //ms unit
    ERf_NSFT_List_RxTx_Cfg rxtxCmd;
} ERf_NSFT_List_RxTx_Cmd;
/**
 * \ingroup LTEStruct
 * This structure is the results of rx measurements in each route.
 */
typedef struct
{
  /** The RSSI measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short          rssiPath0;

  /** The RSSI measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short          rssiPath1;

  /** The RSRP measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short          rsrpPath0;

  /** The RSRP measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short          rsrpPath1;

  /** The RSRQ measurement results in RX path 0. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short          rsrqPath0;

  /** The RSRQ measurement results in RX path 1. The format is S(9,7), which means the left 9-bit is signed integer and the right 7-bit is decimal.
   */
    short          rsrqPath1;

  /** The number of PDSCH decoding successfully.
   */
    unsigned short crcOK_cnt;

  /** The number of PDSCH decoding fail.
   */
    unsigned short crcNG_cnt;
} ERf_NSFT_List_Rx_Step_Rpt;
/**
 * \ingroup LTEStruct
 * This structure is the results of rx measurements in each frequency.
 */
typedef struct
{
  /** The rx route index which finished total rx measurements within this rx route.
   */
    unsigned char route_idx;

  /** The step number of rx measurements in one single rx route.
   */
    unsigned char rx_step_num;

  /** The maximum number of power level in each route.
   */
#define MAX_NSFT_LIST_RXTX_PWR_LEVEL_NUM   5

  /** The results of rx measurements in each route.
   */
    ERf_NSFT_List_Rx_Step_Rpt rx_step[MAX_NSFT_LIST_RXTX_PWR_LEVEL_NUM];
} ERf_NSFT_List_Rx_Route_Rpt;
/**
 * \ingroup LTEStruct
 * This structure is the results of rx measurements in each band.
 */
typedef struct
{
  /** The downlink frequency which finished total rx measurements within this downlink frequency. Unit is 100KHz.
   */
    unsigned char freq_idx;

  /** The number of rx route for rx measurements in one single frequency.
   */
    unsigned char rx_route_num;

  /** The maximum number of rx route in each frequency.
   */
#define MAX_NSFT_LIST_TX_ROUTE_NUM         8

  /** The results of rx measurements in each frequency.
   */
    ERf_NSFT_List_Rx_Route_Rpt rx_route[MAX_NSFT_LIST_RX_ROUTE_NUM];
} ERf_NSFT_List_Rx_Freq_Rpt;
/**
 * \ingroup LTEStruct
 * This structure is the total results of rx measurements in a test round.
 */
typedef struct
{
  /** The band index which finished total RX measurements within this band.
   */
    unsigned char band_idx;

  /** The number of frequency for RX measurements in one single band.
   */
    unsigned char freq_num;

  /** The maximum number of frequency in each band.
   */
#define MAX_NSFT_LIST_RXTX_FREQ_NUM       8

  /** The results of rx measurements in each band.
   */
    ERf_NSFT_List_Rx_Freq_Rpt freq[MAX_NSFT_LIST_RXTX_FREQ_NUM];
} ERf_NSFT_List_Rx_Band_Rpt;
/**
 * \ingroup LTEStruct
 * This structure is the RX-TX information when error occured.
 */
typedef struct
{
  /** The operating band index.
   */
    unsigned short bandIndex;

  /** The operating downlink frequency. Unit is 100KHz.
   */
    unsigned short dlFreq;

  /** The operating uplink frequency. Unit is 100KHz.
   */
    unsigned short ulFreq;

  /** The operating physical cell identity.
   */
    unsigned short pci;

  /** The count for re-synchronization if synchronization fails.
   */
    unsigned char  reSyncCnt;

  /** The enable status of rx path 0.
   */
    unsigned char  rxPath0Enbl;

  /** The enable status of rx path 1.
   */
    unsigned char  rxPath1Enbl;
} ERf_NSFT_List_Rx_Error_Rpt;
/**
 * \ingroup LTEStruct
 * This structure is the report command for TX (or RX-TX) NSFT list measurements.
 */
typedef struct
{
  /** The test status in the physical layer, which includes error status. 0 means no error occured.
   */
    unsigned int  status;

  /** The total band number for list test.
   */
    unsigned char band_num;

  /** The maximum band number for list test.
   */
#define MAX_NSFT_LIST_RXTX_BAND_NUM        8

  /** The total results of rx measurements in a test round.
   */
    ERf_NSFT_List_Rx_Band_Rpt  band[MAX_NSFT_LIST_RXTX_BAND_NUM];

  /** The RX-TX information when error occured.
   */
    ERf_NSFT_List_Rx_Error_Rpt error_report;
} ERf_NSFT_List_RxTx_Rpt;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_Start_TrxNsft_r
 */
META_RESULT  __stdcall META_ERf_Start_TrxNsft( const ERf_NSFT_List_RxTx_Cmd* req, const unsigned int ms_timeout, ERf_NSFT_List_RxTx_Rpt* resp );
/**
 * \ingroup LTE
 * \details Command target to execute TX NSFT arrangements and blocking until result returns
 * \param meta_handle meta handle
 * \param req TX NSFT arrangements
 * \param ms_timeout time out in ms
 * \sa ERF_TEST_CMD_START_NSFT_RXTX_LIST
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_Start_TrxNsft_r( const int meta_handle, const ERf_NSFT_List_RxTx_Cmd* req, const unsigned int ms_timeout, ERf_NSFT_List_RxTx_Rpt* resp );
/**
 * \ingroup LTEStruct
 * This structure is the RX-TX parameters for list scheduling.
 */
typedef struct
{
  /** Useless parameters.
   */
    short          freq_offst;

  /** The setting of tx close loop allow. 0 is enable transmission close loop, and 1 is disable transmission close loop.
   */
    unsigned char  close_loop_disable;

  /** The total band number for list test.
   */
    unsigned char  band_num;

  /** The maximum band number for list test.
   */
#define MAX_NSFT_LIST_RXTX_BAND_NUM        8

  /** The RX-TX parameters for each band configuration.
   */
    ERf_NSFT_List_RxTx_Band_Param band_param[MAX_NSFT_LIST_RXTX_BAND_NUM];
} ERf_NSFT_List_RxTx_V3_Cfg;
/**
 * \ingroup LTEStruct
 * This structure is the setting parameters for list scheduling.
 */
typedef struct
{
  /** The first FDD band index for TX list test.
   */
    unsigned char  fdd_band_start_index;

  /** The last FDD band index for TX list test.
   */
    unsigned char  fdd_band_end_index;

  /** The first TDD band index for TX list test.
   */
    unsigned char  tdd_band_start_index;

  /** The last TDD band index for TX list test.
   */
    unsigned char  tdd_band_end_index;

  /** The duration for synchronization when band switch under FDD or duplex mode changes from TDD to FDD. Only valid if the value is larger than 0. Unit is subframe(ms).
   */
    unsigned short fdd_dl_sync_time;

  /** The duration for synchronization when band switch under TDD or duplex mode changes from FDD to TDD. Only valid if the value is larger than 0. Unit is subframe(ms).
   */
    unsigned short tdd_dl_sync_time;

  /** The duration for synchronization when duplex mode change. Only valid if "fdd_dl_sync_time" is 0 under FDD or "tdd_dl_sync_time" is 0 under TDD. Unit is subframe(ms).
   */
    unsigned char  fdd_to_tdd_switch_time;

  /** The duration for frequency switch in one single FDD band. Unit is subframe(ms).
   */
    unsigned char  fdd_freq_switch_time;

  /** The duration for frequency switch in one single TDD band. Unit is subframe(ms).
   */
    unsigned char  tdd_freq_switch_time;

  /** The duration for configuration change when band switch under FDD. Only valid if "fdd_dl_sync_time" is 0. Unit is subframe(ms).
   */
    unsigned char  fdd_band_switch_time;

  /** The duration for configuration change when band switch under TDD. Only valid if "tdd_dl_sync_time" is 0. Unit is subframe(ms).
   */
    unsigned char  tdd_band_switch_time;

  /** The number of continuous PUSCH transmission with the same power level under FDD. Unit is subframe(ms).
   */
    unsigned char  fdd_tx_step_width;

  /** The number of continuous PUSCH transmission with the same power level under TDD. Unit is subframe(ms).
   */
    unsigned char  tdd_tx_step_width;

  /** Reserved parameter.
   */
    unsigned char  reserved;
} ERf_NSFT_List_RxTx_V3_scheduling_Setting;
/**
 * \ingroup LTEStruct
 * This structure is the request command for TX-RX NSFT list measurements.
 */
typedef struct
{
  /** The list mode selected. 0 is TX list mode, and 1 is TX-RX list mode.
   */
    unsigned char  op_mode;

  /** Physical cell identity. The range is from 0 to 503.
   */
    unsigned char  phy_cell_id;

  /** The setting parameters for list scheduling.
   */
    ERf_NSFT_List_RxTx_V3_scheduling_Setting  schdlSetting;

  /** The RX-TX parameters for list scheduling.
   */
    ERf_NSFT_List_RxTx_V3_Cfg                 rxtxCmd;
} ERf_NSFT_List_RxTx_V3_Cmd;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_Start_TrxNsftV3_r
 */
META_RESULT  __stdcall META_ERf_Start_TrxNsftV3( const ERf_NSFT_List_RxTx_V3_Cmd* req, const unsigned int ms_timeout, ERf_NSFT_List_RxTx_Rpt* resp );
/**
 * \ingroup LTE
 * \details Command target to execute TX-RX NSFT list arrangements and blocking until result returns
 * \param meta_handle meta handle
 * \param req TX-RX NSFT list arrangements
 * \param ms_timeout time out in ms
 * \param resp TX and RX measurement results acquired from target
 * \retval META_SUCCESS successful
 **/
META_RESULT  __stdcall META_ERf_Start_TrxNsftV3_r( const int meta_handle, const ERf_NSFT_List_RxTx_V3_Cmd* req, const unsigned int ms_timeout, ERf_NSFT_List_RxTx_Rpt* resp );

typedef META_Rf_TemperatureInfo_T META_ERf_TemperatureInfo_T;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetTemperatureInfo_r
 */
META_RESULT __stdcall META_ERf_GetTemperatureInfo(const unsigned int ms_timeout, META_ERf_TemperatureInfo_T* info);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetTemperatureInfo_r(const int meta_handle, const unsigned int ms_timeout, META_ERf_TemperatureInfo_T* info);


/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetRfChipIdName_r
 */
const char* __stdcall META_ERf_GetRfChipIdName(unsigned int id);
/**
 * \ingroup LTE
 * \details get the LTE RF chip ID name by given RF chip ID
 * \param meta_handle meta handle
 * \param id LTE RF chip ID
 * \return constant pointer to the RF chip ID name
 */
const char* __stdcall META_ERf_GetRfChipIdName_r( const int meta_handle, unsigned int id);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetPathFlag_r
 */
META_RESULT __stdcall META_ERf_SetPathFlag(const unsigned int ms_timeout);
 /**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_SetPathFlag_r(const int meta_handle, const unsigned int ms_timeout);
#define MAX_ERF_ET_NUM_BAND 14
#define MAX_ERF_ET_NUM_SUBBAND 8
#define MAX_ERF_ET_NUM_CBW 6
#define MAX_ERF_ET_NUM_VIN 33
typedef struct
{
    unsigned char band;
    unsigned char bandwidth;
    short txPower;
    unsigned short ulFrequency;
} ERfEtTxSetting;
typedef struct
{
    short output_vpa_voltage;
} ERfEtFdModeSetting;
typedef struct
{
    unsigned short mode; ///< ET:0 FD:1 Bypass:2
    short outer_gain;
    short input_offset_voltage;
    short main_sw_output_voltage;
    short aux_sw_output_voltage;
} ERfEtSpModeSetting;
typedef struct
{
    unsigned short et_mode; ///< ET:0 FD:1 static performance mode:2
    ERfEtTxSetting tx_setting;
    ERfEtFdModeSetting fd_mode_setting;
    ERfEtSpModeSetting sp_mode_setting;
} ERfEtModeSetting;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetEtMode_r
 */
META_RESULT __stdcall META_ERf_SetEtMode(ERfEtModeSetting* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_SetEtMode_r(const int meta_handle, ERfEtModeSetting* req , const unsigned int ms_timeout);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartEtCal_r
 */
META_RESULT __stdcall META_ERf_StartEtCal(const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_StartEtCal_r(const int meta_handle, const unsigned int ms_timeout);
typedef struct
{
    unsigned short VinVpaLut[MAX_ERF_ET_NUM_SUBBAND][MAX_ERF_ET_NUM_VIN];
    short          VinPmLut[MAX_ERF_ET_NUM_SUBBAND][MAX_ERF_ET_NUM_VIN];
    short          VinAmLut[MAX_ERF_ET_NUM_SUBBAND][MAX_ERF_ET_NUM_VIN];
    short          PathDelay[MAX_ERF_ET_NUM_SUBBAND][MAX_ERF_ET_NUM_CBW];
    short          Pout_max[MAX_ERF_ET_NUM_SUBBAND];
    short          Pout_gain_offset[MAX_ERF_ET_NUM_SUBBAND];
    unsigned short GainComp_0p5_dB;
    unsigned short GainComp_0p5_dB_delta;
    unsigned short PathDelayOffsetByTemp[MAX_ERF_ET_NUM_SUBBAND][MAX_ERF_ET_NUM_CBW];
    short          GrpDlyOfstBySubband[MAX_ERF_ET_NUM_SUBBAND][MAX_ERF_ET_NUM_CBW];
    unsigned short VpaTargetStep2;
    unsigned short SmpValStep2Sec1;
    short          PaGainAdjustStep1;
    unsigned int   PowThrdStep2;
} ERfEtCalSetting;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetEtCalSetting_r
 */
META_RESULT __stdcall META_ERf_GetEtCalSetting(const unsigned short bandIdx, const unsigned int ms_timeout, ERfEtCalSetting* etCalSetting);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetEtCalSetting_r(const int meta_handle, const unsigned short bandIdx, const unsigned int ms_timeout, ERfEtCalSetting* etCalSetting);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetEtCalSetting_r
 */
META_RESULT __stdcall META_ERf_SetEtCalSetting(const unsigned short bandIdx, const ERfEtCalSetting* etCalSetting, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_SetEtCalSetting_r(const int meta_handle, const unsigned short bandIdx, const ERfEtCalSetting* etCalSetting, const unsigned int ms_timeout);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetToolUsage_r
 */
META_RESULT __stdcall META_ERf_SetToolUsage(const unsigned short tool_usage, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \details set the tool usage mode for L1
 * \param meta_handle meta handle
 * \param tool_usage 1:Normal mode 2:Calibration mode 3: ET Calibration mode
 * \param ms_timeout time out in ms
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_SetToolUsage_r(const int meta_handle, const unsigned short tool_usage, const unsigned int ms_timeout);
typedef struct
{
    unsigned short  CmdType;
    unsigned char   BandIndex;
} ERfNVRAMInfoReq;
typedef struct
{
    unsigned short LID;    // Logical data item ID of a EF
    unsigned short RID;    // Record ID (the first record is 1)
} ERfNVRAMInfoElement;
typedef struct
{
    unsigned char        item_count;    // Query result count
    unsigned char        status;       // 0: read ok; others: read failed.
    ERfNVRAMInfoElement   nvramElement[255];
} ERfNVRAMInfoCnf;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_QueryNVRAMInfo_r
 */
META_RESULT __stdcall META_ERf_QueryNVRAMInfo(const ERfNVRAMInfoReq* req, const unsigned int ms_timeout, ERfNVRAMInfoCnf* cnf);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_QueryNVRAMInfo_r(const int meta_handle, const ERfNVRAMInfoReq* req, const unsigned int ms_timeout, ERfNVRAMInfoCnf* cnf);
typedef struct
{
    int C0;
    int C1;
    int initU;
    int lastU;
} ERfCoTmsData;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetCoTmsData_r
 */
META_RESULT __stdcall META_ERf_GetCoTmsData(const unsigned int ms_timeout, ERfCoTmsData* cnf);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetCoTmsData_r(const int meta_handle, const unsigned int ms_timeout, ERfCoTmsData* cnf);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetCoTmsData_r
 */
META_RESULT __stdcall META_ERf_SetCoTmsData(const ERfCoTmsData* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_SetCoTmsData_r(const int meta_handle, const ERfCoTmsData* req, const unsigned int ms_timeout);
typedef struct
{
    unsigned int   EtCalDoneFlag   [MAX_ERF_ET_NUM_BAND];    /*to check if FHC/ETK done already*/
    unsigned short Band            [MAX_ERF_ET_NUM_BAND];    /*band indicator*/
    unsigned short SubbandFreq     [MAX_ERF_ET_NUM_BAND][MAX_ERF_ET_NUM_SUBBAND]; /*subband frequency*/
} ERfTestCmdEtPathDelayCheckResult;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetEtPathDelayCheckResult_r
 */
META_RESULT __stdcall META_ERf_GetEtPathDelayCheckResult(const unsigned int ms_timeout, ERfTestCmdEtPathDelayCheckResult* cnf);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_GetEtPathDelayCheckResult_r(const int meta_handle, const unsigned int ms_timeout, ERfTestCmdEtPathDelayCheckResult* cnf);
typedef struct
{
    unsigned short Band;
    unsigned short SubbandFreq;
    unsigned short CbwIdx;
    short          Offset;
} ERfTestCmdEtPathDelayStartSetting;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_StartEtPathDelaySearch_r
 */
META_RESULT __stdcall META_ERf_StartEtPathDelaySearch(const ERfTestCmdEtPathDelayStartSetting* req, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT __stdcall META_ERf_StartEtPathDelaySearch_r(const int meta_handle, const ERfTestCmdEtPathDelayStartSetting* req, const unsigned int ms_timeout);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetFilterModeTpcSetting
 */
META_RESULT  __stdcall META_ERf_GetFilterModeTpcSetting( unsigned char band,  const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_GetFilterModeTpcSetting_r( const int meta_handle, unsigned char band,  const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetFilterModeTpcSetting
 */
META_RESULT  __stdcall META_ERf_SetFilterModeTpcSetting( unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_SetFilterModeTpcSetting_r( const int meta_handle, unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetHrmFlag_r
 */
META_RESULT __stdcall META_ERf_SetHrmFlag(const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
 META_RESULT __stdcall META_ERf_SetHrmFlag_r(const int meta_handle, const unsigned int ms_timeout);
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetHrmTpcSetting
 */
META_RESULT  __stdcall META_ERf_GetHrmTpcSetting( unsigned char band, const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_GetHrmTpcSetting_r( const int meta_handle, unsigned char band, const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetHrmTpcSetting
 */
META_RESULT  __stdcall META_ERf_SetHrmTpcSetting( unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );
/**
 * \ingroup LTE
 * \brief ToBeDo
 */
META_RESULT  __stdcall META_ERf_SetHrmTpcSetting_r( const int meta_handle, unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );

typedef struct
{
   unsigned char tas_idx;
} ERfTestCmdTasCfg;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_ForceTasSwitch_r
 */
META_RESULT __stdcall META_ERf_ForceTasSwitch(const unsigned int ms_timeout, const ERfTestCmdTasCfg* req);

/**
 * \ingroup LTE
 * \details Configure DPDT switch mode
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req DPDT switch configuration
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_ForceTasSwitch_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdTasCfg* req);
typedef enum
{
    ERF_TEST_ANT_SEL_0,     ///< Select antenna 0 only main.
    ERF_TEST_ANT_SEL_1,     ///< Select antenna 1 only diversity.
    ERF_TEST_ANT_SEL_01     ///< Select antenna 0 & 1 both.
} ERfTestAntSel;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetRxAntenna_r
 */
META_RESULT __stdcall META_ERf_SetRxAntenna(const unsigned int ms_timeout, const ERfTestAntSel* req);
/**
 * \ingroup LTE
 * \details set LTE Rx path antenna type
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req antenna type configuration
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_SetRxAntenna_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestAntSel* req);

typedef struct
{
    unsigned int  auxadc_temp;
} ERfResultTempAuxAdc;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_QueryAuxAdc_r
 */
META_RESULT __stdcall META_ERf_QueryTempAuxAdc(const unsigned int ms_timeout, const ERfResultTempAuxAdc* cnf);
/**
 * \ingroup LTE
 * \details Query Temp AuxADC from target
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param cnf the result of AuxADC
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_QueryTempAuxAdc_r(const int meta_handle, const unsigned int ms_timeout, const ERfResultTempAuxAdc* cnf);

#define      MAX_LTE_AFC_USED_CAPID_ARRAY    32
typedef struct
{
   unsigned short   band;
   unsigned short   ulFrequency;
   short              txPowerValue;
} ERfTestCmd_FhcAfcTxCal_ReqParam;
typedef struct
{
   unsigned short   used_cap_id_array [MAX_LTE_AFC_USED_CAPID_ARRAY];
} ERfTestCmd_FhcAfcTxCal_CnfParam;
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_FhcAfcTxCal_r
 */
META_RESULT __stdcall META_ERf_FhcAfcTxCal(const unsigned int ms_timeout, const ERfTestCmd_FhcAfcTxCal_ReqParam* req, const ERfTestCmd_FhcAfcTxCal_CnfParam* cnf);
/**
 * \ingroup LTE
 * \details     Fast AFC calibration by TX
 * \param       meta_handle     meta handle
 * \param       ms_timeout      time out in ms
 * \param       req             AFC configuration
 * \param[out]  cnf             used cap_id array
 * \retval      META_SUCCESS    Successful
 */
META_RESULT __stdcall META_ERf_FhcAfcTxCal_r(const int meta_handle, const unsigned int ms_timeout, const ERfTestCmd_FhcAfcTxCal_ReqParam* req, const ERfTestCmd_FhcAfcTxCal_CnfParam* cnf);
/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_UbinModeSetup_r
 */
META_RESULT __stdcall META_ERf_UbinModeSetup(unsigned int ms_timeout, const unsigned char ubin_lte_mode_init);//  1 : UBIN mode Init LTE ,      0 : UBIN mode de-init LTE
/**
 * \ingroup LTE
 * \details intialize UBIN to target
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param ubin_lte_mode_init init parameter 1: init 0: de-init
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_UbinModeSetup_r(const int meta_handle, unsigned int ms_timeout, const unsigned char ubin_lte_mode_init);

typedef struct
{
   unsigned short band;
   short          powerOffset;   
   bool           updateToNvram;
} ERfTestCmdSetTxPowerOffsetAdjustmentReq; 

typedef struct
{
   unsigned short band;
} ERfTestCmdGetTxPowerOffsetAdjustmentReq; 

typedef struct
{
   unsigned short band;
   short          powerOffset;   
} ERfTestCmdGetTxPowerOffsetAdjustmentCnf; 

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetNsftTxPowerOffset_r
 */
META_RESULT __stdcall META_ERf_SetNsftTxPowerOffset(unsigned int ms_timeout, const ERfTestCmdSetTxPowerOffsetAdjustmentReq* req);
/**
 * \ingroup LTE
 * \details set tx power adjustment offset to target
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req parameters include set band and power offset
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_SetNsftTxPowerOffset_r(const int meta_handle, unsigned int ms_timeout, const ERfTestCmdSetTxPowerOffsetAdjustmentReq* req);

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetNsftTxPowerOffset_r
 */
META_RESULT __stdcall META_ERf_GetNsftTxPowerOffset(unsigned int ms_timeout, const ERfTestCmdGetTxPowerOffsetAdjustmentReq* req, ERfTestCmdGetTxPowerOffsetAdjustmentCnf* cnf);
/**
 * \ingroup LTE
 * \details Get tx power adjustment offset from target
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req parameters include the queried band
 * \param cnf parameters include result of band and power offset
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_GetNsftTxPowerOffset_r(const int meta_handle, unsigned int ms_timeout, const ERfTestCmdGetTxPowerOffsetAdjustmentReq* req, ERfTestCmdGetTxPowerOffsetAdjustmentCnf* cnf);

 /**
 * \ingroup LTEStruct
 * \details This structure is used to update TX configuration during PUSCH TX
 */
typedef struct
{
   unsigned char    chg_bitmap;     /**< Item bitmap, b0: txRoute, b1:txPowerValue, b2: vrbStart+vrbLength; b3: mcsMode. */
   unsigned short   txRoute;        /**< TX route number. */
   short            txPowerValue;   /**< TX power, with format S(8,8). */
   unsigned char    vrbStart;       /**< . */
   unsigned char    vrbLength;      /**< . */
   unsigned char    mcsMode;        /**< MCS mode, 0: QPSK, 1: 16QAM, 2: 64QAM, 3: 256QAM. */
} ERfTestCmdTxCfgUpdt;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_TxCfgUpdate_r
 */
META_RESULT __stdcall META_ERf_TxCfgUpdate(unsigned int ms_timeout, const ERfTestCmdTxCfgUpdt* req);
/**
 * \ingroup LTE
 * \details Update TX configuration during PUSCH TX, which can save sync time in traditional NSFT flow
 * \param   meta_handle             meta handle
 * \param   ms_timeout              time out in ms
 * \param   req                     TX configuration that want to set
 * \retval  META_SUCCESS            Successful
 * \retval  META_TIMEOUT            DUT not responding, DUT may be in exception state
 * \retval  META_INVALID_ARGUMENTS  Invalid argument, "req" pointer may be NULL
 * \retval  META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_TxCfgUpdate_r(const int meta_handle, unsigned int ms_timeout, const ERfTestCmdTxCfgUpdt* req);

 /**
 * \ingroup LTEStruct
 * \details This structure is the partial band information of each route
 */
typedef struct
{
    unsigned short    band;         /**< LTE band number (spec. defined). */
    unsigned short    comp_route;   /**< Route number. */
    unsigned short    start_freq;   /**< Supported lower bond frequency. */
    unsigned short    end_freq;     /**< Supported upper bond frequency. */
} ERfPartialBandRouteInfo;

 /**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of query LTE partial band command since M50 series
 */
typedef struct
{
#define ERF_MAX_PARTIAL_ROUTE_NUM 64
    unsigned short           RxPartialRouteNumber;                      /**< Number of partial band RX routes. */
    unsigned short           TxPartialRouteNumber;                      /**< Number of partial band TX routes. */
    ERfPartialBandRouteInfo  RxRouteInfo[ERF_MAX_PARTIAL_ROUTE_NUM];    /**< Information of each partial band RX route. */
    ERfPartialBandRouteInfo  TxRouteInfo[ERF_MAX_PARTIAL_ROUTE_NUM];    /**< Information of each partial band TX route. */
} ERfTestResultPartialBandInfo;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetPartialBandInfo_r
 */
META_RESULT __stdcall META_ERf_GetPartialBandInfo(unsigned int ms_timeout, ERfTestResultPartialBandInfo* cnf);
/**
 * \ingroup LTE
 * \details Query partial band information from target
 * \param   meta_handle             meta handle
 * \param   ms_timeout              time out in ms
 * \param   cnf                     confirm message of partial band information
 * \retval  META_SUCCESS            Successful
 * \retval  META_TIMEOUT            DUT not responding, DUT may be in exception state
 * \retval  META_INVALID_ARGUMENTS  Invalid argument, "cnf" pointer may be NULL
 * \retval  META_COMM_FAIL          Send request fail, connection may be broken
 */
META_RESULT __stdcall META_ERf_GetPartialBandInfo_r(const int meta_handle, unsigned int ms_timeout, ERfTestResultPartialBandInfo* cnf);

/******************* General Define ******************/

#define ERF_TEST_LTE_MIPI_SUBBAND_NUM_PER_DATA 5
#define ERF_TEST_ET_MIPI_SUBBAND_NUM_PER_DATA  8

#define ERF_TEST_LTE_MIPI_TPC_SECTION_NUM     (8+1)
#define ERF_TEST_LTE_ET_MIPI_TPC_SECTION_NUM   2
#define ERF_TEST_LTE_MIPI_TPC_SECTION_DATA_NUM 5
#define ERF_MAX_PA_DATA_ACCESS_NUM            27

typedef 	enum
{
    ERF_MIPI_TPC_PROC		      = 0,		
    ERF_MIPI_TPC_ET_PROC		  = 1,
    ERF_MIPI_TPC_DPD_PROC		  = 2,
    ERF_MIPI_TPC_PROC_CONFIG_CNT    ,	
    ERF_MIPI_TPC_PROC_END		  = 0xFFFF, /* Let this enum to be 16 bits */
} ERF_TEST_MIPI_TPC_CONFIG_PROC_E;


/*******************************************************************************
 * ERF_TEST_CMD_GET_PA_MIPI_DATA
 ******************************************************************************/
typedef struct
{ 
   unsigned short mipi_config;
   unsigned short feRouteCount;
   unsigned short mipi_fe_route_idx[ERF_MAX_PA_DATA_ACCESS_NUM];
} ERfTestCmdGetPaMipiDataReq;

typedef struct
{
   unsigned short mipi_addr;
   unsigned short mipi_data;
} ERfTest_LTE_MIPI_adda_DATA_EXPAND_TABLE_T;

typedef struct
{
   ERfTest_LTE_MIPI_adda_DATA_EXPAND_TABLE_T  mipi_tpc_sec_data[ERF_TEST_LTE_MIPI_TPC_SECTION_DATA_NUM];
} ERfTest_LTE_MIPI_TPC_SECTION_DATA_T;

typedef struct
{
    unsigned short                    mipi_subband_freq;
    unsigned short                    mipi_usid;
    ERfTest_LTE_MIPI_TPC_SECTION_DATA_T mipi_tpc_section_table[ERF_TEST_LTE_MIPI_TPC_SECTION_NUM];
} ERfTest_LTE_MIPI_TPC_SECTION_TABLE_T;

typedef struct
{    
    ERfTest_LTE_MIPI_TPC_SECTION_TABLE_T    single_carrier[ERF_TEST_LTE_MIPI_SUBBAND_NUM_PER_DATA];
    ERfTest_LTE_MIPI_TPC_SECTION_TABLE_T    cca[ERF_TEST_LTE_MIPI_SUBBAND_NUM_PER_DATA];
} ERfTest_LTE_MIPI_FEROUTE_SECTION_T;

typedef struct
{
    unsigned short                    mipi_subband_freq;
    unsigned short                    mipi_usid;
    ERfTest_LTE_MIPI_TPC_SECTION_DATA_T mipi_tpc_section_table[ERF_TEST_LTE_ET_MIPI_TPC_SECTION_NUM];
} ERfTest_LTE_ET_MIPI_TPC_SECTION_TABLE_T;

typedef struct
{    
    ERfTest_LTE_ET_MIPI_TPC_SECTION_TABLE_T    single_carrier[ERF_TEST_ET_MIPI_SUBBAND_NUM_PER_DATA];
    ERfTest_LTE_ET_MIPI_TPC_SECTION_TABLE_T    cca[ERF_TEST_ET_MIPI_SUBBAND_NUM_PER_DATA];
} ERfTest_LTE_ET_MIPI_FEROUTE_SECTION_T;

typedef union
{ 
    ERfTest_LTE_ET_MIPI_FEROUTE_SECTION_T  lte_et_mipi_tpc_sec_table[ERF_MAX_PA_DATA_ACCESS_NUM];
    ERfTest_LTE_MIPI_FEROUTE_SECTION_T     lte_mipi_tpc_sec_table[ERF_MAX_PA_DATA_ACCESS_NUM];
} ERfTestCmdGetPaMipiDataCnf, ERfTestCmdPaMipiData;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetPaMipiData_r
 */
META_RESULT __stdcall META_ERf_GetPaMipiData(unsigned int ms_timeout, const ERfTestCmdGetPaMipiDataReq* req, ERfTestCmdGetPaMipiDataCnf* cnf);
/**
 * \ingroup LTE
 * \details get pa mipi data from DUT.
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req parameters include which route/tpc config to get the information.
 * \param cnf parameters include the PA bias information for the route/ tpc config.
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_GetPaMipiData_r(const int meta_handle, unsigned int ms_timeout, const ERfTestCmdGetPaMipiDataReq* req, ERfTestCmdGetPaMipiDataCnf* cnf);

/*******************************************************************************
 * ERF_TEST_CMD_SET_PA_MIPI_DATA
 ******************************************************************************/

typedef struct
{
   unsigned short mipi_config;
   unsigned short feRouteCount;
   unsigned short mipi_fe_route_idx[ERF_MAX_PA_DATA_ACCESS_NUM];
   ERfTestCmdPaMipiData mipiTable;
} ERfTestCmdSetPaMipiDataReq;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_SetPaMipiData_r
 */
META_RESULT __stdcall META_ERf_SetPaMipiData(unsigned int ms_timeout, const ERfTestCmdSetPaMipiDataReq* req);
/**
 * \ingroup LTE
 * \details set pa mipi data to DUT.
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req parameters include route/tpc config and corresponding PA Bias data.
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_SetPaMipiData_r(const int meta_handle, unsigned int ms_timeout, const ERfTestCmdSetPaMipiDataReq* req);

#define	ERF_MAX_PA_BIAS_TX_ROUTE_NUM  6

typedef struct
{
    unsigned short  	feRoute;
    unsigned char      normalRouteSupportBitmap; // Bit0: APT, Bit1: ET, Bit2: DPD
    unsigned char      ccaRouteSupportBitmap;   // Bit0: APT, Bit1: ET, Bit2: DPD
    unsigned short  	compRouteCount;
    unsigned short  	compRouteList[ERF_MAX_PA_BIAS_TX_ROUTE_NUM];
} ERfPaBiasRouteInfo;

typedef struct
{
    unsigned short     band;
    unsigned short     feRouteCount;
    ERfPaBiasRouteInfo feRouteTable[ERF_MAX_PA_BIAS_TX_ROUTE_NUM];
} ERfPaBiasBandInfo;

typedef struct
{
    unsigned short     bandCount;
    ERfPaBiasBandInfo  bandInfo[ERF_MAX_BAND_NUM_V3];
} ERfTestCmdGetPaBiasBandInfoCnf;

/**
 * \ingroup LTE
 * \sa non-reentrant version of META_ERf_GetPaBiasBandInfo_r
 */
META_RESULT __stdcall META_ERf_GetPaBiasBandInfo(unsigned int ms_timeout, ERfTestCmdGetPaBiasBandInfoCnf* cnf);
/**
 * \ingroup LTE
 * \details get pa bias band and route information from DUT.
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param cnf parameters include the PA bias information for band and route.
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_ERf_GetPaBiasBandInfo_r(const int meta_handle, unsigned int ms_timeout, ERfTestCmdGetPaBiasBandInfoCnf* cnf);
#endif /* __META_LTE__ */

#define MMRF_GSM_RAT_INDEX      (1 << 0)
#define MMRF_TDSCDMA_RAT_INDEX  (1 << 1)
#define MMRF_C2K_RAT_INDEX      (1 << 2)
#define MMRF_WCDMA_RAT_INDEX    (1 << 3)
#define MMRF_LTE_TDD_RAT_INDEX  (1 << 4)
#define MMRF_LTE_FDD_RAT_INDEX  (1 << 5)
typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} MMRfTestCmdRfCapabilityReq;
typedef struct
{
    unsigned int    reserved;
} MMRfCapabilityItemSet;
typedef struct
{
    unsigned int    is_capable  : 1;
    unsigned int    is_mandatory: 1;
    unsigned int    parameter   : 30;
} MMRfCalibrationItem;
typedef struct
{
    unsigned int    is_capable      : 1;
    unsigned int    is_mandatory    : 1;
    unsigned int    on_pmic         : 1;
    unsigned int    xtal_type       : 3;
    unsigned int    afc_origin_dac  : 16;
    unsigned int    reserve         : 10;
} MMRfTestXtalInfo;
typedef struct
{
    unsigned int    is_capable  : 1;
    unsigned int    is_mandatory: 1;
    unsigned int    version     : 8;
    unsigned int    t0          : 16;
    unsigned int    reserve     : 6;
} MMRfTestCoTmsCal;
typedef struct
{
    MMRfCalibrationItem    ratmap_cal_result_share_tadc;       /**< [0] bitmap for Multi-RAT to share TADC calibration result;parameter (0|0|C|Lf|Lt|T|W|G) */
    MMRfCalibrationItem    ratmap_cal_result_share_afc;        /**< [1] bitmap for Multi-RAT to share AFC calibration result ;parameter (0|0|C|Lf|Lt|T|W|G) */
    MMRfCalibrationItem    ratmap_support_RfSelf_cal;          /**< [2] bitmap for Multi-RAT to support Rf-Self cal.         ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    ratmap_support_RfSelf_cal_v2;       /**< [3] bitmap for Multi-RAT to support Rf-Self V2 cal.      ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    ratmap_support_dpd_cal;             /**< [4] bitmap for Multi-RAT to support DPD cal.             ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    ratmap_support_cim3_cal;            /**< [5] bitmap for Multi-RAT to support CIM3 cal.            ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    ratmap_support_et_cal;              /**< [6] bitmap for Multi-RAT to support ET cal.              ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    ratmap_support_TAS;                 /**< [7] bitmap for Multi-RAT to support TAS.                 ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    ratmap_support_WM;                  /**< [8] bitmap for Multi-RAT to world mode ID.               ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    ratmap_support_tool_usage;          /**< [9] bitmap for Multi-RAT to tool usage.                  ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    support_query_temp_info;            /**< [10] query temperature DAC af temperature info.          ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    support_query_vpa_voltage_list;     /**< [11] query vpa voltage list.                                                            */
    MMRfCalibrationItem    support_RfSelf_test_analyzer;       /**< [12] Indicate whether "self test analyzer" is supported or not                          */
    MMRfCalibrationItem    support_et_cal_capability;          /**< [13] query max et route num, 0: 301, 1: 522                                             */
    MMRfCalibrationItem    support_mmrf_afc_nvram;             /**< [14] query if support MMRF AFC NVRAM or not.                                            */
    MMRfCalibrationItem    ratmap_support_querying_tas_cfg;    /**< [15] query tas cfg/info                                  ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    support_force_trad_cal_apt;         /**< [16] query foced trad. k into apt mode info.                                            */
    MMRfCalibrationItem    ratmap_support_RfPostSelf_cal;      /**< [17] bitmap for Multi-RAT to support post Rf-Self cal.   ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    support_et_pa_labk_capability;      /**< [18] Indicate whether "reporting ET PA parameters labk capability" is supported or not  */
    MMRfCalibrationItem    support_query_tms_data_status;      /**< [19] Indicates "querying TMS cal data status API" is supported or not                   */
    MMRfCalibrationItem    support_mmtst_record_for_cddc;      /**< [20] Indicates whether MMTST supports "add NVRAM record for CDDC" or not                */
    MMRfCalibrationItem    support_set_apt_pa_setting;         /**< [21] Indicates whether "set PA settings for APT mode" is supported or not ;parameter (0|0|Lf|Lt|W|C|T|G) */
    MMRfCalibrationItem    support_32kless;                    /**< [22] Indicates support 32kless or not */
    MMRfTestXtalInfo       xtal_info;                          /**< [23] Indicates x-tal type & live in PMIC or not */
    MMRfCalibrationItem    support_mm_cotms_setget;            /**< [24] query supported mm tms set get mechanism */
    MMRfTestCoTmsCal       support_mm_cotms_cal;               /**< [25] query supported mm tms calibration mechanism */
    MMRfCalibrationItem    support_mipi_cw_setget;             /**< [26] query supported mipi cw set get and return mipi */
    MMRfCalibrationItem    support_mm_cmr_info;                /**< [27] query supported car-kit maaping report */
    MMRfCalibrationItem    support_RfSelf_cal_v7;              /**< [28] query supported RfSelf cal v7 */
    MMRfCalibrationItem    support_checksum_verify;            /**< [29] query supported cal data checksum check or not */
    MMRfCalibrationItem    support_query_utas_cfg;             /**< [30] query supported UTAS configuration */
    MMRfCalibrationItem    en_used_cc_num_info;                /**< [31] indicates LTE & NR used TX & RX CC num */
    MMRfCalibrationItem    support_check_mipi_component;       /**< [32] check MIPI component supports or not*/
} MMRfCalibrationItemSet;

typedef struct
{
    int                     valid;
    int                     status;
    MMRfCapabilityItemSet   capabilityItems;
    MMRfCalibrationItemSet  calibrationItems;
} MMRfTestCmdRfCapabilityCnf;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetRfCapability_r
 */
META_RESULT __stdcall META_MMRf_GetRfCapability( const unsigned int ms_timeout, const MMRfTestCmdRfCapabilityReq* req, const unsigned int requestLength, MMRfTestCmdRfCapabilityCnf* resp, const unsigned int responseLength );
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetRfCapability_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdRfCapabilityReq* req, const unsigned int requestLength, MMRfTestCmdRfCapabilityCnf* resp, const unsigned int responseLength );
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
} MMRfTestCmdDpdFacStartReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdFacCal_r
 */
META_RESULT __stdcall META_MMRf_StartDpdFacCal( const unsigned int ms_timeout, const MMRfTestCmdDpdFacStartReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartDpdFacCal_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdDpdFacStartReq* req);
#define MMRF_MAX_BAND_NUM               21
#define MAX_FHC_TX_FREQ_NUM_EX          15
#define MAX_DPD_AM_LUT_GAIN_NUM          8 /*  8 PA*PGA gain combination */
#define MAX_DPD_AM_LUT_ACTUAL_PWR_NUM   32 /* 32 power level */
#define MAX_DPD_PM_LUT_GAIN_NUM          8 /*  8 PA*PGA gain combination */
#define MAX_DPD_PM_LUT_ACTUAL_PWR_NUM   32 /* 32 power level */
#define MAX_LTE_CBW_NUM                  6  /* 6 CBW: 1.4M, 3M, 5M, 10M, 15M, 20M */
#define DPD_IMPLICIT_NUM               512
typedef enum
{
    MMRF_TEST_DPD_ALGO_PARAM = 0,
    MMRF_TEST_DPD_AM = 1,
    MMRF_TEST_DPD_PM = 2,
    MMRF_TEST_DPD_ALGO_PARAM_RESULT = 3,
} MMRfTestDpdFacCmdType;
typedef struct
{
    unsigned short    lut[MAX_DPD_AM_LUT_GAIN_NUM][MAX_DPD_AM_LUT_ACTUAL_PWR_NUM];
} MMRfTestDpdAmLutSubBand;
typedef struct
{
    short             lut[MAX_DPD_PM_LUT_GAIN_NUM][MAX_DPD_PM_LUT_ACTUAL_PWR_NUM];
} MMRfTestDpdPmLutSubBand;
typedef struct
{
    unsigned short            dpd_subband_freq[MAX_FHC_TX_FREQ_NUM_EX];
} MMRfTestDPDFacParamToolSet;
typedef struct
{
    unsigned short    dpd_cal_done;
    short             dpdImplicitArray[DPD_IMPLICIT_NUM];
} MMRfTestDPDFacParamResult;
typedef union
{
    MMRfTestDPDFacParamToolSet  dpd_fac_tool_set;                        //  MMRF_TEST_DPD_ALGO_PARAM
    MMRfTestDpdAmLutSubBand     am_lut_subband[MAX_FHC_TX_FREQ_NUM_EX];  //  MMRF_TEST_DPD_AM
    MMRfTestDpdPmLutSubBand     pm_lut_subband[MAX_FHC_TX_FREQ_NUM_EX];  //  MMRF_TEST_DPD_PM
    MMRfTestDPDFacParamResult   dpd_fac_tool_result;                     //  MMRF_TEST_DPD_ALGO_PARAM_RESULT
} MMRfTestDpdFacIO;
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
    unsigned short    am_pm_param_type;
    unsigned short    signal_path;       // 0:(default), 1 (HRM), 2:(filter)
} MMRfTestDpdGetFacParamReq;
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
    unsigned short    am_pm_param_type;  // 0:(algorithm param) 1:(AM LUT) 2:(PM LUT)
    unsigned short    signal_path;       // 0:(default), 1 (HRM), 2:(filter)
    MMRfTestDpdFacIO  param;
} MMRfTestDpdGetFacParamCnf;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdFacCalParam_r
 */
META_RESULT __stdcall META_MMRf_GetDpdFacCalParam( const unsigned int ms_timeout, const MMRfTestDpdGetFacParamReq* req, MMRfTestDpdGetFacParamCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetDpdFacCalParam_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestDpdGetFacParamReq* req, MMRfTestDpdGetFacParamCnf* cnf);
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
    unsigned short    am_pm_param_type;  // 0:(algorithm param) 1:(AM LUT) 2:(PM LUT)
    unsigned short    signal_path;       // 0:(default), 1 (HRM), 2:(filter)
    MMRfTestDpdFacIO param;
} MMRfTestDpdSetFacParamReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdFacCalParam_r
 */
META_RESULT __stdcall META_MMRf_SetDpdFacCalParam( const unsigned int ms_timeout, const MMRfTestDpdSetFacParamReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetDpdFacCalParam_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestDpdSetFacParamReq* req);
typedef struct
{
    unsigned short  rat_idx;         /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned short  dpd_switch;
} MMRfTestDpdFacEnDisReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_DpdEnable_r
 */
META_RESULT __stdcall META_MMRf_DpdEnable( const unsigned int ms_timeout, const MMRfTestDpdFacEnDisReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_DpdEnable_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestDpdFacEnDisReq* req);
#define MAX_DPD_PA_GAIN_NUM                 8
#define MAX_DPD_PA_CAL_EARFCN_SECTION      15
#define MAX_DPD_PA_CAL_TEMP_SECTION         8
#define DPD_PA_IMPLICIT_NUM               512
#define MAX_DPD_DELAY_K_SUBBAND_NUM         5
#define MAX_DPD_DELAY_K_SPLIT_BAND_NUM      2

typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
    unsigned short    apt_ref_channel;
} MMRfTestCmdDpdPaProfileFacStartReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdPaProfileFacCal_r
 */
META_RESULT __stdcall META_MMRf_StartDpdPaProfileFacCal( const unsigned int ms_timeout, const MMRfTestCmdDpdPaProfileFacStartReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartDpdPaProfileFacCal_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdDpdPaProfileFacStartReq* req);
typedef enum
{
    MMRF_TEST_DPD_PA_PROFILE = 0,
    MMRF_TEST_DPD_PA_ALGO_PARAM_RESULT = 1
} MMRfTestDPDPaProfileFacCmdType;
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
    unsigned short    pa_param_type;
    unsigned short    signal_path;       // 0:(default), 1 (HRM), 2:(filter)
} MMRfTestDpdGetPaProfileFacParamReq;
typedef struct
{
    unsigned short    tr[MAX_DPD_DELAY_K_SUBBAND_NUM][MAX_LTE_CBW_NUM];
} MMRfTestDpdTrAbsolute;
typedef struct
{
    /* PA Control */
    unsigned char     paControlLevel; /* 2~8 */
    unsigned char     calRoomTempIdx;
    short             hysteresisStart0;
    short             hysteresisEnd0;
    short             hysteresisStart1;
    short             hysteresisEnd1;
    unsigned char     paMode[MAX_DPD_PA_GAIN_NUM]; /* 0:high, 1:middle, 2:low */
    short             pRf[MAX_DPD_PA_GAIN_NUM];
    unsigned short    paGain[MAX_DPD_PA_GAIN_NUM];
    unsigned char     dc2dcLevel[MAX_DPD_PA_GAIN_NUM]; /* voltage map by chip */
    unsigned short    vBiasDac[MAX_DPD_PA_GAIN_NUM];
    unsigned char     vm0[MAX_DPD_PA_GAIN_NUM];
    unsigned char     vm1[MAX_DPD_PA_GAIN_NUM];
    /* TX Compensation */
    unsigned short           ulFrequency[MAX_DPD_PA_CAL_EARFCN_SECTION];//100kHz unit
    short                    paGainHigh[MAX_DPD_PA_CAL_TEMP_SECTION][MAX_DPD_PA_CAL_EARFCN_SECTION];
    short                    paGainMiddle[MAX_DPD_PA_CAL_TEMP_SECTION][MAX_DPD_PA_CAL_EARFCN_SECTION];
    short                    paGainLow[MAX_DPD_PA_CAL_TEMP_SECTION][MAX_DPD_PA_CAL_EARFCN_SECTION];
    short                    couplerLossHigh;
    short                    couplerLossMiddle;
    short                    couplerLossLow;
    short                    powerDetectorHigh[MAX_DPD_PA_CAL_TEMP_SECTION][MAX_DPD_PA_CAL_EARFCN_SECTION];
    short                    powerDetectorMiddle[MAX_DPD_PA_CAL_TEMP_SECTION][MAX_DPD_PA_CAL_EARFCN_SECTION];
    short                    powerDetectorLow[MAX_DPD_PA_CAL_TEMP_SECTION][MAX_DPD_PA_CAL_EARFCN_SECTION];
    MMRfTestDpdTrAbsolute    tr_absolute[MAX_DPD_DELAY_K_SPLIT_BAND_NUM];
} MMRfTestDPDPaProfileFacParam;
typedef struct
{
    unsigned short     dpd_pa_cal_done;
    short              dpdPaImplicitArray[DPD_PA_IMPLICIT_NUM];
} MMRfTestDPDPaFacParamToolSet;
typedef union
{
    MMRfTestDPDPaProfileFacParam   dpd_pa_fac_param;        // MMRF_TEST_DPD_PA_PROFILE
    MMRfTestDPDPaFacParamToolSet   dpd_pa_fac_tool_result;  // MMRF_TEST_DPD_PA_ALGO_PARAM_RESULT
} MMRfTestDPDPaProfileFacIO;
typedef struct
{
    unsigned short               rat_idx;
    unsigned short               rf_band_idx;
    unsigned short               pa_param_type;
    unsigned short               signal_path;       // 0:(default), 1 (HRM), 2:(filter)
    MMRfTestDPDPaProfileFacIO    dpd_pa_fac_io;
} MMRfTestDpdGetPaProfileFacParamCnf;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdPaProfileFacCalParam_r
 */
META_RESULT __stdcall META_MMRf_GetDpdPaProfileFacCalParam( const unsigned int ms_timeout, const MMRfTestDpdGetPaProfileFacParamReq* req, MMRfTestDpdGetPaProfileFacParamCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetDpdPaProfileFacCalParam_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestDpdGetPaProfileFacParamReq* req, MMRfTestDpdGetPaProfileFacParamCnf* cnf);
typedef struct
{
    unsigned short             rat_idx;
    unsigned short             rf_band_idx;
    unsigned short             pa_param_type;
    unsigned short             signal_path;       // 0:(default), 1 (HRM), 2:(filter)
    MMRfTestDPDPaProfileFacIO  dpd_pa_fac_io;
} MMRfTestDpdSetPaProfileFacParamReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPaProfileFacCalParam_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPaProfileFacCalParam( const unsigned int ms_timeout, const MMRfTestDpdSetPaProfileFacParamReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetDpdPaProfileFacCalParam_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestDpdSetPaProfileFacParamReq* req);
//-----------------------------------------------------//
//  DPD Factory Calibration Tool Interface             //
//-----------------------------------------------------//
/* Multi-mode */
#define MMRF_MAX_LTE_DPD_SPLIT_BAND_NUM            (2)
#define MMRF_MAX_DPD_DELAY_K_SUBBAND_NUM        (5)

/**
 * \ingroup MultiModeStruct
 * maximum number of LTE channel
 */
#define MMRF_MAX_LTE_CBW_NUM                    (6)
#define MMRF_MAX_DPD_AM_LUT_PWR_NUM_REDUCE_V2   (16)
#define MMRF_MAX_DPD_PM_LUT_PWR_NUM_REDUCE_V2   (MMRF_MAX_DPD_AM_LUT_PWR_NUM_REDUCE_V2)
/* Multi-mode */

/* LTE */
#define MAX_TX_PA_MODE_NUM            3
#define MAX_TEMP_SECTION_NUM        8

/**
 * \ingroup MultiModeStruct
 * the number of PA level for DPD mode
 */
#define MMRF_MAX_DPD_PA_LEVEL_NUM               (8)
/**
 * \ingroup MultiModeStruct
 * the number of PGA gears for each PA mode
 */
#define MMRF_MAX_DPD_PGA_NUM_PER_PA                (1)
/**
 * \ingroup MultiModeStruct
 * the number of PA sections for DPD mode
 */
#define MMRF_MAX_DPD_AM_LUT_GAIN_NUM            (MMRF_MAX_DPD_PA_LEVEL_NUM * MMRF_MAX_DPD_PGA_NUM_PER_PA)
/**
 * \ingroup MultiModeStruct
 * the number of PA sections for DPD mode
 */
#define MMRF_MAX_DPD_PM_LUT_GAIN_NUM            (MMRF_MAX_DPD_AM_LUT_GAIN_NUM)
#define MMRF_MAX_DPD_PGA_SWING_NUM                (MAX_FHC_TX_FREQ_NUM_EX * MMRF_MAX_DPD_AM_LUT_GAIN_NUM)
#define MMRF_MAX_DPD_PTAR_TH_NUM                (MAX_FHC_TX_FREQ_NUM_EX * MMRF_MAX_DPD_PA_LEVEL_NUM)
#define MMRF_MAX_DPD_PA_PGA_TABLE_NUM            (MAX_FHC_TX_FREQ_NUM_EX * MMRF_MAX_DPD_AM_LUT_GAIN_NUM * 2)
#define MMRF_MAX_DPD_IMPLICIT_RSV_NUM            (32)
#define MMRF_MAX_DPD_IMPLICIT_NUM               (256)
/**
 * \ingroup MultiModeStruct
 * the number of power entries
 */
#define MMRF_MAX_DPD_AM_LUT_ACTUAL_PWR_NUM        (16)
/**
 * \ingroup MultiModeStruct
 * the number of power entries
 */
#define MMRF_MAX_DPD_PM_LUT_ACTUAL_PWR_NUM        (MMRF_MAX_DPD_AM_LUT_ACTUAL_PWR_NUM)
/**
 * \ingroup MultiModeStruct
 * the maximum number of route that can be set in one LTE DPD ommand
 */
#define MMRF_MAX_LTE_DPD_SET_ALL_DATA_NUM        (6)
/**
 * \ingroup MultiModeStruct
 * the maximum number of route that can be get in one LTE DPD ommand
 */
#define MMRF_MAX_LTE_DPD_GET_ALL_DATA_NUM        (MMRF_MAX_LTE_DPD_SET_ALL_DATA_NUM)
/**
 * \ingroup MultiModeStruct
 * the maximum number of route that can be set in one set partial command for LTE DPD
 */
#define MMRF_MAX_LTE_DPD_SET_PARTIAL_DATA_NUM    (63)
/* LTE */

/* WCDMA */
/**
 * \ingroup WCDMAStruct
 * the maximum number of band that can be done in one WCDMA DPD command
 */
#define MMRF_MAX_WCDMA_DPD_BAND_NUM_V2              (5)
#define MMRF_MAX_WCDMA_DPD_PA_LEVEL_NUM_V2          (8)
#define MMRF_MAX_WCDMA_DPD_PGA_NUM_PER_PA_V2        (1)
#define MMRF_MAX_WCDMA_DPD_AM_LUT_GAIN_NUM_V2        (MMRF_MAX_WCDMA_DPD_PA_LEVEL_NUM_V2 * MMRF_MAX_WCDMA_DPD_PGA_NUM_PER_PA_V2)
#define MMRF_MAX_WCDMA_DPD_PM_LUT_GAIN_NUM_V2        (MMRF_MAX_WCDMA_DPD_AM_LUT_GAIN_NUM_V2)
#define MMRF_MAX_WCDMA_DPD_PA_MODE_NUM_V2           (3)
#define MMRF_MAX_WCDMA_DPD_PA_HYST_NUM_V2           (MMRF_MAX_WCDMA_DPD_PA_MODE_NUM_V2 - 1)

#define MMRF_MAX_WCDMA_DPD_CAL_UARFCN_SECTION_V2    (15)
#define MMRF_MAX_WCDMA_DPD_PGA_SWING_NUM_V2            (MMRF_MAX_WCDMA_DPD_CAL_UARFCN_SECTION_V2 * MMRF_MAX_WCDMA_DPD_AM_LUT_GAIN_NUM_V2)
#define MMRF_MAX_WCDMA_DPD_PTAR_TH_NUM_V2            (MMRF_MAX_WCDMA_DPD_CAL_UARFCN_SECTION_V2 * MMRF_MAX_WCDMA_DPD_PA_LEVEL_NUM_V2)
#define MMRF_MAX_WCDMA_DPD_IMPLICIT_RSV_NUM_V2        (16)
#define MMRF_MAX_WCDMA_DPD_IMPLICIT_NUM_V2            (MMRF_MAX_WCDMA_DPD_PGA_SWING_NUM_V2 + MMRF_MAX_WCDMA_DPD_PTAR_TH_NUM_V2 + MMRF_MAX_WCDMA_DPD_IMPLICIT_RSV_NUM_V2)
#define MMRF_MAX_WCDMA_DPD_SET_ALL_DATA_NUM_V2        (7)
#define MMRF_MAX_WCDMA_DPD_GET_ALL_DATA_NUM_V2        (MMRF_MAX_WCDMA_DPD_SET_ALL_DATA_NUM_V2)
#define MMRF_MAX_WCDMA_DPD_SET_PARTIAL_DATA_NUM_V2    (239)
/* WCDMA */

typedef enum
{
   ERF_TEST_LTE_DPD_V1 = 0,
   ERF_TEST_LTE_DPD_V2 = 1,
   ERF_TEST_LTE_DPD_V3 = 2,
   ERF_TEST_LTE_DPD_V5 = 3
}ERfTestLteDpdGeneration;
typedef enum
{
   URF_TEST_WCDMA_DPD_V1 = 0,
   URF_TEST_WCDMA_DPD_V2 = 1,
   URF_TEST_WCDMA_DPD_V3 = 2,
   URF_TEST_WCDMA_DPD_V5 = 3
}URfTestWcdmaDpdGeneration;

/**
 * \ingroup MultiModeStruct
 * LTE DPD AM table of one subband.
 */
typedef struct
{
   /** LTE DPD AM table of one subband.
    */
   unsigned short  lut[MMRF_MAX_DPD_AM_LUT_GAIN_NUM][MMRF_MAX_DPD_AM_LUT_ACTUAL_PWR_NUM];

} MMRfTestCmdDPDAMLutSubBand;

/**
 * \ingroup MultiModeStruct
 * LTE DPD PM table of one subband.
 */
typedef struct
{

   /** LTE DPD PM table of one subband.
    */
    short               lut[MMRF_MAX_DPD_PM_LUT_GAIN_NUM][MMRF_MAX_DPD_PM_LUT_ACTUAL_PWR_NUM];
} MMRfTestCmdDPDPMLutSubBand;

/**
 * \ingroup MultiModeStruct
 * TPC related parameters for LTE DPD mode
 */
typedef struct
{
    /** LTE band number (spec. defined) for this route information element
     */
    unsigned short        rf_band;

    /** Route number
     */
    unsigned short        route_idx;

    /** TX path selection
     */
    unsigned short        path_select;

    /** Division of PA gain calibration (fixed to 8)
     */
    unsigned char        paControlLevel; /* 2~8 */

    /** Temperature region when calibrating (always 4 now: room temperature)
     */
    unsigned char        calRoomTempIdx;

    /** Start point of 1st hysteresis (in unit of 1/32 dB)
     */
    short               hysteresisStart0;

    /** End point of 1st hysteresis (in unit of 1/32 dB)
     */
    short               hysteresisEnd0;

    /** Start point of 2nd hysteresis (in unit of 1/32 dB)
     */
    short               hysteresisStart1;

    /** End point of 2nd hysteresis (in unit of 1/32 dB)
     */
    short               hysteresisEnd1;

    /** PA operation mode (enumeration):\n
     *  0: PA be operated in high mode\n
     *  1: PA be operated in middle mode\n
     *  2: PA be operated in low mode\n
     */
    unsigned char       paMode[MMRF_MAX_DPD_PA_LEVEL_NUM]; /* ERfTestTxPaModeE */

    /** Target TX power used in PA gain calibration (in unit of 1/32 dB)
     */
    short                pRf[MMRF_MAX_DPD_PA_LEVEL_NUM];

    /** PA gain values corresponding to pRf for middle-channel
     */
    unsigned short      paGain[MMRF_MAX_DPD_PA_LEVEL_NUM];

    /** PA supply voltage (in unit of 1/10 volt)
     */
    unsigned char       dc2dcLevel[MMRF_MAX_DPD_PA_LEVEL_NUM]; /* voltage map by chip, TODO */

    /** Phase-out item, not used now
     */
    unsigned short      vBiasDac[MMRF_MAX_DPD_PA_LEVEL_NUM];

    /** For BPI PA control
     */
    unsigned char        vm0[MMRF_MAX_DPD_PA_LEVEL_NUM];

    /** For BPI PA control
     */
    unsigned char        vm1[MMRF_MAX_DPD_PA_LEVEL_NUM];

    /** DPD PA gain sub-band compensation results
     */
    short                paGainSbWeight[MAX_TX_PA_MODE_NUM][MAX_TEMP_SECTION_NUM][MAX_FHC_TX_FREQ_NUM_EX];

    /** DPD cal. done flag. Change from 0 to 1 after DPD calibration.
     */
    unsigned short        dpd_pa_dpd_cal_done;

    /** Delay for LTE DPD.
      *   0: LTE 1.4M\n
      *   1: LTE 3M\n
      *   2: LTE 5M\n
      *   3: LTE 10M\n
      *   4: LTE 15M\n
      *   5: LTE 20M\n
     */
    short dpd_tr[MAX_FHC_TX_FREQ_NUM_EX][MMRF_MAX_LTE_CBW_NUM];
} MMRfTestCmdSetGetLteDpdTpcPeer;

/**
 * \ingroup MultiModeStruct
 * Calibration data generated by DPD algorithm
 */
typedef struct
{
   /** Reserved variable for algorithm tuning.
    */
   short                         dpdImplicitArray[MMRF_MAX_DPD_IMPLICIT_NUM]; /* For the parameters whose name will not be shown in cal file */

   /** LTE DPD AM table for all subband.
    */
   MMRfTestCmdDPDAMLutSubBand    am_lut_subband[MAX_FHC_TX_FREQ_NUM_EX];

   /** LTE DPD PM table for all subband.
    */
   MMRfTestCmdDPDPMLutSubBand    pm_lut_subband[MAX_FHC_TX_FREQ_NUM_EX];
} MMRfTestCmdSetGetLteDpdDpdPeer;

/**
 * \ingroup MultiModeStruct
 * LTE DPD set all(for downloading calibration data) peer buffer
 */
typedef struct
{
   /** TPC related parameters for LTE DPD mode
    */
   MMRfTestCmdSetGetLteDpdTpcPeer    dpdtpc_peer;

   /** Calibration data generated by DPD algorithm
    */
   MMRfTestCmdSetGetLteDpdDpdPeer    dpd_peer;
}MMRfTestCmdSetLteDpdPaAndDpdFacCalAllOneRoute;

typedef struct
{
   unsigned short    start;
   unsigned short    end;
} MMRfTestCmdWcdmaDpdHysteresisData;

typedef struct
{
   unsigned char    pa_mode;
   char                prf;
   unsigned char    dc2dc_lvl;
   unsigned char    vm1;
   unsigned char    vm2;
   unsigned short    vbias_dac;
   unsigned short    pa_gain;
} MMRfTestCmdWcdmaDpdPmuLevHandle;

typedef struct
{
   unsigned short                        rf_band;
   unsigned short                        dpd_pa_dpd_cal_done;
   short                                dpd_tr[MMRF_MAX_WCDMA_DPD_CAL_UARFCN_SECTION_V2];
   short                                vga_comp_subband[MMRF_MAX_WCDMA_DPD_PA_MODE_NUM_V2][MMRF_MAX_WCDMA_DPD_CAL_UARFCN_SECTION_V2];
   short                                vga_comp_temperature[MMRF_MAX_WCDMA_DPD_PA_MODE_NUM_V2][MMRF_MAX_WCDMA_DPD_PA_LEVEL_NUM_V2];
   MMRfTestCmdWcdmaDpdHysteresisData    tx_hysteresis[MMRF_MAX_WCDMA_DPD_PA_HYST_NUM_V2];
   unsigned char                        octlev_num_section;
   unsigned int                            pa_phase_compensation[MMRF_MAX_WCDMA_DPD_PA_MODE_NUM_V2];
   MMRfTestCmdWcdmaDpdPmuLevHandle        pmu_level_handle[MMRF_MAX_WCDMA_DPD_PA_LEVEL_NUM_V2];
}MMRfTestCmdSetGetWcdmaDpdTpcPeer;

typedef struct
{
   unsigned short  lut[MMRF_MAX_WCDMA_DPD_AM_LUT_GAIN_NUM_V2][MMRF_MAX_DPD_AM_LUT_PWR_NUM_REDUCE_V2];
} MMRfTestCmdWcdmaDPDAMLutSubBand;

typedef struct
{
   short  lut[MMRF_MAX_WCDMA_DPD_PM_LUT_GAIN_NUM_V2][MMRF_MAX_DPD_PM_LUT_PWR_NUM_REDUCE_V2];
} MMRfTestCmdWcdmaDPDPMLutSubBand;

typedef struct
{
   short                            dpdImplicitArray[MMRF_MAX_WCDMA_DPD_IMPLICIT_NUM_V2];
   MMRfTestCmdWcdmaDPDAMLutSubBand    am_lut_subband[MMRF_MAX_WCDMA_DPD_CAL_UARFCN_SECTION_V2];
   MMRfTestCmdWcdmaDPDPMLutSubBand    pm_lut_subband[MMRF_MAX_WCDMA_DPD_CAL_UARFCN_SECTION_V2];
}MMRfTestCmdSetGetWcdmaDpdDpdPeer;

typedef struct
{
   MMRfTestCmdSetGetWcdmaDpdTpcPeer     dpdtpc_peer;
   MMRfTestCmdSetGetWcdmaDpdDpdPeer     dpd_peer;
}MMRfTestCmdSetWcdmaDpdPaAndDpdFacCalAllOneBand;

/**
 * \ingroup MultiModeStruct
 * Local buffer for LTE DPD set all command.
 */
typedef struct
{
   /** Meta tool can set multiple LTE routes calibration data in one set command,\n
   *   e.g. Meta tool wants to set 3 routes calibration data, then it sets route_num to 3.
   */
   unsigned short            route_num;
}MMRfTestCmdSetLteDpdAllReqInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for WCDMA DPD set all command.
 */
typedef struct
{
   /** Meta tool can set multiple WCDMA bands calibration data in one set command,\n
   *   e.g. Meta tool set 3 bands calibration data, it sets num_of_band to 3.
   */
   unsigned short            num_of_band;
}MMRfTestCmdSetWcdmaDpdAllReqInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer for multi-mode DPD set all (downloading) request. It's an union, so meta tool can only set one RAT data in one set command.
 */
typedef union
{
   /** The local buffer for LTE DPD set all request.
   */
   MMRfTestCmdSetLteDpdAllReqInfo    lte_dpd_req;

   /** The local buffer for WCDMA DPD set all request.
   */
   MMRfTestCmdSetWcdmaDpdAllReqInfo wcdma_dpd_req;
}MMRfTestCmdSetMmDpdAllReqInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for multi-mode DPD set all (downloading) request.
 */
typedef struct
{
    /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE\n
    *   Meta tool set this varaible to tell the target which RAT of DPD is running
    */
   unsigned short                    rat_idx;

   /**
   * Parameters of the local buffer of multi-mode DPD set all (downloading) request.
   */
   MMRfTestCmdSetMmDpdAllReqInfo    mm_dpd_info;

}MMRfTestCmdSetDpdPaAndDpdFacCalAllReqParam;

/**
 * \ingroup MultiModeStruct
 * The parameters of multi-mode DPD set all (downloading) request.
 */
typedef struct
{
   /** Local buffer of this command.
   */
   MMRfTestCmdSetDpdPaAndDpdFacCalAllReqParam reqParam;

   /** Peer buffer of this command.
   */
   union
   {
       /** LTE DPD set all peer buffer
        */
        MMRfTestCmdSetLteDpdPaAndDpdFacCalAllOneRoute   reqPeer[MMRF_MAX_LTE_DPD_SET_ALL_DATA_NUM];
        /** WCDMA DPD set all peer buffer.
        */
        MMRfTestCmdSetWcdmaDpdPaAndDpdFacCalAllOneBand  wcdmaReqPeer[MMRF_MAX_WCDMA_DPD_BAND_NUM_V2];
   };
} MMRfTestSetDpdPaAndDpdFacCalAllReq;

typedef enum
{
   MMRF_TEST_SET_LTE_DPDPA_DPD_COARSE_INVALID    = 0,
   MMRF_TEST_SET_LTE_DPDPA_DPD_COARSE_OK        = 1,
   MMRF_TEST_SET_LTE_DPDPA_DPD_COARSE_PEER_SIZE_MISMATCH    = 2  /* count/offset mismatch */
}MMRfTestSetLteDpdPaAndDpdFacCalCoarseStatus;

typedef enum
{
   MMRF_TEST_SET_LTE_DPDPA_DPD_ROUTE_INVALID    = 0,
   MMRF_TEST_SET_LTE_DPDPA_DPD_ROUTE_OK        = 1,
   MMRF_TEST_SET_LTE_DPDPA_DPD_ROUTE_BAND_MISMATCH    = 2
}MMRfTestSetLteDpdPaAndDpdFacCalRouteStatus;

/**
 * \ingroup MultiModeStruct
 * The local buffer for LTE DPD set all confirm.
 */
typedef struct
{
   /** L1 copy the route_num in MMRfTestCmdSetLteDpdAllReqInfo to this route_num and report it to meta tool for debugging.
    */
   unsigned short    route_num;

   /** The main L1 status reported to meta tool.
    *  Enumeration:\n
    *  0: Invalid\n
    *  1: OK\n
    *  2: Peer buffer size mismatched\n
    */
   unsigned short     coarse_status; /* MMRfTest_SetLteDpdPaAndDpdFacCal_CoarseStatus */

   /** The L1 status for each route reported to meta tool.
    *  Enumeration:\n
    *  0: Invalid\n
    *  1: OK\n
    *  2: Route v.s band is mismatched
    */
   unsigned short     route_status[MMRF_MAX_LTE_DPD_SET_ALL_DATA_NUM]; /* MMRfTest_SetLteDpdPaAndDpdFacCal_RouteStatus */
}MMRfTestResultSetLteDpdAllCnfInfo;

typedef enum
{
   MMRF_TEST_SET_WCDMA_DPD_INVALID              = 0,
   MMRF_TEST_SET_WCDMA_DPD_OK                    = 1,
   MMRF_TEST_SET_WCDMA_DPD_PEER_SIZE_MISMATCH   = 2
}MMRfTestSetWcdmaDpdPaAndDpdFacCalRouteStatus;

typedef struct
{
   unsigned short        num_of_band;
   unsigned short        status; /* MMRfTestSetWcdmaDpdPaAndDpdFacCalRouteStatus */
}MMRfTestResultSetWcdmaDpdAllCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer of multi-mode DPD set all (downloading) confirm. It's an union, so meta tool can only set one RAT data in one set command.
 */
typedef union
{
   /** The local buffer of LTE DPD set all confirm.
    */
   MMRfTestResultSetLteDpdAllCnfInfo    lte_dpd_cnf;

   /** The local buffer of WCDMA DPD set all confirm.
    */
   MMRfTestResultSetWcdmaDpdAllCnfInfo    wcdma_dpd_cnf;
}MMRfTestResultSetMmDpdAllCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for multi-mode DPD set all (downloading) confirm.
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE\n
    *   Meta too set this varaible to tell the target which RAT of DPD is running
    */
   unsigned short                   rat_idx;

   /**
   * Parameters of the local buffer for multi-mode DPD set all (downloading) confirm.
   */
   MMRfTestResultSetMmDpdAllCnfInfo    mm_dpd_cnf;
}MMRfTestResultSetDpdPaAndDpdFacCalAllCnfParam;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD set all (downloading) confirm.
 */
typedef struct
{
   /** Local buffer for this command.
    */
   MMRfTestResultSetDpdPaAndDpdFacCalAllCnfParam cnfParam;
} MMRfTestSetDpdPaAndDpdFacCalAllCnf;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPaAndDpdFacCalAll_V2_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalAll_V2( const unsigned int ms_timeout, const MMRfTestSetDpdPaAndDpdFacCalAllReq *req, MMRfTestSetDpdPaAndDpdFacCalAllCnf *cnf);

/**
 * \details The function for downloading DPD calibration data from meta tool to target.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the DPD calibration data sent to target.
 * \param [out] cnf is the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalAll_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestSetDpdPaAndDpdFacCalAllReq *req, MMRfTestSetDpdPaAndDpdFacCalAllCnf *cnf);

/**
 * \ingroup MultiModeStruct
 * LTE DPD set partial(set before calibration) peer buffer
 */
typedef struct
{
   /** Calibration data generated by DPD algorithm
    */
   MMRfTestCmdSetGetLteDpdTpcPeer     dpdtpc_peer;
}MMRfTestCmdSetLteDpdPaAndDpdFacCalPartialOneRoute;

/**
 * \ingroup MultiModeStruct
 * Local buffer of LTE DPD set partial command.
 */
typedef struct
{
   /** Meta tool can set multiple LTE routes calibration data in one set command,\n
    *  e.g. Meta tool wants to set 3 routes calibration data, then it sets route_num to 3.
    */
   unsigned short            route_num;
}MMRfTestCmdSetLteDpdPartialReqInfo;

typedef struct
{
   MMRfTestCmdSetGetWcdmaDpdTpcPeer     dpdtpc_peer;
}MMRfTestCmdSetWcdmaDpdPaAndDpdFacCalPartialOneBand;

typedef struct
{
   unsigned short            num_of_band;
}MMRfTestCmdSetWcdmaDpdPartialReqInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer of multi-mode DPD set partial (set before calibration) request.\n
 * It's an union, so meta tool can only set one RAT data in one set command.
 */
typedef union
{
   /** The local buffer of LTE DPD set all confirm.
    */
   MMRfTestCmdSetLteDpdPartialReqInfo    lte_dpd_req;
   MMRfTestCmdSetWcdmaDpdPartialReqInfo    wcdma_dpd_req;
}MMRfTestCmdSetMmDpdPartialReqInfo;

/**
 * \ingroup MultiModeStruct
 * The local buffer of multi-mode DPD set partial (set before calibration) request.
 */
typedef struct
{
   /** Enumeration:\n
    *  1: GSM\n
    *  2: TDSCDMA\n
    *  4: CDMA2000\n
    *  8: WCDMA\n
    *  16: LTE\n
    *  Meta too set this varaible to tell the target which RAT of DPD is running
    */
   unsigned short                        rat_idx;

   /**
    * Parameters of the local buffer for multi-mode DPD set partial (set before calibration) request.
    */
   MMRfTestCmdSetMmDpdPartialReqInfo    mm_dpd_info;
}MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqParam;

/**
 * \ingroup MultiModeStruct
 * The parameters of multi-mode DPD set partial (set before calibration) request.
 */
typedef struct
{
   /** Local buffer of this command.
    */
   MMRfTestCmdSetDpdPaAndDpdFacCalPartialReqParam reqParam;

   /** Peer buffer of this command.
    */
   union
   {
       /** LTE DPD set partial peer buffer
        */
        MMRfTestCmdSetLteDpdPaAndDpdFacCalPartialOneRoute   reqPeer[MMRF_MAX_LTE_DPD_SET_PARTIAL_DATA_NUM];

        /** WCDMA DPD set partial peer buffer
        */
        MMRfTestCmdSetWcdmaDpdPaAndDpdFacCalPartialOneBand  wcdmaReqPeer[MMRF_MAX_WCDMA_DPD_BAND_NUM_V2];
   };
}MMRfTestCmdSetDpdPaAndDpdFacCalPartialReq;

/**
 * \ingroup MultiModeStruct
 * The local buffer for LTE DPD set partial confirm.
 */
typedef struct
{
   /** L1 copy the route_num in MMRfTestCmdSetLteDpdPartialReqInfo to this route_num and report it to meta tool for debugging.
    */
   unsigned short    route_num;

   /** The main L1 status reported to meta tool.
    *  Enumeration:\n
    *  0: Invalid\n
    *  1: OK\n
    *  2: Peer buffer size mismatched\n
    */
   unsigned short    coarse_status; /* MMRfTest_SetLteDpdPaAndDpdFacCal_CoarseStatus */

   /** The L1 status for each route reported to meta tool.
    *  Enumeration:\n
    *  0: Invalid\n
    *  1: OK\n
    *  2: Route v.s band mismatched
    */
   unsigned short    route_status[MMRF_MAX_LTE_DPD_SET_PARTIAL_DATA_NUM]; /* MMRfTest_SetLteDpdPaAndDpdFacCal_RouteStatus */
}MMRfTestResultSetLteDpdPartialCnfInfo;

typedef struct
{
   unsigned short    num_of_band;
   unsigned short    status;
}MMRfTestResultSetWcdmaDpdPartialCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer for multi-mode DPD set partial (set before calibration) confirm.\n
 * It's an union, so meta tool can only set one RAT data in one command.
 */
typedef union
{
   /** The local buffer for LTE DPD set partial confirm.
    */
   MMRfTestResultSetLteDpdPartialCnfInfo    lte_dpd_cnf;

   /** The local buffer for WCDMA DPD set partial confirm.
    */
   MMRfTestResultSetWcdmaDpdPartialCnfInfo    wcdma_dpd_cnf;
}MMRfTestResultSetMmDpdPartialCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for multi-mode DPD set partial (set before calibration) confirm.
 */
typedef struct
{
   /** Enumeration:\n
    *  1: GSM\n
    *  2: TDSCDMA\n
    *  4: CDMA2000\n
    *  8: WCDMA\n
    *  16: LTE\n
    *  Meta too set this varaible to tell the target which RAT of DPD is running
    */
   unsigned short                       rat_idx;

   /**
   * Parameters of the local buffer for multi-mode DPD set partial (set before calibration) confirm.
   */
   MMRfTestResultSetMmDpdPartialCnfInfo    mm_dpd_cnf;
}MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfParam;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD set partial (set before calibration) confirm.
 */
typedef struct
{
   /** Local buffer for this command.
    */
   MMRfTestResultSetDpdPaAndDpdFacCalPartialCnfParam cnfParam;
}MMRfTestResultSetDpdPaAndDpdFacCalPartialCnf;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPaAndDpdFacCalPartial_V2_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalPartial_V2( const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalPartialReq *req, MMRfTestResultSetDpdPaAndDpdFacCalPartialCnf *cnf);

/**
 * \details The function for setting DPD parameters before starting DPD calibration.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the DPD parameters sent to target.
 * \param [out] cnf is the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetDpdPaAndDpdFacCalPartial_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetDpdPaAndDpdFacCalPartialReq *req, MMRfTestResultSetDpdPaAndDpdFacCalPartialCnf *cnf);

/**
 * \ingroup MultiModeStruct
 * Information for getting correct calibration data.
 */
typedef struct
{
   /** Route number
    */
   unsigned short            route_idx;

   /** TX path selection
    */
   unsigned short            path_select;
}MMRfTestCmdRouteInfo;

/**
 * \ingroup MultiModeStruct
 * The local buffer of LTE DPD get command request.
 */
typedef struct
{
   /** Meta tool can get multiple LTE routes calibration data in one get command,\n
    *   e.g. Meta tool get 3 routes calibration data, it sets route_num to 3.
    */
   unsigned short            route_num;

   /** Information set to L1 for getting correct calibration data.
    */
   MMRfTestCmdRouteInfo        route_info[MMRF_MAX_LTE_DPD_GET_ALL_DATA_NUM];
}MMRfTestCmdGetLteDpdAllReqInfo;

typedef struct
{
   unsigned short            num_of_band;
   unsigned short            rf_band[MMRF_MAX_WCDMA_DPD_BAND_NUM_V2];
}MMRfTestCmdGetWcdmaDpdAllReqInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer of multi-mode DPD get command request. It's an union, so meta tool can only get one RAT data in one get command.
 */
typedef union
{
   /** The local buffer of LTE DPD get command request.
    */
   MMRfTestCmdGetLteDpdAllReqInfo    lte_dpd_req;
   /** The local buffer of WCDMA DPD get command request.
    */
   MMRfTestCmdGetWcdmaDpdAllReqInfo    wcdma_dpd_req;
}MMRfTestCmdGetMmDpdAllReqInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for multi-mode DPD get command confirm.
 */
typedef struct
{
   /** Enumeration:\n
   *   1: GSM\n
   *   2: TDSCDMA\n
   *   4: CDMA2000\n
   *   8: WCDMA\n
   *   16: LTE\n
   *   Meta too set this varaible to tell the target which RAT of DPD is running
   */
   unsigned short                    rat_idx;

   /**
    * Parameters of the local buffer for multi-mode DPD get command confirm.
    */
   MMRfTestCmdGetMmDpdAllReqInfo    mm_dpd_req;
}MMRfTestCmdGetDpdPaAndDpdFacCalAllReqParam;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD get command request.
 */
typedef struct
{
   /** Local buffer for this command.
    */
   MMRfTestCmdGetDpdPaAndDpdFacCalAllReqParam reqParam;
}MMRfTestCmdGetDpdPaAndDpdFacCalAllReq;

typedef enum
{
   MMRF_TEST_GET_LTE_DPDPA_DPD_INVALID    = 0,
   MMRF_TEST_GET_LTE_DPDPA_DPD_OK    = 1
}MMRfTest_GetLteDpdPaAndDpdFacCal_Status;

/**
 * \ingroup MultiModeStruct
 * LTE DPD get command peer buffer
 */
typedef struct
{
   /** TPC related parameters for LTE DPD mode
    */
   MMRfTestCmdSetGetLteDpdTpcPeer    dpdtpc_peer;
   /** Calibration data generated by DPD algorithm
    */
   MMRfTestCmdSetGetLteDpdDpdPeer    dpd_peer;
}MMRfTestResultGetLteDpdPaAndDpdFacCalAllOneRoute;

typedef struct
{
   MMRfTestCmdSetGetWcdmaDpdTpcPeer    dpdtpc_peer;
   MMRfTestCmdSetGetWcdmaDpdDpdPeer    dpd_peer;
}
MMRfTestResultGetWcdmaDpdPaAndDpdFacCalAllOneBand;

/**
 * \ingroup MultiModeStruct
 * The local buffer for LTE DPD get command confirm.
 */
typedef struct
{
   /** L1 copy the route_num in MMRfTestCmdGetLteDpdAllReqInfo to this route_num and report it to meta tool for debugging.
    */
   unsigned short            route_num;

   /** The L1 status reported to meta tool.
    *  Enumeration:\n
    *  0: Invalid\n
    *  1: OK\n
    */
   unsigned short            get_status; /* MMRfTest_GetLteDpdPaAndDpdFacCal_Status */
}MMRfTestResultGetLteDpdAllCnfInfo;

typedef enum
{
   MMRF_TEST_GET_WCDMA_DPD_INVALID    = 0,
   MMRF_TEST_GET_WCDMA_DPD_OK        = 1
} MMRfTestResultGetWcdmaDpdFacCalStatus;

typedef struct
{
   unsigned short            num_of_band;
   unsigned short            get_status; // MMRfTestResultGetWcdmaDpdFacCalStatus
} MMRfTestResultGetWcdmaDpdAllCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer for multi-mode DPD get command confirm. It's an union, so L1 can only return one RAT data in one get command.
 */
typedef union
{
   /** The local buffer for LTE DPD get command confirm.
    */
   MMRfTestResultGetLteDpdAllCnfInfo    lte_dpd_cnf;

   /** The local buffer for WCDMA DPD get command confirm.
    */
   MMRfTestResultGetWcdmaDpdAllCnfInfo    wcdma_dpd_cnf;
}MMRfTestResultGetMmDpdAllCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for multi-mode DPD get confirm.
 */
typedef struct
{
   /** Enumeration:\n
    *  1: GSM\n
    *  2: TDSCDMA\n
    *  4: CDMA2000\n
    *  8: WCDMA\n
    *  16: LTE\n
    *  Meta too set this varaible to tell the target which RAT of DPD is running
    */
   unsigned short                    rat_idx;

   /**
    * Parameters of the local buffer for multi-mode DPD get command confirm.
    */
   MMRfTestResultGetMmDpdAllCnfInfo    mm_dpd_cnf;
}MMRfTestResultGetDpdPaAndDpdFacCalAllCnfParam;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD get confirm.
 */
typedef struct
{
   /** Local buffer for this command.
    */
   MMRfTestResultGetDpdPaAndDpdFacCalAllCnfParam cnfParam;

   /** Peer buffer for this command.
    */
   union
   {
        /** LTE DPD set all peer buffer
         */
        MMRfTestResultGetLteDpdPaAndDpdFacCalAllOneRoute    cnfPeer[MMRF_MAX_LTE_DPD_GET_ALL_DATA_NUM];
        /** WCDMA DPD set all peer buffer
         */
        MMRfTestResultGetWcdmaDpdPaAndDpdFacCalAllOneBand   wcdmaCnfPeer[MMRF_MAX_WCDMA_DPD_BAND_NUM_V2];
   };
}MMRfTestResultGetDpdPaAndDpdFacCalAllCnf;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdPaAndDpdFacCalAll_V2_r
 */
META_RESULT __stdcall META_MMRf_GetDpdPaAndDpdFacCalAll_V2( const unsigned int ms_timeout, MMRfTestCmdGetDpdPaAndDpdFacCalAllReq *req, const MMRfTestResultGetDpdPaAndDpdFacCalAllCnf *cnf);

/**
 * \details The function for getting DPD calibration data from target to meta tool.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the parameters sent to target to indicate which data need to be get.
 * \param [out] cnf is the DPD calibration data and the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetDpdPaAndDpdFacCalAll_V2_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdGetDpdPaAndDpdFacCalAllReq *req, const MMRfTestResultGetDpdPaAndDpdFacCalAllCnf *cnf);

/**
 * \ingroup MultiModeStruct
 * Parameters in one LTE DPD start command peer buffer.
 */
typedef struct
{
   /** Route number
    */
   unsigned short    comp_route;

   /** TX path selection
    */
   unsigned short    path_select;

   /** The subband frequency of referenced PA gain of LTE TPC. In paGainSbWeight[] of ERfTestCmdGetSetTpcSetting_V2,\n
    *  there will be a zero value in one of MAX_FHC_TX_FREQ_NUM_EX, that is the frequency of referenced PA gain.
    */
   unsigned short    apt_ref_channel;
} MMRfTestCmdLteAptRefChannelOneRoute;

typedef struct
{
   unsigned short    rf_band;
   unsigned short    apt_ref_channel;
   short             tpc_wanted_p_offset;
} MMRfTestCmdWcdmaAptRefChannelOneBand;

/**
 * \ingroup MultiModeStruct
 * The local buffer for LTE DPD start command request.
 */
typedef struct
{
   /** The variable that indicates how many elements in MMRfTestCmdLteAptRefChannelOneRoute of MMRfTestCmdStartDpdPaAndDpdFacCalReq are valid.
    */
   unsigned short            route_ps_num;
}MMRfTestCmdStartLteDpdReqInfo;

typedef struct
{
   unsigned short   num_of_band;
   unsigned short    cal_rf_band[MMRF_MAX_WCDMA_DPD_BAND_NUM_V2];
}MMRfTestCmdStartWcdmaDpdReqInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer of multi-mode DPD start command request. It's an union, so meta tool can only send one RAT data in one start command.
 */
typedef union
{
   /** The local buffer of LTE DPD start command request.
    */
   MMRfTestCmdStartLteDpdReqInfo    lte_dpd_req;

   /** The local buffer of WCDMA DPD start command request.
    */
   MMRfTestCmdStartWcdmaDpdReqInfo    wcdma_dpd_req;
}MMRfTestCmdStartMmDpdReqInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for multi-mode DPD start request.
 */
typedef struct
{
   /** Enumeration:\n
    *  1: GSM\n
    *  2: TDSCDMA\n
    *  4: CDMA2000\n
    *  8: WCDMA\n
    *  16: LTE\n
    *  Meta too set this varaible to tell the target which RAT of DPD is running
    */
   unsigned short               rat_idx;

   /**
    * Parameters of the local buffer for multi-mode DPD start request.
    */
   MMRfTestCmdStartMmDpdReqInfo    mm_dpd_info;
}MMRfTestCmdStartDpdPaAndDpdFacCalReqParam;


#define MAX_TX_ROUTE_AND_PS_NUM                    (256 * 4)
#define MMDPD_MAX_AM_LUT_PWR_NUM_V3         (16)
#define MMDPD_MAX_PM_LUT_PWR_NUM_V3         (MMDPD_MAX_AM_LUT_PWR_NUM_V3)

// Define for LTE
#define LTE_TARGET_SUPPORT_BAND_NUM_MAX_V3    (25)
#define LTE_TARGET_MAX_SUPPORT_BAND_NUM_V3  (LTE_TARGET_SUPPORT_BAND_NUM_MAX_V3)
#define LTE_DPD_MAX_CBW_NUM_V3              (6)
#define LTE_DPD_MAX_PA_LEVEL_NUM_V3         (8)
#define LTE_DPD_MAX_PGA_NUM_PER_PA_V3       (1)
#define LTE_DPD_MAX_AM_LUT_GAIN_NUM_V3      (LTE_DPD_MAX_PA_LEVEL_NUM_V3 * LTE_DPD_MAX_PGA_NUM_PER_PA_V3)
#define LTE_DPD_MAX_PM_LUT_GAIN_NUM_V3      (LTE_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define LTE_DPD_FDB_NUM_V3                  (MAX_FHC_TX_FREQ_NUM_EX * LTE_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define LTE_DPD_MAX_PTAR_TH_NUM_V3          (MAX_FHC_TX_FREQ_NUM_EX * LTE_DPD_MAX_PA_LEVEL_NUM_V3)
#define LTE_DPD_MAX_IMPLICIT_RSV_NUM_V3     (0)
#define LTE_DPD_MAX_IMPLICIT_NUM_V3         (LTE_DPD_FDB_NUM_V3 + LTE_DPD_MAX_PTAR_TH_NUM_V3 + LTE_DPD_MAX_IMPLICIT_RSV_NUM_V3)
#define LTE_DPD_MAX_SET_ALL_DATA_NUM_V3     (11)
#define LTE_DPD_MAX_GET_ALL_DATA_NUM_V3     (LTE_DPD_MAX_SET_ALL_DATA_NUM_V3)
#define LTE_DPD_MAX_SET_PARTIAL_DATA_NUM_V3 (63)

// Define for WCDMA
#define MAX_SUPPORTED_BAND_INDEX_V3         (5)
#define UL1_DPD_MAX_PA_LEVEL_NUM_V3         (8)
#define UL1_DPD_MAX_PGA_NUM_PER_PA_V3       (1)
#define UL1_DPD_MAX_AM_LUT_GAIN_NUM_V3      (UL1_DPD_MAX_PA_LEVEL_NUM_V3 * UL1_DPD_MAX_PGA_NUM_PER_PA_V3)
#define UL1_DPD_MAX_PM_LUT_GAIN_NUM_V3      (UL1_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define UL1D_DPD_MAX_PA_MODE_NUM_V3         (3)
#define UL1D_DPD_MAX_PA_HYST_NUM_V3         (UL1D_DPD_MAX_PA_MODE_NUM_V3 - 1)
#define UL1_DPD_FDB_NUM_V3                  (CAL_UARFCN_SECTION * UL1_DPD_MAX_PA_LEVEL_NUM_V3)
#define UL1_DPD_MAX_PTAR_TH_NUM_V3          (CAL_UARFCN_SECTION * UL1_DPD_MAX_PA_LEVEL_NUM_V3)
#define UL1_DPD_MAX_IMPLICIT_RSV_NUM_V3     (0)
#define UL1_DPD_MAX_IMPLICIT_NUM_V3         (UL1_DPD_FDB_NUM_V3 + UL1_DPD_MAX_PTAR_TH_NUM_V3 + UL1_DPD_MAX_IMPLICIT_RSV_NUM_V3)

//=================================C2K DPD define==========================================
#define C2K_UARFCN_SECTION                  16
#define MMRF_MAX_C2K_DPD_BAND_NUM_V3        22
#define C2K_DPD_MAX_PA_LEVEL_NUM_V3         8
#define C2K_DPD_MAX_PGA_NUM_PER_PA_V3       (1)
#define C2K_MAX_SUPPORTED_BAND_INDEX_V3     MMRF_MAX_C2K_DPD_BAND_NUM_V3
#define C2K_DPD_MAX_PA_MODE_NUM_V3          3
#define C2K_DPD_MAX_PA_HYST_NUM_V3          (C2K_DPD_MAX_PA_MODE_NUM_V3 - 1)
#define C2K_DPD_MAX_AM_LUT_GAIN_NUM_V3      (C2K_DPD_MAX_PA_LEVEL_NUM_V3 * C2K_DPD_MAX_PGA_NUM_PER_PA_V3)
#define C2K_DPD_MAX_PM_LUT_GAIN_NUM_V3      (C2K_DPD_MAX_AM_LUT_GAIN_NUM_V3)
#define C2K_DPD_FDB_NUM_V3                  (C2K_UARFCN_SECTION * C2K_DPD_MAX_PA_LEVEL_NUM_V3)
#define C2K_DPD_MAX_PTAR_TH_NUM_V3          (C2K_UARFCN_SECTION * C2K_DPD_MAX_PA_LEVEL_NUM_V3)
#define C2K_DPD_MAX_IMPLICIT_RSV_NUM_V3     (0)
#define C2K_DPD_MAX_IMPLICIT_NUM_V3         (C2K_DPD_FDB_NUM_V3 + C2K_DPD_MAX_PTAR_TH_NUM_V3 + C2K_DPD_MAX_IMPLICIT_RSV_NUM_V3)
#define MMRF_DPD_C2K_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V3      (22)

/**
 * \ingroup MultiModeStruct
 * The parameters of multi-mode DPD start command request.
 */
typedef struct
{
   /** Local buffer of this command.
    */
   MMRfTestCmdStartDpdPaAndDpdFacCalReqParam reqParam;

   /** Peer buffer of this command.
    */
   union
   {
        /** LTE DPD start command peer buffer
         */
        MMRfTestCmdLteAptRefChannelOneRoute     reqPeer[MAX_TX_ROUTE_AND_PS_NUM];

        /** WCDMA DPD start command peer buffer
         */
        MMRfTestCmdWcdmaAptRefChannelOneBand    wcdmaReqPeer[MMRF_MAX_WCDMA_DPD_BAND_NUM_V2];
   };
}MMRfTestCmdStartDpdPaAndDpdFacCalReq;

typedef enum
{
   MMRF_TEST_START_LTE_DPDPA_DPD_INVALID            = 0,
   MMRF_TEST_START_LTE_DPDPA_DPD_OK                    = 1,
   MMRF_TEST_START_LTE_DPDPA_DPD_PEER_SIZE_MISMATCH    = 2
}MMRfTestResultStartLteDpdPaAndDpdFacCalStatus;

typedef enum
{
   MMRF_TEST_START_WCDMA_DPD_INVALID                = 0,
   MMRF_TEST_START_WCDMA_DPD_OK                        = 1,
   MMRF_TEST_START_WCDMA_DPD_PEER_SIZE_MISMATCH        = 2,
   MMRF_TEST_START_WCDMA_DPD_EXCEED_TTG_LIMIT_INIT  = 3,
   MMRF_TEST_START_WCDMA_DPD_EXCEED_TTG_LIMIT        = 4,
   MMRF_TEST_START_WCDMA_DPD_NEGATIVE_TR            = 5,
   MMRF_TEST_START_WCDMA_DPD_LARGE_PA_GAIN_DIFF        = 6
}MMRfTestResultStartWcdmaDpdPaAndDpdFacCalStatus;

typedef struct
{
   unsigned short    wcdma_dpd_status; /* MMRfTestResultStartWcdmaDpdPaAndDpdFacCalStatus */
   unsigned short    curr_rf_band;
   unsigned short        curr_subband_idx;
   unsigned short        curr_gain_idx;
   short            pa_gain;
} MMRfTestResultStartWcdmaDpdCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Parameters of the local buffer for multi-mode DPD start command confirm. It's an union, so L1 can only return one RAT data in one start command.
 */
typedef union
{

   /** The local buffer for LTE DPD start command confirm.
    *  Enumeration:\n
    *  0: Invalid\n
    *  1: OK\n
    *  2: Peer buffer size mismatched
    */
   unsigned short                        lte_dpd_status;  /* MMRfTest_StartLteDpdPaAndDpdFacCal_Status */
   MMRfTestResultStartWcdmaDpdCnfInfo    wcdma_dpd_status;
}MMRfTestResultStartMmDpdCnfInfo;

/**
 * \ingroup MultiModeStruct
 * Local buffer for multi-mode DPD start command confirm.
 */
typedef struct
{
   /** Enumeration:\n
    *  1: GSM\n
    *  2: TDSCDMA\n
    *  4: CDMA2000\n
    *  8: WCDMA\n
    *  16: LTE\n
    *  Meta too set this varaible to tell the target which RAT of DPD is running
    */
   unsigned short                    rat_idx;

   /**
    * Parameters of the local buffer for multi-mode DPD start command confirm.
    */
   MMRfTestResultStartMmDpdCnfInfo    mm_dpd_cnf;
}MMRfTestResultStartDpdPaAndDpdFacCalCnfParam;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD start command confirm.
 */
typedef struct
{
   /** Local buffer for this command.
    */
   MMRfTestResultStartDpdPaAndDpdFacCalCnfParam cnfParam;
}MMRfTestResultStartDpdPaAndDpdFacCalCnf;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdPaAndDpdFacCal_V2_r
 */
META_RESULT __stdcall META_MMRf_StartDpdPaAndDpdFacCal_V2( const unsigned int ms_timeout, const MMRfTestCmdStartDpdPaAndDpdFacCalReq *req, MMRfTestResultStartDpdPaAndDpdFacCalCnf *cnf);

/**
 * \details The function for triggering DPD calibration.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is some parameters used in DPD calibration
 * \param [out] cnf is the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_StartDpdPaAndDpdFacCal_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartDpdPaAndDpdFacCalReq *req, MMRfTestResultStartDpdPaAndDpdFacCalCnf *cnf);

typedef struct
{
   unsigned char  port_sel;
   unsigned char  rw_type;
   unsigned char  usid;
   unsigned short addr;
   unsigned int   data1;
   unsigned int   data2;
   unsigned int   wait_us;
} MMRfTestCmdMipiCtrlData;

#define MMRF_EN_BSI_CW_NUMBER         64

typedef struct
{
   MMRfTestCmdMipiCtrlData   mipi[MMRF_EN_BSI_CW_NUMBER];
} MMRfTestCmdSetMipiDataReq, MMRfTestCmdGetMipiDataCnf;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetMipiData_r
 */
META_RESULT __stdcall META_MMRf_SetMipiData( const unsigned int ms_timeout, MMRfTestCmdSetMipiDataReq *req);

/**
 * \details The function for writing mipi data to DUT.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is some parameters used in mipi data.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetMipiData_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdSetMipiDataReq *req);

typedef struct
{
   unsigned char  port_sel;
   unsigned char  rw_type;
   unsigned char  usid;
   unsigned short addr;
} MMRfTestCmdGetMipiCtrlParam;

typedef struct
{
   MMRfTestCmdGetMipiCtrlParam mipi[MMRF_EN_BSI_CW_NUMBER];
} MMRfTestCmdGetMipiDataReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetMipiData_r
 */
META_RESULT __stdcall META_MMRf_GetMipiData( const unsigned int ms_timeout, MMRfTestCmdGetMipiDataReq* req, MMRfTestCmdGetMipiDataCnf *cnf);

/**
 * \details The function for reading mipi data from DUT.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is some parameters used in mipi data.
 * \param [out] cnf is the result of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetMipiData_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdGetMipiDataReq* req, MMRfTestCmdGetMipiDataCnf *cnf);

/**
 * \ingroup LTEStruct
 * \details This structure is used for querying carkit mapping information since M50 series
 */
typedef struct
{
   unsigned char queryMode;             /**< Query mode, 0: by default, 1: by condition as below(RAT, TAS state). */
   unsigned char rat_bitmap;            /**< . */
   unsigned char forced_tas_state;      /**< . */
} MMRfTestCmdQueryCarKitMappingInfoReq;

/**
 * \ingroup LTEStruct
 * \details This structure is used for indicating carkit number and name
 */
typedef struct
{
   unsigned char    carkit_enum;        /**< Carkit number. */
   char             carkit_name[16];    /**< Carkit name (ASCII Code). */
} MMRfTestParamCarKitNameMapping;

/**
 * \ingroup LTEStruct
 * \details This structure is used for indicating general carkit information
 */
typedef struct
{
   unsigned char                    is_before_switch;   /**< . */
   unsigned int                     support_carkit_num; /**< Supported carkit number. */
   MMRfTestParamCarKitNameMapping   carkit_info[32];    /**< Information of each carkit. */
} MMRfTestParamCmrInfo;

/**
 * \ingroup LTEStruct
 * \details This structure is the carkit mapping information for a band
 */
typedef struct
{
   unsigned char band;          /**< Band number. */
   unsigned char rx_car_kit;    /**< RX main path carkit number. */
   unsigned char rxd_car_kit;   /**< RX diversity path carkit number. */
   unsigned char tx_car_kit;    /**< TX carkit number. */
} MMRfTestParamCarKitInfo_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the carkit mapping information for a TX route
 */
typedef struct
{
   unsigned short tx_route_idx; /**< TX route number. */
   unsigned short band;         /**< Band number. */
   unsigned char  tx_car_kit;   /**< TX carkit number. */
} MMRfTestParamCarKitTxRouteInfo_T;

/**
 * \ingroup LTEStruct
 * \details This structure is the carkit mapping information for a RX route
 */
typedef struct
{
   unsigned short rx_route_idx; /**< RX route number. */
   unsigned short band;         /**< Band number. */
   unsigned char  rx_car_kit;   /**< RX main path carkit number. */
   unsigned char  rxd_car_kit;  /**< RX diversity path carkit number. */
} MMRfTestParamCarKitRxRouteInfo_T;


#define CMR_MAX_GSM_BAND_NUM        5
#define CMR_MAX_TDSCDMA_BAND_NUM     6
#define CMR_MAX_C2K_BAND_NUM        22
#define CMR_MAX_WCDMA_BAND_NUM      19
#define CMR_MAX_LTE_TX_ROUTE_NUM    100
#define CMR_MAX_LTE_RX_ROUTE_NUM    150

/**
 * \ingroup LTEStruct
 * \details This structure is the confirm message of querying carkit mapping information command
 */
typedef struct
{   
   unsigned char                    status;                                             /**< Query status. */
   MMRfTestParamCmrInfo             common_info;                                        /**< Common carkit information. */
   unsigned char                    gsm_count;                                          /**< GSM band and carkit pair count. */
   MMRfTestParamCarKitInfo_T        gsm_cmr_indicator[CMR_MAX_GSM_BAND_NUM];            /**< GSM band and carkit pair information. */
   unsigned char                    tdscdma_count;                                      /**< TDSCDMA band and carkit pair count. */
   MMRfTestParamCarKitInfo_T        tdscdma_cmr_indicator[CMR_MAX_TDSCDMA_BAND_NUM];    /**< TDSCDMA band and carkit pair information. */
   unsigned char                    c2k_count;                                          /**< C2K band and carkit pair count. */
   MMRfTestParamCarKitInfo_T        c2k_cmr_indicator[CMR_MAX_C2K_BAND_NUM];            /**< C2K band and carkit pair information. */
   unsigned char                    wcdma_count;                                        /**< WCDMA band and carkit pair count. */
   MMRfTestParamCarKitInfo_T        wcdma_cmr_indicator[CMR_MAX_WCDMA_BAND_NUM];        /**< WCDMA band and carkit pair information. */
   unsigned char                    lte_tx_count;                                       /**< LTE TX route and carkit pair count. */
   MMRfTestParamCarKitTxRouteInfo_T lte_tx_cmr_indicator[CMR_MAX_LTE_TX_ROUTE_NUM];     /**< LTE TX route and carkit pair information. */
   unsigned char                    lte_rx_count;                                       /**< LTE RX route and carkit pair count. */
   MMRfTestParamCarKitRxRouteInfo_T lte_rx_cmr_indicator[CMR_MAX_LTE_RX_ROUTE_NUM];     /**< LTE RX route and carkit pair information. */
}MMRfTestCmdQueryCarKitMappingInfoCnf;

/**
 * \ingroup     LTE
 * \sa          non-reentrant version of META_MMRf_QueryCarKitMappingInfo_r
 */
META_RESULT __stdcall META_MMRf_QueryCarKitMappingInfo( const unsigned int ms_timeout, MMRfTestCmdQueryCarKitMappingInfoReq* req, MMRfTestCmdQueryCarKitMappingInfoCnf *cnf);
/**
 * \details The function for reporting the car kit maaping information for DUT.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is some parameters used in queried data.
 * \param [out] cnf is the result of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_QueryCarKitMappingInfo_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdQueryCarKitMappingInfoReq* req, MMRfTestCmdQueryCarKitMappingInfoCnf *cnf);

typedef struct
{   
   unsigned int    total_chksum_cal_lsb;
   unsigned int    total_chksum_cal_msb;
}MMRfTestResultCalcCheckSumCal;

META_RESULT __stdcall META_MMRf_CalcCalItemsCheckSum( const unsigned int ms_timeout, MMRfTestResultCalcCheckSumCal *cnf);

/**
 * \details The function for reporting the car kit maaping information for DUT.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is some parameters used in queried data.
 * \param [out] cnf is the result of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_CalcCalItemsCheckSum_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestResultCalcCheckSumCal *cnf);

//-----------------------------------------------------//
//  DPD Factory Calibration Tool Interface             //
//-----------------------------------------------------//

typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
} MMRfTestCmdCim3FacStartReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartCim3FacCal_r
 */
META_RESULT __stdcall META_MMRf_StartCim3FacCal( const unsigned int ms_timeout, const MMRfTestCmdCim3FacStartReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartCim3FacCal_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdCim3FacStartReq* req);
#define MAX_CIM3_PA_GAIN_NUM               MAX_DPD_PA_GAIN_NUM
#define MAX_CIM3_LUT_GAIN_NUM              60 /* 40 PA*PGA gain combination */
#define MAX_CIM3_LUT_CHANNEL_NUM            2 /* 2 TX channel type (PRACH and PUxCH) */
typedef enum
{
    MMRF_TEST_CIM3_ALGO_PARAM = 0,
    MMRF_TEST_CIM3_LUT = 1
} MMRfTestCIM3FacCmdType;

typedef struct
{
    short  a1; /* bit  0~15, actual: S1.10 */
    short  a2; /* bit 16~31, actual: S1.10 */
} MMRfTestCim3Lut;
typedef struct
{
    MMRfTestCim3Lut    lut[MAX_CIM3_LUT_GAIN_NUM][MAX_CIM3_LUT_CHANNEL_NUM];
} MMRfTestCim3LutSubBand;
typedef struct
{
    MMRfTestCim3LutSubBand    cim3_lut_subband[MAX_FHC_TX_FREQ_NUM_EX];
} MMRfTestCim3LutPerBand;
typedef struct
{
    unsigned short  lte_cim3_meas_ofst_reg[MAX_LTE_CBW_NUM];
} MMRfTestCIM3FacAlgoParam;
typedef struct
{
    unsigned short              cim3_subband_freq[MAX_FHC_TX_FREQ_NUM_EX];
    MMRfTestCIM3FacAlgoParam    cim3_algo_param;
} MMRfTestCim3FacParamSet;
typedef union
{
    MMRfTestCim3FacParamSet    cim3_fac_set;
    MMRfTestCim3LutPerBand     cim3_lut_per_band;
} MMRfTestCim3FacIO;
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
    unsigned short    lut_param_type;    /* 0:MMRF_TEST_CIM3_ALGO_PARAM  1:MMRF_TEST_CIM3_LUT  */
    unsigned short    signal_path;
} MMRfTestCim3GetFacParamReq;
typedef struct
{
    unsigned short       rat_idx;
    unsigned short       rf_band_idx;
    unsigned short       lut_param_type;
    unsigned short       signal_path;
    MMRfTestCim3FacIO    param;
} MMRfTestCim3GetFacParamCnf;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetCim3FacCalParam_r
 */
META_RESULT __stdcall META_MMRf_GetCim3FacCalParam( const unsigned int ms_timeout, const MMRfTestCim3GetFacParamReq* req, MMRfTestCim3GetFacParamCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetCim3FacCalParam_r(  const int meta_handle, const unsigned int ms_timeout, const MMRfTestCim3GetFacParamReq* req, MMRfTestCim3GetFacParamCnf* cnf);
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    rf_band_idx;
    unsigned short    lut_param_type;
    unsigned short    signal_path;
    MMRfTestCim3FacIO param;
} MMRfTestCim3SetFacParamReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetCim3FacCalParam_r
 */
META_RESULT __stdcall META_MMRf_SetCim3FacCalParam( const unsigned int ms_timeout, const MMRfTestCim3SetFacParamReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetCim3FacCalParam_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCim3SetFacParamReq* req);
typedef struct
{
    unsigned short  rat_idx;    /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned short  cim3_switch;
} MMRfTestCim3FacEnDisReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_Cim3Enable_r
 */
META_RESULT __stdcall META_MMRf_Cim3Enable( const unsigned int ms_timeout, const MMRfTestCim3FacEnDisReq* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_Cim3Enable_r(  const int meta_handle, const unsigned int ms_timeout, const MMRfTestCim3FacEnDisReq* req);

/* MMRF Self K */
#define MMRF_MAX_RF_SELF_K_LID_COUNT          (64)
/**
 * \ingroup MultiModeStruct
 * which is the upper limit of character number for name of each RF self-calibration item
 */
#define MMRF_MAX_RF_SELF_K_STRING_LENGTH      (64)
#define MMRF_MAX_RF_SELF_K_DBG_INFO_COUNT     (128)

/**
 * \ingroup MultiModeStruct
 * which is the upper-bound of self-calibration items
 */
#define MMRF_MAX_RF_SELF_K_LID_COUNT_V2       (256)
/**
 * \ingroup MultiModeStruct
 * the upper limit of items to be reported in one command
 */
#define MMRF_MAX_RF_SELF_K_LID_COUNT_PDU      (16)
/**
 * \ingroup MultiModeStruct
 * 60kB (60<<10); limited by size of ilm-message buffer
 */
#define MMRF_MAX_RF_SELF_K_PDU_SIZE           (60<<10)
/**
 * \ingroup MultiModeStruct
 * which is the upper limit of debug trace number
 */
#define MMRF_MAX_RF_SELF_K_DBG_INFO_COUNT_V2  (256)



typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  do_self_k;      // 0: get total LID num, bypass cal; 1: get total LID num and do cal
} MMRfTestCmdStartRfSelfKReq;

/**
 * \ingroup MultiModeStruct
 * This structure is used to assign parameters for triggering RF self-calibration
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
   unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
   unsigned short  self_k_stage;

   /** 0: for getting total LID num from driver only, self-cal flow would be bypassed\n
    *  1: get total LID num and do cal
    */
   unsigned short  do_self_k;

} MMRfTestCmdStartRfSelfKReqV2;

typedef struct
{
    unsigned short  rat_idx;       // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_total_num;
    unsigned short  is_error_occur;
} MMRfTestResultStartRfSelfKCnf;

/**
 * \ingroup MultiModeStruct
 * This structure is the confirm message of RF self-calibration, which indexing the self-calibration results
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
   unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
   unsigned short  self_k_stage;

   /** 0: stage not support\n
    *  1: process OK
    */
   unsigned short  stage_set_sts;

   /** Total item count of RF self-calibration results
    */
   unsigned short  total_item_cnt;

   /** Item index list of RF self-calibration results
    */
   unsigned short  item_index[MMRF_MAX_RF_SELF_K_LID_COUNT_V2];

   /** Memory size in unit of byte for each item of RF self-calibration results
    */
   unsigned short  item_size[MMRF_MAX_RF_SELF_K_LID_COUNT_V2];

} MMRfTestResultStartRfSelfKCnfV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartSelfCal_r
 */
META_RESULT __stdcall META_MMRf_StartSelfCal( const unsigned int ms_timeout, const MMRfTestCmdStartRfSelfKReq* req, MMRfTestResultStartRfSelfKCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartSelfCal_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartRfSelfKReq* req, MMRfTestResultStartRfSelfKCnf* cnf);

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartSelfCal_V2_r
 */
META_RESULT __stdcall META_MMRf_StartSelfCal_V2( const unsigned int ms_timeout, const MMRfTestCmdStartRfSelfKReqV2* req, MMRfTestResultStartRfSelfKCnfV2* cnf);
/**
 * \details For triggering RF self-calibration
 * \ingroup MultiMode
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Parameters for triggering RF self-calibration (RAT, stage of self-calibration)
 * \param [out] cnf Indexing of RF self-calibration results (total item count, item index, and size for each item)
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_StartSelfCal_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartRfSelfKReqV2* req, MMRfTestResultStartRfSelfKCnfV2* cnf);
typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_index;
} MMRfTestCmdGetRfSelfKReq;

/**
 * \ingroup MultiModeStruct
 * This structure is used to assign parameters for querying calibration results (raw data) from L1 driver
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
   unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
   unsigned short  self_k_stage;

   /** Total item count of RF self-calibration results to be queried; the upper limit of this value should be less than 16 due to limit of ilm-message size
    */
   unsigned short  total_item_cnt;

   /** Item index of RF self-calibration results to be queried
    */
   unsigned short  item_index[MMRF_MAX_RF_SELF_K_LID_COUNT_PDU];

} MMRfTestCmdGetRfSelfKReqV2;

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_index;
    unsigned short  lid_size;
    unsigned char   cal_data[16 * 1024]; // Max size: 16K
} MMRfTestCmdGetRfSelfKCnf;

/**
 * \ingroup MultiModeStruct
 * This structure is the confirm message of queried calibration results (raw data) from L1 driver
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
    unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
    unsigned short  self_k_stage;

   /** 0: stage not support\n
    *  1: process OK
    */
    unsigned short  stage_set_sts;

   /** Total item count of RF self-calibration results to be queried; the upper limit of this value should be less than 16 due to limit of ilm-message size
    */
    unsigned short  total_item_cnt;

   /** Item index list of queried RF self-calibration results
    */
    unsigned short  item_index[MMRF_MAX_RF_SELF_K_LID_COUNT_PDU];

   /** Item size for each queried RF self-calibration results
    */
    unsigned short  item_size [MMRF_MAX_RF_SELF_K_LID_COUNT_PDU];

   /** Memory offset (in unit of byte) for accessing PDU for each queried RF self-calibration results
    */
    unsigned short  mem_offset[MMRF_MAX_RF_SELF_K_LID_COUNT_PDU];

   /** PDU, the queried calibration results (raw data) from L1 driver; not that the total size should be less than 60kB due to ilm-message buffer limit
    */
    unsigned char   data_buffer[MMRF_MAX_RF_SELF_K_PDU_SIZE];
} MMRfTestCmdGetRfSelfKCnfV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetSelfCalData_r
 */
META_RESULT __stdcall META_MMRf_GetSelfCalData(  const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKReq* req, MMRfTestCmdGetRfSelfKCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetSelfCalData_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKReq* req, MMRfTestCmdGetRfSelfKCnf* cnf);
/**
 * \ingroup MultiMode
  * \sa non-reentrant version of META_MMRf_GetSelfCalData_V2_r
 */
META_RESULT __stdcall META_MMRf_GetSelfCalData_V2( const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKReqV2* req, MMRfTestCmdGetRfSelfKCnfV2* cnf);

/**
 * \details For querying calibration results (raw data) from L1 driver
 * \ingroup MultiMode
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Parameters for querying calibration results (raw data) from L1 driver
 * \param [out] cnf Queried RF self-calibration results (raw data) from L1 driver
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetSelfCalData_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKReqV2* req, MMRfTestCmdGetRfSelfKCnfV2* cnf);

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_index;
    unsigned short  lid_size;
    unsigned char   cal_data[16 * 1024]; // Max size: 16K
} MMRfTestCmdSetRfSelfKReq;

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  self_k_stage;   // 0: RF self-calibration: stage0, 1: RF self-calibration: stage1
    unsigned short  total_item_cnt; // total count should be less than 16
    unsigned short  item_index[MMRF_MAX_RF_SELF_K_LID_COUNT_PDU]; // list of item index
    unsigned short  item_size [MMRF_MAX_RF_SELF_K_LID_COUNT_PDU]; // size of item
    unsigned short  mem_offset[MMRF_MAX_RF_SELF_K_LID_COUNT_PDU]; // mem offset in peer buffer of each item
    unsigned char   data_buffer[MMRF_MAX_RF_SELF_K_PDU_SIZE];  // total size should be less than 37kB
} MMRfTestCmdSetRfSelfKReqV2;

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_index;
} MMRfTestResultSetRfSelfKCnf;

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  self_k_stage;   // 0: RF self-calibration: stage0, 1: RF self-calibration: stage1
    unsigned short  stage_set_sts;  // 0: stage not support, 1: process OK
    unsigned short  total_item_cnt; // total count should be less than 16
    unsigned short  item_index[MMRF_MAX_RF_SELF_K_LID_COUNT_PDU]; // total size should be less than 60kB
} MMRfTestResultSetRfSelfKCnfV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetSelfCalData_r
 */
META_RESULT __stdcall META_MMRf_SetSelfCalData(  const unsigned int ms_timeout, const MMRfTestCmdSetRfSelfKReq* req, MMRfTestResultSetRfSelfKCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetSelfCalData_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetRfSelfKReq* req, MMRfTestResultSetRfSelfKCnf* cnf);
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetSelfCalData_V2_r
 */
META_RESULT __stdcall META_MMRf_SetSelfCalData_V2( const unsigned int ms_timeout, const MMRfTestCmdSetRfSelfKReqV2* req, MMRfTestResultSetRfSelfKCnfV2* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetSelfCalData_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetRfSelfKReqV2* req, MMRfTestResultSetRfSelfKCnfV2* cnf);

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_index;
} MMRfTestCmdGetRfSelfKDataLenReq;

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_index;
    unsigned short  lid_size;
} MMRfTestCmdGetRfSelfKDataLenCnf;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetSelfCalDataLen_r
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDataLen(  const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKDataLenReq* req, MMRfTestCmdGetRfSelfKDataLenCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDataLen_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKDataLenReq* req, MMRfTestCmdGetRfSelfKDataLenCnf* cnf);

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
} MMRfTestCmdGetRfSelfKStrReq;

/**
 * \ingroup MultiModeStruct
 * This structure is used to assign parameters for querying the name of RF self-calibration results
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
    unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
    unsigned short  self_k_stage;
} MMRfTestCmdGetRfSelfKStrReqV2;

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_total_num;
    char    key[64/*LID index*/][64/*string length*/];
} MMRfTestCmdGetRfSelfKStrCnf;

/**
 * \ingroup MultiModeStruct
 * This structure is the confirm message of queried name list of RF self-calibration results
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
    unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
    unsigned short  self_k_stage;

   /** 0: stage not support\n
    *  1: process OK
    */
    unsigned short  stage_set_sts;

   /** Total count of names for all the RF self-calibration results
    */
    unsigned short  total_item_cnt;

   /** Buffer for name list of all RF self-calibration results; note that the name strings are in ASCII format
    */
    char            key[MMRF_MAX_RF_SELF_K_LID_COUNT_V2][MMRF_MAX_RF_SELF_K_STRING_LENGTH];
} MMRfTestCmdGetRfSelfKStrCnfV2;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetSelfCalDataString_r
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDataString(  const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKStrReq* req, MMRfTestCmdGetRfSelfKStrCnf* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDataString_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKStrReq* req, MMRfTestCmdGetRfSelfKStrCnf* cnf);

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetSelfCalDataString_V2_r
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDataString_V2( const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKStrReqV2* req, MMRfTestCmdGetRfSelfKStrCnfV2* cnf);
/**
 * \details For querying the name for all the RF self-calibration results
 * \ingroup MultiMode
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Parameters for querying the name for all the RF self-calibration results
 * \param [out] cnf Queried name list for all the RF self-calibration results
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDataString_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKStrReqV2* req, MMRfTestCmdGetRfSelfKStrCnfV2* cnf);

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
} MMRfTestCmdGetRfSelfKDbgInfo;

/**
 * \ingroup MultiModeStruct
 * This structure is used to assign parameters for querying "debug log" of RF self-calibration from L1 driver
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
   unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
   unsigned short  self_k_stage;

} MMRfTestCmdGetRfSelfKDbgInfoReqV2;

typedef struct
{
    unsigned short  rat_idx;        // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  lid_entry_num;
    char    dbg_info[128/*Entry index*/][64/*string length*/];
} MMRfTestResultGetRfSelfKDbgInfo;

/**
 * \ingroup MultiModeStruct
 * This structure is the confirm message for querying "debug log" of RF self-calibration from L1 driver, note that the log is in format of ASCII code
 */
typedef struct
{
   /** Enumeration:\n
    *   1: GSM\n
    *   2: TDSCDMA\n
    *   4: CDMA2000\n
    *   8: WCDMA\n
    *   16: LTE
    */
   unsigned short  rat_idx;

   /** 0: RF self-calibration: stage0\n
    *  1: RF self-calibration: stage1
    */
   unsigned short  self_k_stage;

   /** 0: stage not support\n
    *  1: process OK
    */
   unsigned short  stage_set_sts;

   /** Entry number of debug log
    */
   unsigned short  dbg_info_entry_num;

   /** Debug log of RF self-calibration; driver would check self-calibration results runtime and leave some traces once abnormal case detected
    */
    char    dbg_info[MMRF_MAX_RF_SELF_K_DBG_INFO_COUNT_V2][MMRF_MAX_RF_SELF_K_STRING_LENGTH];

} MMRfTestResultGetRfSelfKDbgInfoCnfV2;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetSelfCalDebugInfo_r
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDebugInfo( const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKDbgInfo* req, MMRfTestResultGetRfSelfKDbgInfo* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDebugInfo_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKDbgInfo* req, MMRfTestResultGetRfSelfKDbgInfo* cnf);

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetSelfCalDebugInfo_V2_r
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDebugInfo_V2( const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKDbgInfoReqV2* req, MMRfTestResultGetRfSelfKDbgInfoCnfV2* cnf);
/**
 * \details For querying debug log from L1 driver
 * \ingroup MultiMode
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [in] req Parameters for querying "debug log" of RF self-calibration from L1 driver
 * \param [out] cnf Confirm parameters for querying "debug log" of RF self-calibration from L1 driver
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetSelfCalDebugInfo_V2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfSelfKDbgInfoReqV2* req, MMRfTestResultGetRfSelfKDbgInfoCnfV2* cnf);

#define MMRFC_RSLT_DUMP_TONE_SUPPORT            28
#define MMRFC_RSLT_DUMP_GAIN_SUPPORT            8
#define MMRFC_RSLT_DUMP_CABAND_SUPPORT          5
// Dump Config Margin Check
#define MMRFC_RSLT_DUMP_CFG_MARGIN_NUM          10
#define MMRFC_RSLT_DUMP_DUMP_CFG_NUM            2
#define MMRFC_RSLT_DUMP_RESERVE_NUM             (MMRFC_RSLT_DUMP_CFG_MARGIN_NUM - MMRFC_RSLT_DUMP_DUMP_CFG_NUM)
// Dump Postdata Margin Check
#define MMRFC_RSLT_DUMP_POSTDATA_MARGIN_NUM     5000
#define MMRFC_RSLT_DUMP_POSTDATA_FS_RATE_NUM    1
#define MMRFC_RSLT_DUMP_RESERVE_POSTDATA_NUM    (MMRFC_RSLT_DUMP_POSTDATA_MARGIN_NUM-MMRFC_RSLT_DUMP_POSTDATA_FS_RATE_NUM)



typedef struct
{
    int opt_code;     // IRR/Gain/Phase/GA...etc
    int opt_code2;   // Reserve
    int rat_idx;        // MMRfTestCmd_RatIndicator
    int ca_band[MMRFC_RSLT_DUMP_CABAND_SUPPORT];
    int meas_band_index;
    int test_idx;  // 0:1st_run, 1:rerun, 2:rerun_w_nvram_result
    int test_item;       // 0:MMPOC_RXIRR_IQ_CAL, 1:MMPOC_RXIRR_IQ_CAL(RXIQ), 2:MMPOC_DETIQDC_DNL_CAL, 3:MMPOC_TXIQ_CAL, 4:MMPOC_TXGA_CAL
    int mode_idx;       // RX(0:Primary, 1:Diversity), TX(0:Normal, 1:DPD)
    int cbw_idx;          // 0x0:BW1p4, 0x1:BW3, 0x2:BW5, 0x3:BW10, 0x4:BW15, 0x5:BW20, 0x6:BW30, 0x7:BW35, 0x8:BW40, 0x9:BW50, 0xA:BW60, 0x10GSM_SC, 0x20:WCDMA_SC, 0x21:WCDMA_DC, 0x22:WCDMA_3C, 0x30:TDS_SC, 0x31TDS_DC,
    int dump_cfg[MMRFC_RSLT_DUMP_DUMP_CFG_NUM]; // MMPOC_RXIRR_IQ_CAL: gain, MMPOC_TXIQ_CAL: subband ; MMPOC_RXIRR_IQ_CAL: tone, MMPOC_TXIQ_CAL: tx_route
    int reserve[MMRFC_RSLT_DUMP_RESERVE_NUM];
}MMRfTestCmdStartRFSelfTestAnalyzer;

typedef struct
{
   int  opt_code;
   int  opt_code2;
   int  n_tone;
   int  n_gain;     // Dimension depend on RF (8 Slice)
   int  tone_freq[MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  gain_est_pos[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  gain_est_neg[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  phase_est_pos[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  phase_est_neg[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  mean_tone_pos_re[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  mean_tone_pos_im[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  mean_tone_neg_re[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   int  mean_tone_neg_im[MMRFC_RSLT_DUMP_GAIN_SUPPORT][MMRFC_RSLT_DUMP_TONE_SUPPORT];
   short  data_dump_i[8192];
   short  data_dump_q[8192];
   /******* Below region share memory size of kal_int32*5400 *******/
   int  fs_rate;  // Change MMRFC_RSLT_DUMP_POSTDATA_FS_RATE_NUM when sizeof(fs_rate) modified
   int  reserve[MMRFC_RSLT_DUMP_RESERVE_POSTDATA_NUM];    // To avoid violate META command buffer limitation, please use these reserve memory size to create new test condition
   /******* Above region share memory size of kal_int32*5400 *******/
   int  status;    // 0:not start, 1:pass, 2:wrong rat, 3:wrong cal item
}MMRfAnalyzerMeasureResult;

typedef struct
{
   MMRfAnalyzerMeasureResult post_result;
}MMRfTestResultStartRFSelfTestAnalyzerRpt;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartSelfTestAnalyzer_r
 */
META_RESULT __stdcall META_MMRf_StartSelfTestAnalyzer( const unsigned int ms_timeout, const MMRfTestCmdStartRFSelfTestAnalyzer* req, MMRfTestResultStartRFSelfTestAnalyzerRpt* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartSelfTestAnalyzer_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartRFSelfTestAnalyzer* req, MMRfTestResultStartRFSelfTestAnalyzerRpt* cnf);

typedef struct
{
    unsigned short  dpdAmValueCheckMax;
    unsigned short  dpdAmValueCheckMin;
    short  dpdPmValueCheckMax;
    short  dpdPmValueCheckMin;
} MMRfDpdValueRangeCheck;

typedef struct
{
    short  cim3ValueCheckMax;
    short  cim3ValueCheckMin;
} MMRfCIM3ValueRangeCheck;

typedef struct
{
    unsigned short  paIdx;
    unsigned short  pgaIdx;
} MMRfEachLutIdxMapInfo;

typedef struct
{
    unsigned short  band;
    unsigned short  supportSubBandNum;
} MMRfSubBandInfo;

typedef struct
{
    unsigned short  supportGainNum;
    unsigned short  supportpaSettingNum;
    unsigned short  pgaMaxNumForEachPA[MAX_DPD_PA_GAIN_NUM];
    MMRfSubBandInfo         subBandInfo[MMRF_MAX_BAND_NUM];
    MMRfDpdValueRangeCheck  valueRangeCheck;
    MMRfEachLutIdxMapInfo   eachLutIdxInfo[MAX_DPD_AM_LUT_GAIN_NUM] ;
} MMRfDpdLutConfig;

typedef struct
{
    unsigned short  supportGainNum;
    unsigned short  supportpaSettingNum;
    unsigned short  pgaMaxNumForEachPA[MAX_CIM3_PA_GAIN_NUM];
    MMRfSubBandInfo          subBandInfo[MMRF_MAX_BAND_NUM];
    MMRfCIM3ValueRangeCheck  valueRangeCheck;
    MMRfEachLutIdxMapInfo    eachLutIdxInfo[MAX_CIM3_LUT_GAIN_NUM];
} MMRfCim3LutConfig;

typedef union
{
    MMRfDpdLutConfig   dpdLutConfig;
    MMRfCim3LutConfig  cim3LutConfig;
} MMRfDpdCim3LutConfig;

typedef struct
{
    unsigned short  rat_idx;
    unsigned short  lut_type;  ///< 0 for DDP, 1 for Cim3
} MMRfTestCmdGetLUTConfig;

typedef struct
{
    unsigned short  rat_idx;
    unsigned short  lut_type;
    MMRfDpdCim3LutConfig  param;
} MMRfTestResultGetLUTConfig;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdCim3LUTConfig_r
 */
META_RESULT __stdcall META_MMRf_GetDpdCim3LUTConfig(const unsigned int ms_timeout, const MMRfTestCmdGetLUTConfig* req, MMRfTestResultGetLUTConfig* cnf);

/**
 * \ingroup MultiMode
 * \details Get DPD CIM3 LUT configuration for MMRF tool GUI usage
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req Get DPD CIM3 LUT configuration parameter
 * \param cnf Result for DPD CIM3 LUT configuration
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_GetDpdCim3LUTConfig_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetLUTConfig* req, MMRfTestResultGetLUTConfig* cnf);
#define MAX_MMRF_ET_NUM_BAND                  31

/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of ET mode TX sub-band division
 */
#define MAX_MMRF_ET_NUM_SUBBAND                8
#define MAX_MMRF_ET_NUM_RB_IDX                16
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of ET mode rb case division
 */
#define MAX_MMRF_ET_NUM_RB_IDX_V2             36
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of ET look up table entry
 */
#define MAX_MMRF_ET_LUT_PWR_NUM               32
#define MAX_MMRF_ET_NUM_CBW                    6
#define MAX_MMRF_ET_NUM_TEMP                   8
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of routes calibration results in one command
 */
#define MMRF_MAX_LTE_ET_SET_DATA_NUM          13
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of routes calibration results in one command
 */
#define MMRF_MAX_LTE_ET_GET_DATA_NUM       MMRF_MAX_LTE_ET_SET_DATA_NUM
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of ET mode backoff rb case
 */
#define ET_NUM_BACKOFF                         2
#define ET_NUM_POUTGAINOFF                     4
#define ERF_FILTER_MAX_SUPPORT_BAND_NUM        5
#define ERF_HRM_MAX_SUPPORT_BAND_NUM           5
#define MAX_FHC_TX_TYPE1_ROUTE_NUM_V2_FOR_ET 256
#define ERF_MAX_BAND_NUM_V2_FOR_ET            35
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number Tx routes
 */
#define MMRF_MAX_ET_NUM_ROUTE              (MAX_FHC_TX_TYPE1_ROUTE_NUM_V2_FOR_ET + ERF_MAX_BAND_NUM_V2_FOR_ET + ERF_FILTER_MAX_SUPPORT_BAND_NUM + ERF_HRM_MAX_SUPPORT_BAND_NUM)
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of et lab k results in tool one command
 */
#define MMRF_MAX_ET_START_ROUTE_NUM_V2        49
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number of ET mode Tx channel bandwidth
 */
#define MAX_MMRF_ET_NUM_CBW_V2                 9
/**
 * \ingroup MultiModeStruct
 * the maximum allowable number Tx routes if Tx support Alternative CCA route
 */
#define MMRF_MAX_ET_NUM_ROUTE_EX             522

/**
 * \ingroup LTEStruct
 * This enum is used to separate different ET generations
 */
typedef enum
{
   ERF_TEST_LTE_ET_V1 = 0,
   ERF_TEST_LTE_ET_V2 = 1,
   ERF_TEST_LTE_ET_V3 = 2,
   ERF_TEST_LTE_ET_V5 = 3
}ERfTestLteEtGeneration;

/**
 * \ingroup MultiModeStruct
 * This structure is used to separate different rat ET calibrtion
 */
typedef struct
{
   unsigned short rat_idx; /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
} MMRfTestCmdEtCalStartDim;
/**
 * \ingroup MultiModeStruct
 * This structure is used for setting ET lab calibration results to factory calibration
 */
typedef struct
{
  /** ET LUT0 Gain compression results for each band and subband
   */
   unsigned short GainComp_dB_0[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND];
   /** ET LUT1 Gain compression results from lab tuing
   */
   short GainComp_dB_1[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND];
   /** Difference between ET mode PA gain and APT mode PA gain
   */
   short pa_gain_adjustment[MAX_MMRF_ET_NUM_BAND];
   /** ET path delay results from lab tuning
   */
   short GrpDelayoffset_0[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX];
   short GrpDelayoffset_1[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX];
   unsigned short ETKStep2VpaTarget[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short ETKStep2Gain[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short ETKStep2DC[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short ETKFlag;
} MMRfTestCmdEtCalStartParam;
typedef struct
{
    MMRfTestCmdEtCalStartDim   et_cal_start_dim;
    MMRfTestCmdEtCalStartParam et_cal_start_param;
} MMRfTestCmdStartEtCalReq;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtCal_r
 */
META_RESULT __stdcall META_MMRf_StartEtCal(const unsigned int ms_timeout, const MMRfTestCmdStartEtCalReq* req);
/**
 * \ingroup MultiMode
 * \details Start ET calibration
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req ET cal parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_StartEtCal_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartEtCalReq* req);
typedef struct
{
   unsigned short rat_idx;
   unsigned short rf_band_idx;
   unsigned short signal_path;
} MMRfTestCmdEtCalSetGetDim;
typedef struct
{
   MMRfTestCmdEtCalSetGetDim et_cal_set_get_dim;
} MMRfTestCmdGetEtCalSetting;
typedef struct
{
   unsigned short VinVpaLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM];
   short          VinPmLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM];
   unsigned short VinAmLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM];
   short          PathDelay[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_CBW];
   short          Pout_max[MAX_MMRF_ET_NUM_SUBBAND];
   short          Pout_gain_offset[MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short GainComp_dB [MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short GainComp_dB_delta[MAX_MMRF_ET_NUM_SUBBAND];
   short          PathDelayOffsetByTemp[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_CBW][MAX_MMRF_ET_NUM_TEMP];
   short          GrpDlyOfstBySubband[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX];
   short          PaGainAdjustStep1;
   short          PaGainFineTuneStep1[MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short TwoLUTPwrThreshold[MAX_MMRF_ET_NUM_SUBBAND];
   unsigned int   EtCalDoneFlag;
} MMRfTestCmdEtCalResult_0;
typedef struct
{
   unsigned short VinVpaLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM];
   short          VinPmLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM];
   unsigned short VinAmLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM];
   short          PathDelay[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_CBW];
   short          Pout_max[MAX_MMRF_ET_NUM_SUBBAND];
   short          Pout_gain_offset[MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short GainComp_dB[MAX_MMRF_ET_NUM_SUBBAND];
   unsigned short GainComp_dB_delta[MAX_MMRF_ET_NUM_SUBBAND];
   short          GrpDlyOfstBySubband[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX];
} MMRfTestCmdEtCalResult_1;
typedef struct
{
   MMRfTestCmdEtCalResult_0 et_cal_fac_param_0;
   MMRfTestCmdEtCalResult_1 et_cal_fac_param_1;
} MMRfTestResultGetEtCalSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtCalSetting_r
 */
META_RESULT __stdcall META_MMRf_GetEtCalSetting(const unsigned int ms_timeout, const MMRfTestCmdGetEtCalSetting* req, MMRfTestResultGetEtCalSetting* cnf);
/**
 * \ingroup MultiMode
 * \details Get ET calibration result
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req get ET cal setting parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_GetEtCalSetting_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetEtCalSetting* req, MMRfTestResultGetEtCalSetting* cnf);
typedef struct
{
   MMRfTestCmdEtCalSetGetDim     et_cal_set_get_dim;
   MMRfTestResultGetEtCalSetting et_cal_fac_param;
} MMRfTestCmdSetEtCalSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetEtCalSetting_r
 */
META_RESULT __stdcall META_MMRf_SetEtCalSetting(const unsigned int ms_timeout, const MMRfTestCmdSetEtCalSetting* req);
/**
 * \ingroup MultiMode
 * \details Get ET calibration result
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req get ET cal setting parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_SetEtCalSetting_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetEtCalSetting* req);
typedef struct
{
    unsigned short rat_idx;
} MMRfTestCmdEtPathDelayCheckResult;
typedef struct
{
    unsigned int   EtCalDoneFlag[MAX_MMRF_ET_NUM_BAND];                        /*to check if FHC/ETK done already*/
    unsigned short Band[MAX_MMRF_ET_NUM_BAND];                                 /*band indicator*/
    unsigned short SubbandFreq[MAX_MMRF_ET_NUM_BAND][MAX_MMRF_ET_NUM_SUBBAND]; /*subband frequency*/
} MMRfTestResultEtPathDelayCheckResult;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtPathDelayCheckResult_r
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResult(const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayCheckResult* req, MMRfTestResultEtPathDelayCheckResult* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResult_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayCheckResult* req, MMRfTestResultEtPathDelayCheckResult* cnf);
typedef struct
{
    unsigned short rat_idx;
    unsigned short Band;
    unsigned short SubbandFreq;
    unsigned short RbIdx;
    short          Offset;
    unsigned short signal_path;
} MMRfTestCmdEtPathDelayStartSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtPathDelaySearch_r
 */
META_RESULT __stdcall META_MMRf_StartEtPathDelaySearch(const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayStartSetting* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartEtPathDelaySearch_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayStartSetting* req);
typedef enum
{
    MMRF_TEST_ET_NORMAL_TX_MODE = 0,
    MMRF_TEST_ET_FORCE_APT_MDOE = 1,
    MMRF_TEST_ET_FORCE_ET_MDOE = 2
} MMRfTestETMode;

typedef struct
{
    short la_gain;
    short la_dac;
    short lfp_dac;
    short hfp_dac;
} MMRfForceEtSetting;

typedef union
{
    MMRfForceEtSetting force_et_setting;
} MMRfEtSetting;
typedef struct
{
    unsigned short rat_idx;
    unsigned short et_mode;
    MMRfEtSetting et_setting;
} MMRfTestCmdEtModeSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_EtModeSetting_r
 */
META_RESULT __stdcall META_MMRf_EtModeSetting(const unsigned int ms_timeout, const MMRfTestCmdEtModeSetting* req);
/**
 * \ingroup MultiMode
 * \details ET mode setting before staring TX
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req ET mode setting configuration
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_EtModeSetting_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtModeSetting* req);


typedef enum
{
   MMRF_TEST_TOOL_USAGE_NORMAL      = 0,
   MMRF_TEST_TOOL_USAGE_K           = 1,
   MMRF_TEST_TOOL_USAGE_ET_K        = 2,
   MMRF_TEST_TOOL_USAGE_DPD_START   = 3,
   MMRF_TEST_TOOL_USAGE_DPD_DEFAULT = 4,
   MMRF_TEST_TOOL_USAGE_TRAD_NSFT_START  = 5,
   MMRF_TEST_TOOL_USAGE_TRAD_NSFT_STOP   = 6,
   MMRF_TEST_TOOL_USAGE_TRAD_CAL_START   = 7,
   MMRF_TEST_TOOL_USAGE_TRAD_CAL_STOP    = 8

} MMRfTestSetToolUsageToL1ModeType;

/**
 * \ingroup MultiModeStruct
 * This structure is used for separating different rat and kinds of ET calibration
 */
typedef struct
{
   /** Enumeration:\n
    * 1: GSM\n
    * 2: TDSCDMA\n
    * 4: CDMA2000\n
    * 8: WCDMA\n
    * 16: LTE
    */
    unsigned short  rat_idx;               /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    /** How many routes in one command
    */
    unsigned short  route_num;         /* The number of route in this start command */
    /** Set different kinf of ET calibration
    *  - 0 and 1 are factory k , 2 is ET RF gain index lab k, 3 is GC and delay search lab k
    */
    unsigned short  cmd_set_done;   /* last start command indicator. 0:No, 1:Yes 2:RF gain idx labk 3:GC delay search labk */
} MMRfTestCmdEtCalStartDimV2;

/**
 * \ingroup MultiModeStruct
 * This structure is used for setting ET lab calibration results to factory calibration by route
 */
typedef struct
{
    /* 92 ET increase */
    /** LTE band number of this route
    */
    unsigned short    rf_band;
    /** Acutal TX route index
    */
    unsigned short    route_idx;
    /** TX path selection (enumeration):\n
    *  0: normal-path + non-CCA setting\n
    *  1: filtered-path + non-CCA setting\n
    *  2: bypass-path + CCA setting\n
    *  3: filtered-path + CCA setting
    */
    unsigned short    path_select;
    /*92 ET PA Gain k increase*/
    /** Reserved for ET mode pa supply voltage, not used here
    */
    unsigned short    pa_supply_voltage_et;
    /** ET LUT0 Gain compression results for each subband
    */
    unsigned short    GainComp_dB_0[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for ET LUT1 Gain compression results for each subband
    */
    unsigned short    GainComp_dB_1[MAX_MMRF_ET_NUM_SUBBAND];
    /** RF gain index results from RF gain index labk
    */
    short             pa_gain_adjustment[MAX_MMRF_ET_NUM_SUBBAND];
    /** LUT0 ET path delay results from lab tuning
     */
    short             GrpDelayoffset_0[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX_V2];
    /** Reserved for LUT1 ET path delay results from lab tuning, not used here
     */
    short             GrpDelayoffset_1[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX_V2];
    /** Reserved for old method ET factory k step2
     */
    unsigned short    ETKStep2VpaTarget[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for old method ET factory k step2
     */
    unsigned short    ETKStep2Gain[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for old method ET factory k step2
     */
    unsigned short    ETKStep2DC[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for old method ET factory k step2
     */
    unsigned short    ETKFlag;
} MMRfTestCmdEtCalStartParamV2;

/**
 * \ingroup MultiModeStruct
 * This structure is used for setting ET factory K needed information by route
 */
typedef struct
{
    /** Basic information of this command
    */
    MMRfTestCmdEtCalStartDimV2   et_cal_start_dim_v2;
    /** ET lab k results of these routes
    */
    MMRfTestCmdEtCalStartParamV2 et_cal_start_param_v2[MMRF_MAX_ET_START_ROUTE_NUM_V2];
} MMRfTestCmdStartEtCalReqV2;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtCal_V2_r
 */
META_RESULT __stdcall META_MMRf_StartEtCal_V2(const unsigned int ms_timeout, const MMRfTestCmdStartEtCalReqV2* req);
/**
 * \ingroup MultiMode
 * \details Start ET calibration for 92 modem version
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req ET cal parameters
 * \param cnf ET cal confirm message
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_StartEtCal_V2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartEtCalReqV2* req);

/*******************************************************************************
 * MMRF ETK V3 Definitions
 ******************************************************************************/
#define ERF_MAX_ET_NUM_SUBBAND_V3               (8)
#define ERF_MAX_ET_NUM_RB_IDX_V3                (36)
#define ERF_MAX_ET_LUT_PWR_NUM_V3               (16)
#define ERF_MAX_ET_NUM_CBW_V3                   (9)
#define ERF_MAX_ET_STEP2_DEFINE_CBW_V3          (2)
#define ERF_MAX_ET_STEP2_DEFINE_NUM_DELAY_V3    (3)
#define ERF_MAX_ET_START_FAC_CAL_ROUTE_NUM_V3   (93)
#define ERF_MAX_LTE_ET_SET_DATA_NUM_V3          (40)
#define ERF_MAX_LTE_ET_GET_DATA_NUM_V3          (ERF_MAX_LTE_ET_SET_DATA_NUM_V3)
#define LTE_MAX_TX_COMP_ROUTE_NUM               (50)
#define LTE_FILTER_MAX_SUPPORT_BAND_NUM         (5)
#define LTE_TARGET_MAX_SUPPORT_BAND_NUM         (25)
#define ERF_MAX_ET_NUM_ROUTE_V3                 (LTE_MAX_TX_COMP_ROUTE_NUM + LTE_FILTER_MAX_SUPPORT_BAND_NUM + LTE_TARGET_MAX_SUPPORT_BAND_NUM + LTE_FILTER_MAX_SUPPORT_BAND_NUM)

/*******************************************************************************
 * MMRF_TEST_CMD_START_ET_FAC_CAL_V3
 ******************************************************************************/
// REQ
typedef struct
{
    unsigned short  route_num;    /* The number of route in this start command */
    unsigned short  cal_band[LTE_TARGET_MAX_SUPPORT_BAND_NUM];   /*Use cfg to decide ET calibration band*/
    unsigned short  cmd_set_done;  /* last start command indicator. 0:No, 1:Yes, 2:PA_gain K 3:GC_delay search Lab K*/
} ERfTestCmdStartEtFacCalInfoV3;

typedef struct
{
    unsigned short      rat_idx; /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    union
    {
        ERfTestCmdStartEtFacCalInfoV3   lteStartKInfo;
    };
} MMRfTestCmdStartEtFacCalReqParamV3;

typedef struct
{
    /*92ET increase*/
    unsigned short      band;
    unsigned short      comp_route;
    unsigned short      path_select;    /* 0:bypass 1:filter 2:CCA 3: filter CCA */

    /*93ET remove LUT1*/
    short               GainComp_dB_0[ERF_MAX_ET_NUM_SUBBAND_V3];
    short               Tx_gain_idx[ERF_MAX_ET_NUM_SUBBAND_V3]; /*93 re-named*/
    short               GrpDelayoffset_0[ERF_MAX_ET_NUM_SUBBAND_V3][ERF_MAX_ET_NUM_RB_IDX_V3];
    short               cca_poutgain[ERF_MAX_ET_NUM_SUBBAND_V3];
    short               ETK_algorithm;  /*1 for normal, 2 for smooth LUT*/

    /*93ET increase for ETK step2 */
    unsigned short      duration_of_gainK;
    unsigned short      Ite_num;
    unsigned short      duration_dlyK;
    short               step2_define_cal_dly[ERF_MAX_ET_STEP2_DEFINE_CBW_V3][ERF_MAX_ET_STEP2_DEFINE_NUM_DELAY_V3];
    unsigned short      step2_define_cal_cbw[ERF_MAX_ET_NUM_SUBBAND_V3];
} ERfTestCmdStartEtFacCalReqPeerOneRouteV3;

typedef struct
{
    MMRfTestCmdStartEtFacCalReqParamV3   reqParam;
    union
    {
        ERfTestCmdStartEtFacCalReqPeerOneRouteV3   lteReqPeer[ERF_MAX_ET_START_FAC_CAL_ROUTE_NUM_V3];
    };
} MMRfTestCmdStartEtFacCalReqV3;


// CNF
typedef enum
{
    ERF_TEST_ET_CAL_START_OUT_RANGE  = 0,
    ERF_TEST_ET_CAL_LUT_FLAT_FAIL    = 1,
    ERF_TEST_ET_CAL_GC_ABNORMAL_FAIL = 2,
    ERF_TEST_ET_CAL_START_SUCCESS    = 3
} ERfTestResultStartEtFacCalStatusV3;

typedef struct
{
    ERfTestResultStartEtFacCalStatusV3  status;
    unsigned short                      band;
    unsigned short                      route;
    unsigned short                      subband;
} ERfTestResultStartEtCnfInfoV3;

typedef struct
{
    unsigned short                      et_rat_idx;
    union
    {
        ERfTestResultStartEtCnfInfoV3   lteStartKStatus;
    };
} MMRfTestResultStartEtFacCalCnfParamV3;

typedef struct
{
   MMRfTestResultStartEtFacCalCnfParamV3 cnfParam;
} MMRfTestResultStartEtFacCalCnfV3;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtCal_V3_r
 */
META_RESULT __stdcall META_MMRf_StartEtCal_V3(const unsigned int ms_timeout, const MMRfTestCmdStartEtFacCalReqV3* req, MMRfTestResultStartEtFacCalCnfV3* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartEtCal_V3_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartEtFacCalReqV3* req, MMRfTestResultStartEtFacCalCnfV3* cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_GET_ET_CAL_RESULT_V3
 ******************************************************************************/
// REQ
typedef struct
{
    unsigned short  route_idx;
    unsigned short    path_select;
} ERfTestCmdEtRouteInfoV3;

typedef struct
{
    unsigned short          route_num;     /* how many route info L1 need to report*/
    ERfTestCmdEtRouteInfoV3 route_info[ERF_MAX_LTE_ET_GET_DATA_NUM_V3];
} ERfTestCmdGetEtFacCalResultInfoV3;

typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   unsigned short                   rat_idx;
   union
   {
        ERfTestCmdGetEtFacCalResultInfoV3 lteGetResultInfo;
   };

} MMRfTestCmdGetEtFacCalResultReqParamV3;

typedef struct
{
    MMRfTestCmdGetEtFacCalResultReqParamV3 reqParam;
} MMRfTestCmdGetEtFacCalResultReqV3;


// CNF
typedef enum
{
   ERF_TEST_GET_ET_INVALID  = 0,
   ERF_TEST_GET_ET_OK       = 1
} ERfTestResultGetEtFacCalResultStatusV3;

typedef struct
{
    ERfTestResultGetEtFacCalResultStatusV3  get_status;
    unsigned short  route_num;
} ERfTestResultGetEtFacCalResultCnfInfoV3;

typedef struct
{
    /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
    unsigned short                          rat_idx;
    union
    {
        ERfTestResultGetEtFacCalResultCnfInfoV3   lteGetCalResultInfo;
    };
} MMRfTestResultGetEtFacCalResultCnfParamV3;

typedef struct
{
    unsigned short  band;
    unsigned short  comp_route;
    unsigned short  path_select;  /* 0:bypass 1:filter 2:CCA 3: filter CCA */

    unsigned short  VinVpaLut[ERF_MAX_ET_NUM_SUBBAND_V3][ERF_MAX_ET_LUT_PWR_NUM_V3]; /* by subband, by number of Pin */
    char            VinPmLut [ERF_MAX_ET_NUM_SUBBAND_V3][ERF_MAX_ET_LUT_PWR_NUM_V3]; /* by subband, by number of Pin */
    unsigned char   VinAmLut [ERF_MAX_ET_NUM_SUBBAND_V3][ERF_MAX_ET_LUT_PWR_NUM_V3]; /* by subband, by number of Pin */
    short           PathDelay[ERF_MAX_ET_NUM_SUBBAND_V3][ERF_MAX_ET_NUM_CBW_V3];     /* by subband, by number of CBWs */
    short           Pout_max [ERF_MAX_ET_NUM_SUBBAND_V3];
    short           Pout_gain_offset[ERF_MAX_ET_NUM_SUBBAND_V3];
    short           GainComp_dB[ERF_MAX_ET_NUM_SUBBAND_V3];
    short           GainComp_dB_0[ERF_MAX_ET_NUM_SUBBAND_V3];
    short           GrpDlyOfstBySubband  [ERF_MAX_ET_NUM_SUBBAND_V3][ERF_MAX_ET_NUM_RB_IDX_V3];
    short           Tx_gain_idx[ERF_MAX_ET_NUM_SUBBAND_V3];     //93 re-named
    short           PaGainFineTuneStep1[ERF_MAX_ET_NUM_SUBBAND_V3];
    short           PaGainFineTuneStep2[ERF_MAX_ET_NUM_SUBBAND_V3][ERF_MAX_ET_NUM_CBW_V3];
    unsigned int    EtCalDoneFlag;
    unsigned int    EtCalhpueDoneFlag;
    short           cca_poutgain[ERF_MAX_ET_NUM_SUBBAND_V3];
    short           ETK_algorithm;                                                                                        /*1 for normal, 2 for smooth LUT*/
    /*93ET increase for ETK step2 */
    unsigned short  duration_of_gainK;
    unsigned short  Ite_num;
    unsigned short  duration_dlyK;
    short           step2_define_cal_dly[ERF_MAX_ET_STEP2_DEFINE_CBW_V3][ERF_MAX_ET_STEP2_DEFINE_NUM_DELAY_V3];
    unsigned short  step2_define_cal_cbw[ERF_MAX_ET_NUM_SUBBAND_V3];
} ERfTestSetGetEtFacCalResultOneRouteV3;

typedef struct
{
    MMRfTestResultGetEtFacCalResultCnfParamV3 cnfParam;
    union
    {
        ERfTestSetGetEtFacCalResultOneRouteV3  lteCnfPeer[ERF_MAX_LTE_ET_GET_DATA_NUM_V3];
    };
} MMRfTestResultGetEtFacCalResultCnfV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtFacCalResult_V3_r
 */
META_RESULT __stdcall META_MMRf_GetEtFacCalResult_V3( const unsigned int ms_timeout, MMRfTestCmdGetEtFacCalResultReqV3 *req, const MMRfTestResultGetEtFacCalResultCnfV3 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetEtFacCalResult_V3_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdGetEtFacCalResultReqV3 *req, const MMRfTestResultGetEtFacCalResultCnfV3 *cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_SET_ET_CAL_RESULT_V3
 ******************************************************************************/
// REQ
typedef struct
{
    unsigned short  route_num;
} ERfTestCmdSetEtFacCalResultInfoV3;

typedef struct
{
    unsigned short  rat_idx;
    union
    {
        ERfTestCmdSetEtFacCalResultInfoV3 lteSetResultInfo;
    };
} MMRfTestCmdSetEtFacCalResultReqParamV3;

typedef struct
{
    MMRfTestCmdSetEtFacCalResultReqParamV3 reqParam;
    union
    {
        ERfTestSetGetEtFacCalResultOneRouteV3    lteReqPeer[ERF_MAX_LTE_ET_SET_DATA_NUM_V3];
    };
} MMRfTestCmdSetEtFacCalResultReqV3;


// CNF
typedef enum
{
    ERF_TEST_SET_ET_ROUTE_INVALID       = 0,
    ERF_TEST_SET_ET_ROUTE_OK            = 1,
    ERF_TEST_SET_ET_ROUTE_BAND_MISMATCH = 2
} ERfTestResultSetEtCalResultRouteStatus;

typedef struct
{
    unsigned short  route_num;
    ERfTestResultSetEtCalResultRouteStatus      route_status[ERF_MAX_LTE_ET_SET_DATA_NUM_V3];
} ERfTestResultSetEtFacCalResultInfoV3;

typedef struct
{
    unsigned short  rat_idx;
    union
    {
        ERfTestResultSetEtFacCalResultInfoV3 lteSetResultInfo;
    };
} MMRfTestResultSetEtFacCalResultCnfParamV3;

typedef struct
{
    MMRfTestResultSetEtFacCalResultCnfParamV3 cnfParam;
} MMRfTestResultSetEtFacCalResultCnfV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetEtFacCalResult_V3_r
 */
META_RESULT __stdcall META_MMRf_SetEtFacCalResult_V3( const unsigned int ms_timeout, MMRfTestCmdSetEtFacCalResultReqV3 *req, const MMRfTestResultSetEtFacCalResultCnfV3 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetEtFacCalResult_V3_r( const int meta_handle, const unsigned int ms_timeout, MMRfTestCmdSetEtFacCalResultReqV3 *req, const MMRfTestResultSetEtFacCalResultCnfV3 *cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_CHECK_ET_PATH_DELAY_SEARCH_V3
 ******************************************************************************/
// REQ
typedef struct
{
    unsigned short rat_idx;
} MMRfTestCmdGetEtPathDelayCheckResultReqParamV3;

typedef struct
{
    MMRfTestCmdGetEtPathDelayCheckResultReqParamV3 reqParam;
} MMRfTestCmdGetEtPathDelayCheckResultReqV3;


// CNF
typedef enum
{
    ERF_TEST_ET_PATH_DELAY_CHECK_ERROR   = 0,
    ERF_TEST_ET_PATH_DELAY_CHECK_SUCCESS = 1,
} ERfTestETPathDelayCheckStatusType;

typedef struct
{
    unsigned short  rat_idx;
    union
    {
        ERfTestETPathDelayCheckStatusType lteCheckResultStatus;
    };

} MMRfTestResultGetEtPathDelayCheckResultCnfParamV3;

typedef struct
{
    unsigned int    SwOptMode[ERF_MAX_ET_NUM_ROUTE_V3];                                /* 0:invalid 1:ET mode 2:APT mode*/
    unsigned short  Band[ERF_MAX_ET_NUM_ROUTE_V3];                                /*Band*/
    unsigned short  Route[ERF_MAX_ET_NUM_ROUTE_V3];                                /*Comp_route*/
    unsigned short  path_select[ERF_MAX_ET_NUM_ROUTE_V3];                                /*bit0 :filter bit1 : CCA*/
    unsigned short  SubbandFreq[ERF_MAX_ET_NUM_ROUTE_V3][ERF_MAX_ET_NUM_SUBBAND_V3];     /*subband frequency*/
} ERfTestResultGetEtPathDelayCheckResultCnfPeerV3;

typedef struct
{
    MMRfTestResultGetEtPathDelayCheckResultCnfParamV3 cnfParam;
    union
    {
        ERfTestResultGetEtPathDelayCheckResultCnfPeerV3 cnfPeer;
    };
} MMRfTestResultGetEtPathDelayCheckResultCnfV3;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtPathDelayCheckResult_V3_r
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResult_V3( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetEtPathDelayCheckResultReqV3* req, MMRfTestResultGetEtPathDelayCheckResultCnfV3* cnf);
/**
 * \ingroup MultiMode
 * \details Get ET delay search result for 93 modem version
 * \param meta_handle   meta handle
 * \param ms_timeout    time out in ms
 * \param req           check path delay result parameters
 * \param cnf           ET delay search result
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResult_V3_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetEtPathDelayCheckResultReqV3* req, MMRfTestResultGetEtPathDelayCheckResultCnfV3* cnf);

/*******************************************************************************
 * MMRF_TEST_CMD_START_ET_PATH_DELAY_SEARCH_V3
 ******************************************************************************/

// REQ
typedef struct
{
    unsigned short  rat_idx;
    unsigned short  band;
    unsigned short  route_idx;
    unsigned short  path_select;
    unsigned short  SubbandFreq;
    unsigned short  RbIdx;
    short           Offset;
} ERfTestCmdEtPathDelayStartSettingInfoV3;

typedef struct
{
    unsigned short rat_idx;
    union
    {
        ERfTestCmdEtPathDelayStartSettingInfoV3 ltePathDelayInfo;
    };
} MMRfTestCmdEtPathDelayStartSettingReqParamV3;

typedef struct
{
    MMRfTestCmdEtPathDelayStartSettingReqParamV3 reqParam;
} MMRfTestCmdEtPathDelayStartSettingV3;


typedef enum
{
    ERF_TEST_ET_PATH_DELAY_START_ERROR   = 0,
    ERF_TEST_ET_PATH_DELAY_START_SUCCESS = 1,
} ERfTestETPathDelayStartStatusType;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtPathDelaySearch_V3_r
 */
META_RESULT __stdcall META_MMRf_StartEtPathDelaySearch_V3( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayStartSettingV3* req);
/**
 * \ingroup MultiMode
 * \details start ET delay search for 93 modem version
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req start ET delay search parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_StartEtPathDelaySearch_V3_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayStartSettingV3* req);



/**
 * \ingroup MultiModeStruct
 * This structure is used for setting route information
 */
typedef struct
{
   /** Acutal TX route index
    */
    unsigned short  route_idx;
    /** TX path selection (enumeration):\n
    *  0: normal-path + non-CCA setting\n
    *  1: filtered-path + non-CCA setting\n
    *  2: bypass-path + CCA setting\n
    *  3: filtered-path + CCA setting
    */
    unsigned short  path_select;
} MMRfTestEtRouteInfo;

/**
 * \ingroup MultiModeStruct
 * This structure is used for setting command basic information
 */
typedef struct
{
    /** How many routes calibration reults need to report in this command
    */
    unsigned short               route_num;
    /** Basic information of each route
    */
    MMRfTestEtRouteInfo  route_info[MMRF_MAX_LTE_ET_GET_DATA_NUM];
} MMRfTestCmdGetEtCalSettingV2;

/**
 * \ingroup MultiModeStruct
 * This structure is used for reporting LUT0 ET factory calibration results of each route
 */
typedef struct
{
    /** LTE band number of this route
    */
    unsigned short    rf_band;
    /** Acutal TX route index
    */
    unsigned short    route_idx;
    /** TX path selection (enumeration):\n
    *  0: normal-path + non-CCA setting\n
    *  1: filtered-path + non-CCA setting\n
    *  2: bypass-path + CCA setting\n
    *  3: filtered-path + CCA setting
    */
    unsigned short    path_select;
    /** ET vin to vpa look up table of each subband and power entry
    */
    unsigned short    VinVpaLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM]; /* by subband, by number of Pin */
    /** ET mode DPD PM look up table of each subband and power entry
    */
    short             VinPmLut [MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM]; /* by subband, by number of Pin */
    /** ET mode DPD AM look up table of each subband and power entry
    */
    unsigned short    VinAmLut [MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM]; /* by subband, by number of Pin */
    /** ETK step2 ET path delay results of each subband and channel bandwidth
    */
    short             PathDelay[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_CBW_V2];     /* by subband, by number of CBWs */
    /** ET mode maximum Pout calibation results of each subband
    */
    short             Pout_max [MAX_MMRF_ET_NUM_SUBBAND];
    /** ET mode Pout gain offset calibration results of each subband
    */
    short             Pout_gain_offset[MAX_MMRF_ET_NUM_SUBBAND];
    /** Gain compression results from Lab tuning
    */
    unsigned short    GainComp_dB[MAX_MMRF_ET_NUM_SUBBAND];
    /** Gain compression calibration results from factory calibration
    */
    unsigned short    GainComp_dB_delta[MAX_MMRF_ET_NUM_SUBBAND];
    /** ET path delay results from Lab tuning
    */
    short             GrpDlyOfstBySubband  [MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX_V2];
    /** RF gain index results from Rf gain index lab K
    */
    short             PaGainAdjustStep1[MAX_MMRF_ET_NUM_SUBBAND];     //92 increase by subband
    /** Difference between ET mode pa gain and APt mode pa gain
    */
    short             PaGainFineTuneStep1[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for two ET LUT, only one ET LUT is used in this generation. Not used here
    */
    unsigned short    TwoLUTPwrThreshold[MAX_MMRF_ET_NUM_SUBBAND];
    /** ET calibration complete flag
    */
    unsigned int      EtCalDoneFlag;
} MMRfTestCmdEtCalResultV2_0;

/**
 * \ingroup MultiModeStruct
 * This structure is used for reporting LUT1 ET factory calibration results of each route
 */
typedef struct
{
    /** Reserved for ET LUT1 vin to vpa look up table of each subband and power entry
     */
    unsigned short   VinVpaLut[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM]; /* by subband, by number of Pin */
    /** Reserved for ET mode DPD PM look up table LUT1 of each subband and power entry
    */
    short            VinPmLut [MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM]; /* by subband, by number of Pin */
    /** Reserved for ET mode DPD AM look up table LUT1 of each subband and power entry
    */
    unsigned short   VinAmLut [MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_LUT_PWR_NUM]; /* by subband, by number of Pin */
    /** Reserved for ETK step2 LUT1 ET path delay results of each subband and channel bandwidth
    */
    short            PathDelay[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_CBW_V2];     /* by subband, by number of CBWs */
    /** Reserved for ET mode LUT1 maximum Pout calibation results of each subband
    */
    short            Pout_max [MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for ET mode LUT1 Pout gain offset calibration results of each subband
    */
    short            Pout_gain_offset[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for LUT1 Gain compression results from Lab tuning
    */
    unsigned short   GainComp_dB[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for LUT1 Gain compression calibration results from factory calibration
    */
    unsigned short   GainComp_dB_delta[MAX_MMRF_ET_NUM_SUBBAND];
    /** Reserved for LUT1 ET path delay results from Lab tuning
    */
    short            GrpDlyOfstBySubband[MAX_MMRF_ET_NUM_SUBBAND][MAX_MMRF_ET_NUM_RB_IDX_V2];
    /** Reserved for ET mode DPD PM LUT function enable
    */
    unsigned short   reserve1;                      // pm_switch
    /** Reserved for ET mode set point backoff
    */
    unsigned short   reserve2[ET_NUM_BACKOFF];      //backoff_case
    /** Reserved for ET normal mode, not used here
    */
    short            reserve3[ET_NUM_POUTGAINOFF];  //Pout_gain_offset_temp
    /* 92 ET increase, PA gain-K */
    /** Reserved for ET PA gain K, not used here
    */
    unsigned short   pa_supply_voltage_et;
} MMRfTestCmdEtCalResultV2_1;

/**
 * \ingroup MultiModeStruct
 * This enum is used for reporting command process status
 */
typedef enum
{
   /** Enumeration:\n
    * 0: Invalid parameter makes report fail\n
    * 1: Report ET factory k result done\n
    */
    MMRF_TEST_GET_ET_INVALID  = 0,
    MMRF_TEST_GET_ET_OK       = 1
} MMRfTest_GetEtCalResult_CoarseStatus;

/**
 * \ingroup MultiModeStruct
 * This structure is used for reporting calibration results procesing status
 */
typedef struct
{
   /** Report calibration results procesing status
    */
    MMRfTest_GetEtCalResult_CoarseStatus   get_status;
    /** Total process route number of this command
    */
    unsigned short                         route_num;
} MMRfTestResultGetEtRptV2;

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending ET factory calibration results
 */
typedef struct
{
   /** Send LUT 0 ET factory calibration resuts
    */
    MMRfTestCmdEtCalResultV2_0 et_cal_fac_param_v2_0;
    /** Send LUT 1 ET factory calibration resuts and reserved parameters
    */
    MMRfTestCmdEtCalResultV2_1 et_cal_fac_param_v2_1;
} MMRfTestEtCalDataV2;

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending ET factory calibration results and command process results
 */
typedef struct
{
   /** Send command process result
    */
    MMRfTestResultGetEtRptV2   et_get_result_rpt;
    /** Send claibration results
    */
    MMRfTestEtCalDataV2        et_get_cal_data_param[MMRF_MAX_LTE_ET_GET_DATA_NUM];
} MMRfTestResultGetEtCalSettingV2;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtCalSetting_V2_r
 */
META_RESULT __stdcall META_MMRf_GetEtCalSetting_V2(const unsigned int ms_timeout, const MMRfTestCmdGetEtCalSettingV2* req, MMRfTestResultGetEtCalSettingV2* cnf);
/**
 * \ingroup MultiMode
 * \details Get ET calibration result for 92 modem version
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req get ET cal setting parameters
 * \param cnf ET cal setting result parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_GetEtCalSetting_V2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetEtCalSettingV2* req, MMRfTestResultGetEtCalSettingV2* cnf);

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending number of routes in one command
 */
typedef struct
{
   /* bitmap:(0|0|Lf|Lt|W|C|T|G) */
   /** Enumeration:\n
    * 1: GSM\n
    * 2: TDSCDMA\n
    * 4: CDMA2000\n
    * 8: WCDMA\n
    * 16: LTE
    */
    unsigned short  rat_idx;
    /** Number of routes are carried in one command
    */
    unsigned short  route_num;
} MMRfTestCmdEtCalSetDimV2;

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending routes information and calibration data
 */
typedef struct
{
   /** command and route information
    */
    MMRfTestCmdEtCalSetDimV2     et_cal_set_dim_v2;
    /** Send claibration results
    */
    MMRfTestEtCalDataV2          et_cal_fac_param_v2[MMRF_MAX_LTE_ET_SET_DATA_NUM];
} MMRfTestCmdSetEtCalSettingV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetEtCalSetting_V2_r
 */
META_RESULT __stdcall META_MMRf_SetEtCalSetting_V2(const unsigned int ms_timeout, const MMRfTestCmdSetEtCalSettingV2* req);
/**
 * \ingroup MultiMode
 * \details Get ET calibration result for 92 modem version
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req set ET cal setting parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_SetEtCalSetting_V2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetEtCalSettingV2* req);

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending rat information
 */
typedef struct
{
   unsigned short    rat_idx;
} MMRfTestCmdEtPathDelayCheckResultV2;
/**
 * \ingroup MultiModeStruct
 * This structure is used for sending each route ET GC and Delay search lab k support status
 */
#define MMRF_MAX_ET_ROUTE_NUM_TYPE_1 (0)
#define MMRF_MAX_ET_ROUTE_NUM_TYPE_2 (1)
typedef struct
{
  /** ET mode support status by route
   *  - 0 is invalid, 1 is ET mode, 2 is APT mode
   */
   unsigned int     SwOptMode[MMRF_MAX_ET_NUM_ROUTE]; // 0:invalid 1: ET mode 2:APT mode
   /** LTE band number of this route
   */
   unsigned short   Band[MMRF_MAX_ET_NUM_ROUTE];
   /** Acutal TX route index
   */
   unsigned short   Route[MMRF_MAX_ET_NUM_ROUTE];
   /** TX path selection (enumeration):\n
   *  0: normal-path + non-CCA setting\n
   *  1: filtered-path + non-CCA setting\n
   *  2: bypass-path + CCA setting\n
   *  3: filtered-path + CCA setting\n
   */
   unsigned short   PathSelect[MMRF_MAX_ET_NUM_ROUTE];
   /** ET mode Tx subband frequency
   */
   unsigned short   SubbandFreq[MMRF_MAX_ET_NUM_ROUTE][MAX_MMRF_ET_NUM_SUBBAND];
} MMRfTestResultEtPathDelayCheckResultV2;

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending each route ET GC and Delay search lab k support status( alternative route CCA support version )
 */
typedef struct
{
  /** ET mode support status by route
   *  - 0 is invalid, 1 is ET mode, 2 is APT mode
   */
   unsigned int     SwOptMode[MMRF_MAX_ET_NUM_ROUTE_EX]; // 0:invalid 1: ET mode 2:APT mode
   /** LTE band number of this route
   */
   unsigned short   Band[MMRF_MAX_ET_NUM_ROUTE_EX];
   /** Acutal TX route index
   */
   unsigned short   Route[MMRF_MAX_ET_NUM_ROUTE_EX];
   /** TX path selection (enumeration):\n
   *  0: normal-path + non-CCA setting\n
   *  1: filtered-path + non-CCA setting\n
   *  2: bypass-path + CCA setting\n
   *  3: filtered-path + CCA setting\n
   */
   unsigned short   PathSelect[MMRF_MAX_ET_NUM_ROUTE_EX];
   /** ET mode Tx subband frequency
   */
   unsigned short   SubbandFreq[MMRF_MAX_ET_NUM_ROUTE_EX][MAX_MMRF_ET_NUM_SUBBAND];
} MMRfTestResultEtPathDelayCheckResultExV2;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtPathDelayCheckResult_V2_r
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResult_V2(const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayCheckResultV2* req, MMRfTestResultEtPathDelayCheckResultV2* cnf);
/**
 * \ingroup MultiMode
 * \details check ET delay search result for 92 modem version
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req check path delay result parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResult_V2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayCheckResultV2* req, MMRfTestResultEtPathDelayCheckResultV2* cnf);

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetEtPathDelayCheckResultEx_V2_r
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResultEx_V2(const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayCheckResultV2* req, MMRfTestResultEtPathDelayCheckResultExV2* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetEtPathDelayCheckResultEx_V2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayCheckResultV2* req, MMRfTestResultEtPathDelayCheckResultExV2* cnf);

/**
 * \ingroup MultiModeStruct
 * This structure defines the crystal calibration results
 */
typedef struct
{
  /** Calibrated AFC DAC results (nominal value in fix-AFC solution)
    */
   unsigned short AfcDac;

  /** Factor for transforming FoE to AFC DAC (fixed to be 1024 in fix-AFC solution)
    */
   int            SlopeInv;

  /** Calibrated CAP ID results
    */
   unsigned int   CapId;
} MMRfTestResultGetAfcSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetAfcSetting_r
 */
META_RESULT __stdcall META_MMRf_GetAfcSetting(const unsigned int ms_timeout, MMRfTestResultGetAfcSetting* cnf);
/**
 * \ingroup MultiMode
 * \details Get crystal calibration data from target
 *
 * \param [in]  meta_handle Context handle to specific DUT
 * \param [in]  ms_timeout  API transaction timeout value in milliseconds
 * \param [out] cnf         Crystal calibration data
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetAfcSetting_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultGetAfcSetting* cnf);

/**
 * \ingroup MultiMode
 * This structure defines the AFC calibration results
 */
typedef MMRfTestResultGetAfcSetting MMRfTestCmdSetAfcSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetAfcSetting_r
 */
META_RESULT __stdcall META_MMRf_SetAfcSetting(const unsigned int ms_timeout, const MMRfTestCmdSetAfcSetting* req);
/**
 * \details Set crystal calibration results to DUT
 * \ingroup MultiMode
 *
 * \param [in] meta_handle  Context handle to specific DUT
 * \param [in] ms_timeout   API transaction timeout value in milliseconds
 * \param [in] req          Crystal calibration results to be updated to DUT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetAfcSetting_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetAfcSetting* req);

/**
 * \ingroup MultiModeStruct
 * This structure defines the crystal calibration results
 */
typedef struct
{
  /** Calibrated AFC DAC results (nominal value in fix-AFC solution)
    */
   unsigned short AfcDac;

  /** Factor for transforming FoE to AFC DAC (fixed to be 1024 in fix-AFC solution)
    */
   int            SlopeInv;

  /** Calibrated CAP ID results
    */
   unsigned int   CapId;

  /** Calibrated low power mode results
    */
   int            cload_freq_offset;
} MMRfTestResultGetAfcSettingV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetAfcSettingV2_r
 */
META_RESULT __stdcall META_MMRf_GetAfcSettingV2(const unsigned int ms_timeout, MMRfTestResultGetAfcSettingV2* cnf);
/**
 * \ingroup MultiMode
 * \details Get crystal calibration data from target
 *
 * \param [in]  meta_handle Context handle to specific DUT
 * \param [in]  ms_timeout  API transaction timeout value in milliseconds
 * \param [out] cnf         Crystal calibration data
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetAfcSettingV2_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultGetAfcSettingV2* cnf);

/**
 * \ingroup MultiMode
 * This structure defines the crystal calibration results
 */
typedef MMRfTestResultGetAfcSettingV2 MMRfTestCmdSetAfcSettingV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetAfcSettingV2_r
 */
META_RESULT __stdcall META_MMRf_SetAfcSettingV2(const unsigned int ms_timeout, const MMRfTestCmdSetAfcSettingV2* req);
/**
 * \details Set crystal calibration results to DUT
 * \ingroup MultiMode
 *
 * \param [in] meta_handle  Context handle to specific DUT
 * \param [in] ms_timeout   API transaction timeout value in milliseconds
 * \param [in] req          Crystal calibration results to be updated to DUT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetAfcSettingV2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetAfcSettingV2* req);

/**
 * \ingroup MultiModeStruct
 * This structure defines the crystal calibration results
 */
typedef struct
{
  /** Calibrated AFC DAC results (nominal value in fix-AFC solution)
    */
   unsigned short AfcDac;

  /** Calibrated AAC results
    */
   short          aac;

  /** Factor for transforming FoE to AFC DAC (fixed to be 1024 in fix-AFC solution)
    */
   int            SlopeInv;

  /** Calibrated CAP ID results
    */
   unsigned int   CapId;

  /** Calibrated low power mode results
    */
   int            cload_freq_offset;
} MMRfTestResultGetAfcSettingV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetAfcSettingV3_r
 */
META_RESULT __stdcall META_MMRf_GetAfcSettingV3(const unsigned int ms_timeout, MMRfTestResultGetAfcSettingV3* cnf);
/**
 * \ingroup MultiMode
 * \details Get crystal calibration data from target
 *
 * \param [in]  meta_handle Context handle to specific DUT
 * \param [in]  ms_timeout  API transaction timeout value in milliseconds
 * \param [out] cnf         Crystal calibration data
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetAfcSettingV3_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultGetAfcSettingV3* cnf);

/**
 * \ingroup MultiMode
 * This structure defines the crystal calibration results
 */
typedef MMRfTestResultGetAfcSettingV3 MMRfTestCmdSetAfcSettingV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetAfcSettingV3_r
 */
META_RESULT __stdcall META_MMRf_SetAfcSettingV3(const unsigned int ms_timeout, const MMRfTestCmdSetAfcSettingV3* req);
/**
 * \details Set crystal calibration results to DUT
 * \ingroup MultiMode
 *
 * \param [in] meta_handle  Context handle to specific DUT
 * \param [in] ms_timeout   API transaction timeout value in milliseconds
 * \param [in] req          Crystal calibration results to be updated to DUT
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetAfcSettingV3_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetAfcSettingV3* req);

typedef struct
{
    unsigned char Aac;
} MMRfTestResultAfcAacCal;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_AfcAacCal_r
 */
META_RESULT __stdcall META_MMRf_AfcAacCal(const unsigned int ms_timeout, MMRfTestResultAfcAacCal* cnf);
/**
 * \details For updating AFC calibration results to DUT
 * \ingroup MultiMode
 *
 * \param [in] meta_handle Context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_AfcAacCal_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultAfcAacCal* cnf);

// C0(S3.28) and C1(S1.30)
typedef struct
{
   int c0;
   int c1;
   int c2;
   int c3;
} MML1_CO_TMS_CONFIG_T;
/**
 * \ingroup MultiModeStruct
 * This structure defines whether AFC and TMS are calibrated and their result
 */
typedef struct
{
  /** Whether AFC is calibrated
    */
   unsigned short     afc_calibrated;

  /** Whether TMS is calibrated
    */
   unsigned short     tms_calibrated;

  /** AFC data if calibrated
    */
   MMRfTestResultGetAfcSettingV2    xtal_cal_data;

  /** TMS data if calibrated
    */
   MML1_CO_TMS_CONFIG_T             tms_cal_data;
} MMRfTestResultXtalTmsCalibrated;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_XtalTmsCalibrated_r
 */
META_RESULT __stdcall META_MMRf_XtalTmsCalibrated(const unsigned int ms_timeout, MMRfTestResultXtalTmsCalibrated* cnf);
/**
 * \details For querying whether AFC and TMS are calibrated
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT
 * \param [in]  ms_timeout  API transaction timeout value in milliseconds
 * \param [out] cnf         defines whether AFC and TMS are calibrated and their result
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_XtalTmsCalibrated_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultXtalTmsCalibrated* cnf);

/**
 * \ingroup MultiModeStruct
 * This structure defines fixed value of C0(S3.28) and C1(S1.30)
 */
typedef struct
{
    int fixed_C0;
    int fixed_C1;
} MMRfTestResultGetCoTmsData;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetCoTmsData_r
 */
META_RESULT __stdcall META_MMRf_GetCoTmsData(const unsigned int ms_timeout, MMRfTestResultGetCoTmsData* cnf);
/**
 * \ingroup MultiMode
 * \details Get Co-TMS data from target
 *
 * \param [in]  meta_handle Context handle to specific DUT
 * \param [in]  ms_timeout  API transaction timeout value in milliseconds
 * \param [out] cnf         Co-TMS data
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetCoTmsData_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultGetCoTmsData* cnf);

/**
 * \ingroup MultiModeStruct
 * This structure defines floating and fixed value of C0(S3.28) and C1(S1.30)
 */
typedef struct
{
    unsigned int    floating_C0;
    unsigned int    floating_C1;
    int             fixed_C0;
    int             fixed_C1;
} MMRfTestCmdSetCoTmsData;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetCoTmsData_r
 */
META_RESULT __stdcall META_MMRf_SetCoTmsData(const unsigned int ms_timeout, const MMRfTestCmdSetCoTmsData* req);
/**
 * \ingroup MultiMode
 * \details Set Co-TMS data from target
 *
 * \param [in] meta_handle  Context handle to specific DUT
 * \param [in] ms_timeout   API transaction timeout value in milliseconds
 * \param [in] req          Co-TMS data
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetCoTmsData_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetCoTmsData* req);

/**
 * \ingroup MultiModeStruct
 * This structure defines fixed value of C0(S3.28), C1(S1.30), C2(S0.31), and C3(S0.31)
 */
typedef struct
{
    int fixed_C0;
    int fixed_C1;
    int fixed_C2;
    int fixed_C3;
} MMRfTestResultGetCoTmsDataV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetCoTmsData_r
 */
META_RESULT __stdcall META_MMRf_GetCoTmsDataV3(const unsigned int ms_timeout, MMRfTestResultGetCoTmsDataV3* cnf);
/**
 * \ingroup MultiMode
 * \details Get Co-TMS data from target
 *
 * \param [in]  meta_handle Context handle to specific DUT
 * \param [in]  ms_timeout  API transaction timeout value in milliseconds
 * \param [out] cnf         Co-TMS data
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetCoTmsDataV3_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultGetCoTmsDataV3* cnf);

/**
 * \ingroup MultiModeStruct
 * This structure defines floating and fixed value of C0(S3.28), C1(S1.30), C2(S0.31), and C3(S0.31)
 */
typedef struct
{
    unsigned int    floating_C0;
    unsigned int    floating_C1;
    unsigned int    floating_C2;
    unsigned int    floating_C3;
    int             fixed_C0;
    int             fixed_C1;
    int             fixed_C2;
    int             fixed_C3;
} MMRfTestCmdSetCoTmsDataV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetCoTmsData_r
 */
META_RESULT __stdcall META_MMRf_SetCoTmsDataV3(const unsigned int ms_timeout, const MMRfTestCmdSetCoTmsDataV3* req);
/**
 * \ingroup MultiMode
 * \details Set Co-TMS data from target
 *
 * \param [in] meta_handle  Context handle to specific DUT
 * \param [in] ms_timeout   API transaction timeout value in milliseconds
 * \param [in] req          Co-TMS data
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetCoTmsDataV3_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetCoTmsDataV3* req);

/**
 * \ingroup MultiModeStruct
 * This structure defines switch(1:on, 0:off) for heater control
 */
typedef struct
{
    unsigned char ctrl_bit; //1:on, 0:off
} MMRfTestCmdHeaterControl;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_HeaterControl_r
 */
META_RESULT __stdcall META_MMRf_HeaterControl(const unsigned int ms_timeout, const MMRfTestCmdHeaterControl* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_HeaterControl_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdHeaterControl* req);

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending GC and delay lab calibration parameter by route
 */
typedef struct
{
  /** LTE band number of this route
   */
   unsigned short    rf_band;
   /** Acutal TX route index
   */
   unsigned short    route_idx;
   /** TX path selection (enumeration):\n
   *  0: normal-path + non-CCA setting\n
   *  1: filtered-path + non-CCA setting\n
   *  2: bypass-path + CCA setting\n
   *  3: filtered-path + CCA setting
   */
   unsigned short    path_select;
   /** Enumeration:\n
   * 1: GSM\n
   * 2: TDSCDMA\n
   * 4: CDMA2000\n
   * 8: WCDMA\n
   * 16: LTE
   */
   unsigned short    rat_idx;
   /** Subband frequency for ET delay interpolation
   */
   unsigned short    SubbandFreq;
   /** LTE ET defined rb case index
   */
   unsigned short    RbIdx;
   /** Delay search value for ET path
   */
   short             Offset;
} MMRfTestCmdEtPathDelayStartSettingV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtPathDelaySearch_V2_r
 */
META_RESULT __stdcall META_MMRf_StartEtPathDelaySearch_V2(const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayStartSettingV2* req);
/**
 * \ingroup MultiMode
 * \details start ET delay search for 92 modem version
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req start ET delay search parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_StartEtPathDelaySearch_V2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtPathDelayStartSettingV2* req);
/**
 * \ingroup MultiModeStruct
 * This enum is used for turning on/off ET PA gain adjustment function
 */
typedef enum
{
    MMRF_TEST_PA_GAIN_ADJUST_OFF  = 0,
    MMRF_TEST_PA_GAIN_ADJUST_ON   = 1
} MMRfTestPaGainAdjustModeType;
/**
 * \ingroup MultiModeStruct
 * This structure is used for sending ET PA gain adjustment calibration parameters
 */
typedef struct
{
  /** Enumeration:\n
   * 1: GSM\n
   * 2: TDSCDMA\n
   * 4: CDMA2000\n
   * 8: WCDMA\n
   * 16: LTE
   */
   unsigned short                  rat_idx;
   /** Reserved for ET mode PA supply voltage
   */
   unsigned short                  pa_supply_voltage_et;
   /** Reserved for ET mode target power level
   */
   unsigned short                  target_power_level;
   /** ET PA gain adjustment function switch
   */
   MMRfTestPaGainAdjustModeType    mode_type;
} MMRfTestCmdPaGainAdjustReqParam;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtPaGainAdjust
 */
META_RESULT __stdcall META_MMRf_StartEtPaGainAdjust(const unsigned int ms_timeout, const MMRfTestCmdPaGainAdjustReqParam* req);
/**
 * \ingroup MultiMode
 * \details start ET PA gain adjust for 92 modem version
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param req PA gain adjust parameters
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_StartEtPaGainAdjust_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdPaGainAdjustReqParam* req);

/**
 * \ingroup MultiModeStruct
 * This structure is used for sending calibration step status
 */
typedef struct
{
  /** Enumeration:\n
   * 1: GSM\n
   * 2: TDSCDMA\n
   * 4: CDMA2000\n
   * 8: WCDMA\n
   * 16: LTE
   */
   unsigned short rat_idx;
   /** Calibration step status
   */
   unsigned short toolUsage;  /* 0:Normal; 1:Calibration; 2:ET calibration mode */
} MMRfTestCmdEtSetToolUsage;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetToolUsage_r
 */
META_RESULT __stdcall META_MMRf_SetToolUsage(const unsigned int ms_timeout, const MMRfTestCmdEtSetToolUsage* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetToolUsage_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdEtSetToolUsage* req);

/**
 * \ingroup MultiModeStruct
 * \sa non-reentrant version of META_MMRf_StartPaParameterSearch_r
 */
#define MMRF_MAX_ET_PA_BIAS_NUM (3)
typedef struct
{
    unsigned short      rfBand;
    unsigned short      route_idx;
    unsigned short      path_select;
    unsigned short      rat_idx;
    unsigned short      data_map;  /*bit0 :PA bias update bit1 :Vab_min update bit2 :VPA_max update bit3 :VPA_min update*/
    unsigned short      PA_BIAS[MMRF_MAX_ET_PA_BIAS_NUM];
    unsigned short      Vab_min[MAX_MMRF_ET_NUM_SUBBAND];
    unsigned short      VPA_max;
    unsigned short      VPA_min;
} MMRfTestCmdStartEtPaParameterSearch;

typedef enum
{
    MMRF_TEST_ET_START_PA_BIAS_SEARCH_ERROR   = 0,
    MMRF_TEST_ET_START_PA_BIAS_SEARCH_SUCCESS = 1
} MMRfTestResultStartEtPaParameterSearchStatusType;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartEtPaParameterSearch_r
 */
META_RESULT __stdcall META_MMRf_StartEtPaParameterSearch( const unsigned int ms_timeout, const MMRfTestCmdStartEtPaParameterSearch *req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartEtPaParameterSearch_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartEtPaParameterSearch *req);


#define MMRF_MAX_VBIAS_MIPI_CW_COUNT      (3)
#define LTE_COMP_ROUTE_NUM_PER_FE_ROUTE   (2)

typedef enum
{
    MMRF_PA_OCT_MODE_MIN_TXPWR = 0,
    MMRF_PA_OCT_MODE_0 = MMRF_PA_OCT_MODE_MIN_TXPWR,
    MMRF_PA_OCT_MODE_1 = 1,
    MMRF_PA_OCT_MODE_2 = 2,
    MMRF_PA_OCT_MODE_3 = 3,
    MMRF_PA_OCT_MODE_4 = 4,
    MMRF_PA_OCT_MODE_5 = 5,
    MMRF_PA_OCT_MODE_6 = 6,
    MMRF_PA_OCT_MODE_7 = 7,
    MMRF_PA_OCT_MODE_MAX_TXPWR = 7,
    MMRF_PA_OCT_MODE_8 = MMRF_PA_OCT_MODE_MAX_TXPWR,
    MMRF_PA_OCT_MODE_CNT,
} MMRfTestCmdPaOctMode;

typedef struct
{
    unsigned short  address;
    unsigned short  data;
} MMRfTestCmdMipiAddrData;

typedef struct
{
    unsigned short  fe_route;
    unsigned short  control_bitmap;
    unsigned char   dc2dc;
    unsigned char   padding_1;
    unsigned short  padding_2;
    MMRfTestCmdPaOctMode        pa_mode;
    MMRfTestCmdMipiAddrData     vbias_mipi_info[MMRF_MAX_VBIAS_MIPI_CW_COUNT];
} URfTestCmdSetAptPaSettingInputParamV2;

typedef struct
{
    unsigned short  fe_route;
    unsigned short  control_bitmap;
    unsigned char   dc2dc;
    unsigned char   path_select;
    unsigned short  padding;
    MMRfTestCmdPaOctMode    pa_mode;
    MMRfTestCmdMipiAddrData vbias_mipi_info[MMRF_MAX_VBIAS_MIPI_CW_COUNT];
} ERfTestCmdSetAptPaSettingInputParamV2;

typedef struct
{
    unsigned short             rat_idx;
    union
    {
        URfTestCmdSetAptPaSettingInputParamV2   urf_req;
        ERfTestCmdSetAptPaSettingInputParamV2   erf_req;
    };
} MMRfTestCmdSetAptPaSettingV2;


typedef enum
{
    MMRF_SET_APT_BIAS_OK_VPA_OK           = 0,
    MMRF_SET_APT_BIAS_OK_VPA_INVALID      = 1,
    MMRF_SET_APT_BIAS_INVALID_VPA_OK      = 2,
    MMRF_SET_APT_BIAS_INVALID_VPA_INVALID = 3,
    MMRF_SET_APT_FE_ROUTE_INVALID         = 4,
    MMRF_SET_APT_MIPI_INDEX_INVALID       = 5,
    MMRF_SET_APT_PA_MODE_INVALID          = 6,
    MMRF_SET_APT_STATUS_MAX               = 0XFFFF
} MMRF_SET_APT_STATUS_E;

typedef struct
{
    unsigned short          comp_route[2];
    MMRF_SET_APT_STATUS_E   set_status;
} ERfTestResultSetAptPaSettingOutputParamV2;

typedef struct
{
    MMRF_SET_APT_STATUS_E   set_status;
} URfTestResultSetAptPaSettingOutputParamV2;

typedef struct
{
    unsigned short             rat_idx;
    union
    {
        URfTestResultSetAptPaSettingOutputParamV2   urf_req;
        ERfTestResultSetAptPaSettingOutputParamV2   erf_req;
    };
} MMRfTestResultSetAptPaSettingV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetAptPaSettingV2_r
 */
META_RESULT __stdcall META_MMRf_SetAptPaSettingV2( const unsigned int ms_timeout, const MMRfTestCmdSetAptPaSettingV2 *req, MMRfTestResultSetAptPaSettingV2 *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetAptPaSettingV2_r( const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetAptPaSettingV2 *req, MMRfTestResultSetAptPaSettingV2 *cnf);



#define MMRF_MAX_TADC_LEV_NUM                     (8)
#define MMRF_MAX_TADC_SET_NUM                     (8)
typedef struct
{
    unsigned short temp_dac[MMRF_MAX_TADC_SET_NUM][MMRF_MAX_TADC_LEV_NUM];
} MMRfTestCmdSetTadcSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetTadcSetting_r
 */
META_RESULT __stdcall META_MMRf_SetTadcSetting(const unsigned int ms_timeout, const MMRfTestCmdSetTadcSetting* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_SetTadcSetting_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetTadcSetting* req);
typedef struct
{
    short temp_degree[MMRF_MAX_TADC_LEV_NUM];
    unsigned short temp_dac[MMRF_MAX_TADC_SET_NUM][MMRF_MAX_TADC_LEV_NUM];
} MMRfTestResultGetTadcSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetTadcSetting_r
 */
META_RESULT __stdcall META_MMRf_GetTadcSetting(const unsigned int ms_timeout, MMRfTestResultGetTadcSetting* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetTadcSetting_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultGetTadcSetting* cnf);
typedef struct
{
    unsigned short measure_count;
} MMRfTestCmdGetRfTemp;
typedef struct
{
    unsigned int sum[MMRF_MAX_TADC_SET_NUM];
} MMRfTestResultGetRfTemp;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetRfTemp_r
 */
META_RESULT __stdcall META_MMRf_GetRfTemp(const unsigned int ms_timeout, const MMRfTestCmdGetRfTemp* req, MMRfTestResultGetRfTemp* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetRfTemp_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetRfTemp* req, MMRfTestResultGetRfTemp* cnf);
typedef struct
{
    short status[MMRF_MAX_TADC_SET_NUM];
    short tadc_dac[MMRF_MAX_TADC_SET_NUM];
    short temperature[MMRF_MAX_TADC_SET_NUM];
    short temp_idx[MMRF_MAX_TADC_SET_NUM];
} MMRfTestResultGetTemperatureInfo;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetTemperatureInfo_r
 */
META_RESULT __stdcall META_MMRf_GetTemperatureInfo(const unsigned int ms_timeout, MMRfTestResultGetTemperatureInfo* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetTemperatureInfo_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultGetTemperatureInfo* cnf);
typedef struct
{
    unsigned short freq[MAX_DPD_DELAY_K_SUBBAND_NUM][MAX_MMRF_ET_NUM_CBW];
} MMRfTestDpdPathDelaySubbandFreq;
typedef struct
{
    unsigned short rat_idx;
} MMRfTestCmdDpdPathDelayCheckResult;
typedef struct
{
    unsigned int                     dpd_cal_done_flag[MAX_MMRF_ET_NUM_BAND];
    unsigned short                   band[MAX_MMRF_ET_NUM_BAND];
    MMRfTestDpdTrAbsolute            tr_init[MAX_MMRF_ET_NUM_BAND][MAX_DPD_DELAY_K_SPLIT_BAND_NUM];
    MMRfTestDpdPathDelaySubbandFreq  subband_freq[MAX_MMRF_ET_NUM_BAND][MAX_DPD_DELAY_K_SPLIT_BAND_NUM];
} MMRfTestResultDpdPathDelayCheckResult;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdPathDelayCheckResult_r
 */
META_RESULT __stdcall META_MMRf_GetDpdPathDelayCheckResult(const unsigned int ms_timeout, const MMRfTestCmdDpdPathDelayCheckResult* req, MMRfTestResultDpdPathDelayCheckResult* cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetDpdPathDelayCheckResult_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdDpdPathDelayCheckResult* req, MMRfTestResultDpdPathDelayCheckResult* cnf);
typedef struct
{
    unsigned short    rat_idx;
    unsigned short    band;
    unsigned short    subband_freq;
    unsigned short    cbw_idx;
    short             tr_value;
    unsigned short    signal_path;
} MMRfTestCmdDpdPathDelayStartSetting;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdPathDelaySearch_r
 */
META_RESULT __stdcall META_MMRf_StartDpdPathDelaySearch(const unsigned int ms_timeout, const MMRfTestCmdDpdPathDelayStartSetting* req);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_StartDpdPathDelaySearch_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdDpdPathDelayStartSetting* req);
/**
 * \ingroup MultiModeStruct
 * the maximum number of peer data can be set in one command
 */
#define MMRF_DPD_LTE_MAX_PATH_DELAY_SET_SUPPORT_ROUTE_NUM_V2   (210)

/**
 * \ingroup MultiModeStruct
 * the maximum number of data that can be get in one command
 */
#define MMRF_DPD_LTE_MAX_PATH_DELAY_GET_SUPPORT_ROUTE_NUM_V2   (260)
/**
 * \ingroup MultiModeStruct
 * the maximum number of band for which we can search in one command
 */
#define MMRF_DPD_LTE_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V2        (35)
#define MMRF_DPD_WCDMA_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V2      (5)

/**
 * \ingroup MultiModeStruct
 * The content of one peer data of LTE DPD delay search set command request.
 */
typedef struct
{
    /** The LTE band for which we want to search DPD delay.
     */
    unsigned short    rf_band;

    /** Route number
     */
    unsigned short    comp_route;

    /** TX path selection
     */
    unsigned short    path_select;

    /** The LTE subband frequency for which we want to search DPD delay.
     */
    unsigned short    subband_freq[MAX_FHC_TX_FREQ_NUM_EX];

    /** Initial delay (phase-out)
     */
    short             dpd_tr[MAX_FHC_TX_FREQ_NUM_EX][MMRF_MAX_LTE_CBW_NUM];
} MMRfTestCmdSetLteDpdPathDelaySearchRouteInfoV2;

/**
 * \ingroup MultiModeStruct
 * Local and peer buffer of LTE DPD delay search set command request.
 */
typedef struct
{
    /** Local buffer of this command. Indicates how many elements in route_info[] are valid.
     */
    unsigned short                                    route_num;

    /** Peer buffer of this command.
     */
    MMRfTestCmdSetLteDpdPathDelaySearchRouteInfoV2    route_info[MMRF_DPD_LTE_MAX_PATH_DELAY_SET_SUPPORT_ROUTE_NUM_V2];
} MMRfTestCmdSetLteDpdPathDelaySearchInfoV2;

typedef struct
{
    unsigned short    rf_band;
    unsigned short    subband_freq[CAL_UARFCN_SECTION];
    short             dpd_tr[CAL_UARFCN_SECTION];
} MMRfTestCmdSetWcdmaDpdPathDelaySearchBandInfoV2;
typedef struct
{
    unsigned short                                     band_num;
    MMRfTestCmdSetWcdmaDpdPathDelaySearchBandInfoV2    band_info[MMRF_DPD_WCDMA_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V2];
} MMRfTestCmdSetWcdmaDpdPathDelaySearchInfoV2;

//================== C2K DPD delay path =================
typedef struct
{
    unsigned char     rf_band;
    unsigned short    subband_freq[C2K_UARFCN_SECTION];
    short             dpd_tr[C2K_UARFCN_SECTION];
} MMRfTestCmdSetC2kDpdPathDelaySearchBandInfoV3;
typedef struct
{
    unsigned char                                      rf_mode;
    unsigned char                                      band_num;
    unsigned char                                      band_class[MMRF_DPD_C2K_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V3];
    MMRfTestCmdSetC2kDpdPathDelaySearchBandInfoV3      band_info[MMRF_DPD_C2K_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V3];
} MMRfTestCmdSetC2kDpdPathDelaySearchInfoV3;
typedef struct
{
    unsigned char     rf_mode;
    unsigned char     test_times;
    unsigned char     band_num;
    unsigned char     search_band[MMRF_DPD_C2K_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V3];
} MMRfTestCmdStartC2kDpdPathDelaySearchInfoV3;

typedef struct
{
    unsigned char                                      rf_mode;
    unsigned char                                      band_num;
    unsigned char                                      band_class[MMRF_DPD_C2K_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V3];
} MMRfTestCmdGetC2kDpdPathDelaySearchInfoV3;
typedef struct
{
    unsigned char     rf_band;
    unsigned short    subband_freq[C2K_UARFCN_SECTION];
    short             dpd_tr[C2K_UARFCN_SECTION];
} MMRfTestResultC2kDpdPathDelaySearchBandInfoV3;
typedef struct
{
    MMRfTestResultC2kDpdPathDelaySearchBandInfoV3    band_info[MMRF_DPD_C2K_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V3];
} MMRfTestResultC2kDpdPathDelaySearchV3;
typedef struct
{
   unsigned char                                       band_num;
   unsigned char                                       set_status;
} MMRfTestResultSetC2kDpdPathDelaySearchInfoV3;
//===============================================================

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD delay search set command request.
 */
typedef struct
{
    /** Enumeration:\n
     *  1: GSM\n
     *  2: TDSCDMA\n
     *  4: CDMA2000\n
     *  8: WCDMA\n
     *  16: LTE\n
     *  Meta too set this varaible to tell the target which RAT of DPD is running
     */
    unsigned short                                     rat_idx;
    union
    {
        /** LTE DPD local and peer buffer for this command.
         */
        MMRfTestCmdSetLteDpdPathDelaySearchInfoV2      lte_dpd_delay_req;
        MMRfTestCmdSetWcdmaDpdPathDelaySearchInfoV2    wcdma_dpd_delay_req;
        MMRfTestCmdSetC2kDpdPathDelaySearchInfoV3      c2k_dpd_delay_req;
    };
} MMRfTestCmdSetDpdPathDelaySearchV2;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPathDelaySearchSettingV2_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPathDelaySearchSettingV2(const unsigned int ms_timeout, const MMRfTestCmdSetDpdPathDelaySearchV2* req);

/**
 * \details The function for setting DPD delay parameters before starting DPD delay dearch.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the DPD delay parameters sent to target.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetDpdPathDelaySearchSettingV2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetDpdPathDelaySearchV2* req);

/**
 * \ingroup MultiModeStruct
 * The local buffer of LTE DPD delay search start command request.
 */
typedef struct
{
    /** E.g. Meta set test_times to 20, then L1 do delay search 20 times and report averaged delay to meta tool.
     */
    unsigned short    test_times;

    /** The bands for which we want to search DPD delay.
     */
    unsigned short    search_band[MMRF_DPD_LTE_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V2];
} MMRfTestCmdStartLteDpdPathDelaySearchInfoV2;

typedef struct
{
    unsigned short    test_times;
    unsigned short    search_band[MMRF_DPD_WCDMA_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V2];
} MMRfTestCmdStartWcdmaDpdPathDelaySearchInfoV2;

/**
 * \ingroup MultiModeStruct
 * The parameters of multi-mode DPD delay search start command request.
 */
typedef struct
{
    /** Enumeration:\n
     *  1: GSM\n
     *  2: TDSCDMA\n
     *  4: CDMA2000\n
     *  8: WCDMA\n
     *  16: LTE\n
     *  Meta too set this varaible to tell the target which RAT of DPD is running
     */
    unsigned short                                       rat_idx;
    union
    {
        /** LTE DPD local and peer buffer of this command.
         */
        MMRfTestCmdStartLteDpdPathDelaySearchInfoV2      lte_dpd_delay_req;
        MMRfTestCmdStartWcdmaDpdPathDelaySearchInfoV2    wcdma_dpd_delay_req;
    };
} MMRfTestCmdStartDpdPathDelayV2;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD delay search start command confirm.
 */
typedef struct
{
    /** The L1 status of DPD delay search result.
     *  Enumeration:\n
     *  0: Invalid\n
     *  1: Valid\n
     *  2: Time out\n
     *  3: Search fail\n
     */
    unsigned short                                       status;
} MMRfTestResultStartDpdPathDelayV2;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdPathDelaySearchV2_r
 */
META_RESULT __stdcall META_MMRf_StartDpdPathDelaySearchV2(const unsigned int ms_timeout, const MMRfTestCmdStartDpdPathDelayV2* req, MMRfTestResultStartDpdPathDelayV2* cnf);

/**
 * \details The function for triggering DPD delay search.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the DPD delay parameters sent to target.
 * \param [out] cnf is the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_StartDpdPathDelaySearchV2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartDpdPathDelayV2* req, MMRfTestResultStartDpdPathDelayV2* cnf);

/**
 * \ingroup MultiModeStruct
 * The information set to L1 for getting correct DPD delay data.
 */
typedef struct
{
    /** Route number
     */
    unsigned short    comp_route;

    /** TX path selection
     */
    unsigned short    path_select;
} MMRfTestCmdGetLteDpdPathDelaySearchRouteInfoV2;

/**
 * \ingroup MultiModeStruct
 * The local buffer of multi-mode DPD delay search get command request.
 */
typedef struct
{
    /** Indicates the valide elements in route_info[].
     */
    unsigned short                                    route_num;

    /** Information set to L1 for getting correct calibration data.
     */
    MMRfTestCmdGetLteDpdPathDelaySearchRouteInfoV2    route_info[MMRF_DPD_LTE_MAX_PATH_DELAY_GET_SUPPORT_ROUTE_NUM_V2];
} MMRfTestCmdGetLteDpdPathDelaySearchInfoV2;

typedef struct
{
    unsigned short                                    band_num;
} MMRfTestCmdGetWcdmaDpdPathDelaySearchInfoV2;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD delay search get command request.
 */
typedef struct
{
    /** Enumeration:\n
     *  1: GSM\n
     *  2: TDSCDMA\n
     *  4: CDMA2000\n
     *  8: WCDMA\n
     *  16: LTE\n
     *  Meta too set this varaible to tell the target which RAT of DPD is running
     */
    unsigned short                                     rat_idx;
    union
    {
        /** LTE DPD local and peer buffer of this command.
         */
        MMRfTestCmdGetLteDpdPathDelaySearchInfoV2      lte_dpd_delay_req;
        MMRfTestCmdGetWcdmaDpdPathDelaySearchInfoV2    wcdma_dpd_delay_req;
    };
} MMRfTestCmdGetDpdPathDelaySearchV2;

/**
 * \ingroup MultiModeStruct
 * The parameters of one peer buffer of LTE DPD delay search get command confirm.
 */
typedef struct
{
    /** The LTE band of this peer buffer data.
     */
    unsigned short    rf_band;

    /** Route number
     */
    unsigned short    comp_route;

    /** TX path selection
     */
    unsigned short    path_select;

     /* LTE DPD delay search result.
      *   0: LTE 1.4M\n
      *   1: LTE 3M\n
      *   2: LTE 5M\n
      *   3: LTE 10M\n
      *   4: LTE 15M\n
      *   5: LTE 20M\n
     */
    short             dpd_tr[MAX_FHC_TX_FREQ_NUM_EX][MMRF_MAX_LTE_CBW_NUM];
} MMRfTestResultLteDpdPathDelaySearchRouteInfoV2;

/**
 * \ingroup MultiModeStruct
 * The total peer buffer of LTE DPD delay search get command confirm.
 */
typedef struct
{
    /** The total peer buffer of LTE DPD delay search get command confirm.
     */
    MMRfTestResultLteDpdPathDelaySearchRouteInfoV2 route_info[MMRF_DPD_LTE_MAX_PATH_DELAY_GET_SUPPORT_ROUTE_NUM_V2];
} MMRfTestResultLteDpdPathDelaySearchV2;

typedef struct
{
    unsigned short    rf_band;
    short             dpd_tr[MAX_FHC_TX_FREQ_NUM_EX];
} MMRfTestResultWcdmaDpdPathDelaySearchBandInfoV2;
typedef struct
{
    MMRfTestResultWcdmaDpdPathDelaySearchBandInfoV2    band_info[MMRF_DPD_WCDMA_MAX_PATH_DELAY_SUPPORT_BAND_NUM_V2];
} MMRfTestResultWcdmaDpdPathDelaySearchV2;

/**
 * \ingroup MultiModeStruct
 * The parameters for multi-mode DPD delay search get command confirm.
 */
typedef struct
{
    union
    {
        /** LTE DPD peer buffer of this command.
         */
        MMRfTestResultLteDpdPathDelaySearchV2      lte_dpd_result;
        MMRfTestResultWcdmaDpdPathDelaySearchV2    wcdma_dpd_result;
    };
} MMRfTestResultGetDpdPathDelaySearchV2;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdPathDelaySearchResultV2_r
 */
META_RESULT __stdcall META_MMRf_GetDpdPathDelaySearchResultV2(const unsigned int ms_timeout, const MMRfTestCmdGetDpdPathDelaySearchV2* req, MMRfTestResultGetDpdPathDelaySearchV2* cnf);

/**
 * \details Get DPD delay search result from target.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the parameters sent to target to indicate which data need to be get.
 * \param [out] cnf is the DPD delay search result and the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetDpdPathDelaySearchResultV2_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetDpdPathDelaySearchV2* req, MMRfTestResultGetDpdPathDelaySearchV2* cnf);

#define MAX_LTE_DPD_DELAY_SEARCH_CA_CBW_NUM_V3            (10)
typedef struct
{
   unsigned short                                       route_num;
   unsigned short                                       coarse_status;                                      /* ERfTest_SetDpdPathDelaySearch_CoarseStatus_V3 */
   unsigned short                                       route_status[MMRF_DPD_LTE_MAX_PATH_DELAY_SET_SUPPORT_ROUTE_NUM_V2];    /* ERfTest_SetDpdPathDelaySearch_RouteStatus_V3  */
} MMRfTestResultSetLteDpdPathDelaySearchInfoV3;
typedef struct
{
   unsigned short                                       band_num;
   unsigned short                                       band_status[MAX_SUPPORTED_BAND_INDEX_V3];           /* URfTest_SetDpdPathDelaySearch_Status_V3 */
} MMRfTestResultSetWcdmaDpdPathDelaySearchInfoV3;
typedef struct
{
    unsigned short                                      rat_idx;
    union
    {
        MMRfTestResultSetLteDpdPathDelaySearchInfoV3    lte_dpd_delay_cnf;
        MMRfTestResultSetWcdmaDpdPathDelaySearchInfoV3  wcdma_dpd_delay_cnf;
        MMRfTestResultSetC2kDpdPathDelaySearchInfoV3    c2k_dpd_delay_cnf;
    };
} MMRfTestResultSetDpdPathDelaySearchV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_SetDpdPathDelaySearchSettingV3_r
 */
META_RESULT __stdcall META_MMRf_SetDpdPathDelaySearchSettingV3(const unsigned int ms_timeout, const MMRfTestCmdSetDpdPathDelaySearchV2* req, MMRfTestResultSetDpdPathDelaySearchV3* cnf);
/**
 * \details Set DPD delay search result to target.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the DPD delay search result.
 * \param [out] cnf is the status of set operation.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_SetDpdPathDelaySearchSettingV3_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdSetDpdPathDelaySearchV2* req, MMRfTestResultSetDpdPathDelaySearchV3* cnf);
typedef struct
{
    unsigned short                                      test_times;
    unsigned short                                      search_band[LTE_TARGET_MAX_SUPPORT_BAND_NUM_V3];
    unsigned short                                      search_ca_cbw[MAX_LTE_DPD_DELAY_SEARCH_CA_CBW_NUM_V3];
} MMRfTestCmdStartLteDpdPathDelaySearchInfoV3;
typedef struct
{
    unsigned short                                      rat_idx;
    union
    {
        MMRfTestCmdStartLteDpdPathDelaySearchInfoV3     lte_dpd_delay_req;
        MMRfTestCmdStartWcdmaDpdPathDelaySearchInfoV2   wcdma_dpd_delay_req;
        MMRfTestCmdStartC2kDpdPathDelaySearchInfoV3     c2k_dpd_delay_req;
    };
} MMRfTestCmdStartDpdPathDelayV3;
typedef struct
{
    unsigned short                                      rat_idx;
    union
    {
        unsigned short                                  lte_dpd_delay_status;   /* ERfTest_StartDpdPathDelaySearch_Status_V3 */
        unsigned short                                  wcdma_dpd_delay_status; /* URfTest_StartDpdPathDelaySearch_Status_V3 */
        unsigned short                                  c2k_dpd_delay_status;   /* C2kTest_StartDpdPathDelaySearch_Status_V3 */
    };
} MMRfTestResultStartDpdPathDelayV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_StartDpdPathDelaySearchV3_r
 */
META_RESULT __stdcall META_MMRf_StartDpdPathDelaySearchV3(const unsigned int ms_timeout, const MMRfTestCmdStartDpdPathDelayV3* req, MMRfTestResultStartDpdPathDelayV3* cnf);

/**
 * \details The function for triggering DPD delay search.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the DPD delay parameters sent to target.
 * \param [out] cnf is the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_StartDpdPathDelaySearchV3_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdStartDpdPathDelayV3* req, MMRfTestResultStartDpdPathDelayV3* cnf);
typedef struct
{
    unsigned short                                      band_num;
    unsigned short                                      band_info[MAX_SUPPORTED_BAND_INDEX_V3];
} MMRfTestCmdGetWcdmaDpdPathDelaySearchInfoV3;
typedef struct
{
    unsigned short                                      rat_idx;
    union
    {
        MMRfTestCmdGetLteDpdPathDelaySearchInfoV2       lte_dpd_delay_req;
        MMRfTestCmdGetWcdmaDpdPathDelaySearchInfoV3     wcdma_dpd_delay_req;
        MMRfTestCmdGetC2kDpdPathDelaySearchInfoV3       c2k_dpd_delay_req;
    };
} MMRfTestCmdGetDpdPathDelaySearchV3;
typedef struct
{
    unsigned short                                      get_status; /* ERfTest_GetDpdPathDelaySearch_Status_V3 */
    unsigned short                                      route_num;
    MMRfTestResultLteDpdPathDelaySearchRouteInfoV2      route_info[MMRF_DPD_LTE_MAX_PATH_DELAY_GET_SUPPORT_ROUTE_NUM_V2];
} MMRfTestResultLteDpdPathDelaySearchV3;
typedef struct
{
    unsigned short                                      get_status; /* URfTest_GetDpdPathDelaySearch_Status_V3 */
    unsigned short                                      band_num;
    MMRfTestResultWcdmaDpdPathDelaySearchBandInfoV2     band_info[MAX_SUPPORTED_BAND_INDEX_V3];
} MMRfTestResultWcdmaDpdPathDelaySearchV3;
typedef struct
{
    unsigned short                                      rat_idx;
    union
    {
        MMRfTestResultLteDpdPathDelaySearchV3           lte_dpd_result;
        MMRfTestResultWcdmaDpdPathDelaySearchV3         wcdma_dpd_result;
        MMRfTestResultC2kDpdPathDelaySearchV3           c2k_dpd_result;
    };
} MMRfTestResultGetDpdPathDelaySearchV3;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetDpdPathDelaySearchResultV3_r
 */
META_RESULT __stdcall META_MMRf_GetDpdPathDelaySearchResultV3(const unsigned int ms_timeout, const MMRfTestCmdGetDpdPathDelaySearchV3* req, MMRfTestResultGetDpdPathDelaySearchV3* cnf);
/**
 * \details Get DPD delay search result from target.
 * \ingroup MultiMode
 *
 * \param [in]  meta_handle Context handle to specific DUT.
 * \param [in]  ms_timeout API transaction timeout value in milliseconds.
 * \param [in]  req is the parameters sent to target to indicate which data need to be get.
 * \param [out] cnf is the DPD delay search result and the status of this command reported to meta tool.
 *
 * \retval META_SUCCESS Successful.
 * \retval META_TIMEOUT DUT not responding, DUT maybe in exception state
 */
META_RESULT __stdcall META_MMRf_GetDpdPathDelaySearchResultV3_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdGetDpdPathDelaySearchV3* req, MMRfTestResultGetDpdPathDelaySearchV3* cnf);

//--------------------------------------------------------------------------//
//  MMRF TAS                                                                     //
//--------------------------------------------------------------------------//
typedef struct
{
    unsigned short  rat_idx;
    unsigned char   tas_cfg;
} MMRfTestCmdCfgTas;
typedef struct
{
    unsigned short rat_idx;
} MMRfTestResultCfgTas;

/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_ForceTasSwitch_r
 */
META_RESULT __stdcall META_MMRf_ForceTasSwitch(const unsigned int ms_timeout, const MMRfTestCmdCfgTas* req, MMRfTestResultCfgTas* cnf);
/**
 * \ingroup MultiMode
 * \details Configure DPDT switch mode
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param tas_cfg DPDT switch configuration
 * \retval META_SUCCESS Successful
 */
META_RESULT __stdcall META_MMRf_ForceTasSwitch_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdCfgTas* req, MMRfTestResultCfgTas* cnf);
typedef struct
{
    unsigned short  rat_idx;
} MMRfTestCmdFGetTasStateCfg;
typedef enum
{
   E_MMTST_TAS_VER_1_0     = 0,
   E_MMTST_TAS_VER_1_5     = 1,
   E_MMTST_TAS_VER_2_0     = 2,
   E_MMTST_TAS_VER_COUNT,
   E_MMTST_TAS_VER_INVALID = 0x7FFF,
} E_MMTST_TAS_VER;
typedef struct
{
   unsigned short  band;               // 2G: band_enum, 3/4G: band#
   unsigned short  tas_state_up_bound; // state limit; tas_cfg should not exceed this value
   unsigned short  tas_state_bitmap;   // eg. bitmap = 0xD means state-0,2,3 need to be toggled
} MMRfTasStateConfig;
typedef struct
{
    unsigned short  rat_idx;    // bitmap: (0|0|Lf|Lt|W|C|T|G)
    unsigned short  tas_ver;    // enum (use E_MMTST_TAS_VER to case it)
    unsigned short  band_cnt;
#define MMRF_MAX_TAS_CONFIG_COUNT (32)
    MMRfTasStateConfig tas_state_cfg[MMRF_MAX_TAS_CONFIG_COUNT];
} MMRfTestResultGetTasStateCfg;
/**
 * \ingroup MultiMode
 * \sa non-reentrant version of META_MMRf_GetTasStateCfg_r
 */
META_RESULT __stdcall META_MMRf_GetTasStateCfg(const unsigned int ms_timeout, const MMRfTestCmdFGetTasStateCfg *req, MMRfTestResultGetTasStateCfg *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetTasStateCfg_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdFGetTasStateCfg *req, MMRfTestResultGetTasStateCfg *cnf);

typedef struct 
{
   unsigned short   band;
   unsigned short   cal_default_state;
   unsigned char    valid_state_num;
   unsigned char    toggled_state_num;
#define MMRF_MAX_TAS_STATE_MAX_NUM_V5 (64)   
   unsigned short   valid_state_list[MMRF_MAX_TAS_STATE_MAX_NUM_V5];   
   unsigned short   toggled_state_list[MMRF_MAX_TAS_STATE_MAX_NUM_V5];
} MMRfTestCmdTasStateConfigV5_Entry_T;

typedef struct 
{
   unsigned short  band_cnt;
   MMRfTestCmdTasStateConfigV5_Entry_T tas_state_cfg[32];
} MMRfTestCmdGetTasStateCfgV5Cnf;

/**
 * \ingroup MultiMode
 * \brief non-reentrant version of META_MMRf_GetTasStateCfg_r
 */
META_RESULT __stdcall META_MMRf_GetUtasStateCfg(const unsigned int ms_timeout, const MMRfTestCmdFGetTasStateCfg *req, MMRfTestCmdGetTasStateCfgV5Cnf *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_GetUtasStateCfg_r(const int meta_handle, const unsigned int ms_timeout, const MMRfTestCmdFGetTasStateCfg *req, MMRfTestCmdGetTasStateCfgV5Cnf *cnf);

typedef struct
{
   unsigned int  mipi_elm_type;    // 0:NULL, 1:ASM, 2:ANT, 3:PA, 4:PA_SEC, 5:ET
   unsigned int  mipi_port;        // MIPI Port
   unsigned int  unique_slave_id;  // Unique Slave Identification
   unsigned int  manufacturer_id;  // Manufacturer Identification
   unsigned int  product_id;       // Product Identification
   unsigned int  check_result;     // 0:not found, 1:found, 2:don't care
} MMRfMipiComponent;


typedef struct 
{
#define MML1_MIPI_MAX_HW_CHECK_NUM         10 
   unsigned int       entry_count;
   unsigned int       overall_check_result;
   MMRfMipiComponent  mipi[MML1_MIPI_MAX_HW_CHECK_NUM];
} MMRfTestResultCheckMipiComponent;

/**
 * \ingroup MultiMode
 * \brief non-reentrant version of META_MMRf_GetTasStateCfg_r
 */
META_RESULT __stdcall META_MMRf_CheckMipiComponent(const unsigned int ms_timeout, MMRfTestResultCheckMipiComponent *cnf);
/**
 * \ingroup MultiMode
 * \brief ToBeDo
 */
META_RESULT __stdcall META_MMRf_CheckMipiComponent_r(const int meta_handle, const unsigned int ms_timeout, MMRfTestResultCheckMipiComponent *cnf);


/********************* MT6297  NR Tool Structure Definitions *********************/

/*================== Common Defined  =======================*/

#define NL1TST_MAX_BAND_NUM_V7                  25
#define NL1TST_MAX_RX_CC_NUM_V7                 2
#define NL1TST_MAX_TX_CC_NUM_V7                 2

/*================== General Enumeration  ==================*/

typedef enum
{
   NL1TST_BW_SCS_15_KHZ_25RB  =  5000, //5MHz
   NL1TST_BW_SCS_15_KHZ_52RB  = 10000, //10MHz
   NL1TST_BW_SCS_15_KHZ_79RB  = 15000, //15MHz
   NL1TST_BW_SCS_15_KHZ_106RB = 20000, //20MHz
   NL1TST_BW_SCS_15_KHZ_133RB = 25000, //25MHz
   NL1TST_BW_SCS_15_KHZ_160RB = 30000, //30MHz
   NL1TST_BW_SCS_15_KHZ_216RB = 40000, //40MHz
   NL1TST_BW_SCS_15_KHZ_270RB = 50000, //50MHz
   NL1TST_BW_SCS_15_KHZ_MAX   = 0x7FFFFFFF
}NL1TST_BW_SCS_15_KHZ_E;


typedef enum
{
   NL1TST_BW_SCS_30_KHZ_11RB  =   5000,  //5MHz
   NL1TST_BW_SCS_30_KHZ_24RB  =  10000,  //10MHz
   NL1TST_BW_SCS_30_KHZ_38RB  =  15000,  //15MHz
   NL1TST_BW_SCS_30_KHZ_51RB  =  20000,  //20MHz
   NL1TST_BW_SCS_30_KHZ_65RB  =  25000,  //25MHz
   NL1TST_BW_SCS_30_KHZ_78RB  =  30000,  //30MHz
   NL1TST_BW_SCS_30_KHZ_106RB =  40000,  //40MHz
   NL1TST_BW_SCS_30_KHZ_133RB =  50000,  //50MHz
   NL1TST_BW_SCS_30_KHZ_162RB =  60000,  //60MHz
   NL1TST_BW_SCS_30_KHZ_217RB =  80000,  //80MHz
   NL1TST_BW_SCS_30_KHZ_273RB = 100000,  //100MHz
   NL1TST_BW_SCS_30_KHZ_MAX   = 0x7FFFFFFF
}NL1TST_BW_SCS_30_KHZ_E;


typedef enum
{
   NL1TST_BW_SCS_60_KHZ_11RB  =  10000,  //10MHz
   NL1TST_BW_SCS_60_KHZ_18RB  =  15000,  //15MHz
   NL1TST_BW_SCS_60_KHZ_24RB  =  20000,  //20MHz
   NL1TST_BW_SCS_60_KHZ_31RB  =  25000,  //25MHz
   NL1TST_BW_SCS_60_KHZ_38RB  =  30000,  //30MHz
   NL1TST_BW_SCS_60_KHZ_51RB  =  40000,  //40MHz
   NL1TST_BW_SCS_60_KHZ_65RB  =  50000,  //50MHz
   NL1TST_BW_SCS_60_KHZ_79RB  =  60000,  //60MHz
   NL1TST_BW_SCS_60_KHZ_107RB =  80000,  //80MHz
   NL1TST_BW_SCS_60_KHZ_135RB = 100000,  //100MHz
   NL1TST_BW_SCS_60_KHZ_MAX   = 0x7FFFFFFF
}NL1TST_BW_SCS_60_KHZ_E;


typedef enum
{
   NL1TST_MCS_DFT_S_BPSK    = 0,
   NL1TST_MCS_CP_QPSK       = 1,
   NL1TST_MCS_DFT_S_QPSK    = 2,
   NL1TST_MCS_CP_16QAM      = 3,
   NL1TST_MCS_DFT_S_16QAM   = 4,
   NL1TST_MCS_CP_64QAM      = 5,
   NL1TST_MCS_DFT_S_64QAM   = 6,
   NL1TST_MCS_CP_256QAM     = 7,
   NL1TST_MCS_DFT_S_256QAM  = 8,
   NL1TST_MCS_MAX    = 0x7FFFFFFF
}NL1TST_MCS_E;

typedef enum
{
   NL1TST_SCS_15KHZ  = 0,
   NL1TST_SCS_30KHZ  = 1,
   NL1TST_SCS_60KHZ  = 2,
   NL1TST_SCS_120KHZ = 3,
   NL1TST_SCS_240KHZ = 4,
   NL1TST_SCS_MAX    = 0x7FFFFFFF
}NL1TST_SCS_E;

typedef enum
{
   NL1TST_NW_SEL_NS1  = 0,
   NL1TST_NW_SEL_NS2  = 1,
   NL1TST_NW_SEL_NS3  = 2,
   NL1TST_NW_SEL_NS4  = 3,
   NL1TST_NW_SEL_NS5  = 4,
   NL1TST_NW_SEL_NS6  = 5,
   NL1TST_NW_SEL_NS7  = 6,
   NL1TST_NW_SEL_NS8  = 7,
   NL1TST_NW_SEL_NS9  = 8,
   NL1TST_NW_SEL_NS10 = 9,
   NL1TST_NW_SEL_NS11 = 10,
   NL1TST_NW_SEL_NS12 = 11,
   NL1TST_NW_SEL_NS13 = 12,
   NL1TST_NW_SEL_NS14 = 13,
   NL1TST_NW_SEL_NS15 = 14,
   NL1TST_NW_SEL_NS16 = 15,
   NL1TST_NW_SEL_NS17 = 16,
   NL1TST_NW_SEL_NS18 = 17,
   NL1TST_NW_SEL_NS19 = 18,
   NL1TST_NW_SEL_NS20 = 19,
   NL1TST_NW_SEL_NS21 = 20,
   NL1TST_NW_SEL_NS22 = 21,
   NL1TST_NW_SEL_NS23 = 22,
   NL1TST_NW_SEL_NS24 = 23,
   NL1TST_NW_SEL_NS25 = 24,
   NL1TST_NW_SEL_NS26 = 25,
   NL1TST_NW_SEL_NS27 = 26,
   NL1TST_NW_SEL_NS28 = 27,
   NL1TST_NW_SEL_NS29 = 28,
   NL1TST_NW_SEL_NS30 = 29,
   NL1TST_NW_SEL_NS31 = 30,
   NL1TST_NW_SEL_NS32 = 31,
   NL1TST_NW_SEL_MAX  = 0x7FFFFFFF
}NL1TST_NW_SEL_E;


typedef union
{
   NL1TST_BW_SCS_15_KHZ_E  scs_15_enum;
   NL1TST_BW_SCS_30_KHZ_E  scs_30_enum;
   NL1TST_BW_SCS_60_KHZ_E  scs_60_enum;
}NL1TST_BW_KHZ_U;

/*******************************************************************************
 * NL1TST_META_CMD_STOP = 1
 ******************************************************************************/
META_RESULT __stdcall META_NRf_TestStop_V7( const unsigned int ms_timeout);
META_RESULT __stdcall META_NRf_TestStop_V7_r( const int meta_handle, const unsigned int ms_timeout );

/*******************************************************************************
 * NL1TST_META_CMD_GET_RF_CAPABILITY = 2
 ******************************************************************************/

typedef struct
{
       unsigned int     is_capable            : 1;
       unsigned int    is_mandatory        : 1;
       unsigned int     fdd_2_tdd_swt          : 3; // FHC FDD to TDD switch time (ms)
       unsigned int     fdd_tx_2_rx_swt     : 3; // FHC FDD TX to RX switch time (ms)
      unsigned int     tdd_tx_2_rx_swt     : 3; // FHC TDD TX to RX switch time (ms)
      unsigned int     freq_swt            : 3; // FHC frequency switch time (ms)
       unsigned int     band_swt            : 3; // FHC band switch time (ms)
       unsigned int     tx_step_width       : 3; // FHC tx step width (ms)
       unsigned int     reserve                 : 12;
}NL1TST_CAL_SWITCH_TIME_T;

typedef struct
{
       unsigned int     is_capable          : 1;
       unsigned int     is_mandatory        : 1;
       unsigned int     generation          : 8;
       unsigned int     reserve             : 22;
}NL1TST_GENERATION_VERNO_T;


typedef  struct
{
       unsigned int     is_capable            : 1;
       unsigned int     is_mandatory        : 1;
       unsigned int     meas_start_time      : 14;
       unsigned int     meas_duration         : 14;
       unsigned int     reserve             : 2;
}NL1TST_CAL_MEAS_INFO_T;

typedef enum
{
       NL1TST_MODEM_NULL      =  0,
       NL1TST_MODEM_V7        =  1,
       NL1TST_MODEM_END       =  0x7FFFFFFF
}NL1TST_GEN_VERSION_E;

typedef enum
{
       NL1TST_RFID_NULL        = 0,
    NL1TST_RFID_COLUMBUS     = 1,
    NL1TST_RFID_END            = 0x7FFFFFFF
}NL1TST_RFID_E;


typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} NRfTestCmdRfCapabilityReq;

typedef struct
{
    unsigned int  supportBandMap[2];            ///< supportBandMap[0]           :Band01(LSB)~Band32(MSB);supportBandMap[1]            :Band33(LSB)~Band64(MSB)
    unsigned int  supportMipiBandMap[2];        ///< supportMipiBandMap[0]       :Band01(LSB)~Band32(MSB);supportMipiBandMap[1]        :Band33(LSB)~Band64(MSB)
    unsigned int  supportCoexistenceBandMap[2]; ///< supportCoexistenceBandMap[0]:Band01(LSB)~Band32(MSB);supportCoexistenceBandMap[1] :Band33(LSB)~Band64(MSB)
    unsigned int  supportDpdBandMap[2];         ///< supportDpdBandMap[0]        :Band01(LSB)~Band32(MSB);supportDpdBandMap[1]         :Band33(LSB)~Band64(MSB)
    unsigned int  supportCim3BandMap[2];        ///< supportCim3BandMap[0]       :Band01(LSB)~Band32(MSB);supportCim3BandMap[1]        :Band33(LSB)~Band64(MSB)
    unsigned int  supportHRMBandMap[2];         ///< supportHRMBandMap[0]        :Band01(LSB)~Band32(MSB);supportHRMBandMap[1]         :Band33(LSB)~Band64(MSB)
    unsigned int  supportNCCAOneElnaBandMap[2]; ///< supportNCCAOneElnaBandMap[0]:Band01(LSB)~Band32(MSB);supportNCCAOneElnaBandMap[1] :Band33(LSB)~Band64(MSB)
} NrfCapabilityItemSet;

typedef struct
{
    unsigned int is_capable: 1;
    unsigned int is_mandatory: 1;
    unsigned int parameter: 30;
} NrfCalibrationItem;

typedef struct
{
    NrfCalibrationItem    generation_version;         
    NrfCalibrationItem    fhc_sw_time;                    
    NrfCalibrationItem    fhc_rx_measurement_info; 
    NrfCalibrationItem    fhc_tx_measurement_info;

} NrfCalibrationItemSet;


typedef struct
{
    int                    valid;
    int                    status;
    unsigned int           rfId;
    NrfCalibrationItemSet  calibrationItems;
} NRfTestCmdRfCapabilityCnf;

META_RESULT __stdcall META_NRf_GetRfCapability( const unsigned int ms_timeout, const NRfTestCmdRfCapabilityReq* req, const unsigned int requestLength, NRfTestCmdRfCapabilityCnf * resp, const unsigned int responseLength );
META_RESULT __stdcall META_NRf_GetRfCapability_r( const int meta_handle, const unsigned int ms_timeout, const NRfTestCmdRfCapabilityReq* req, const unsigned int requestLength, NRfTestCmdRfCapabilityCnf* resp, const unsigned int responseLength );

/*******************************************************************************
 * NL1TST_META_CMD_START_PUSCH_TX = 3
 ******************************************************************************/
typedef struct
{
   unsigned short      band;
   unsigned char       tddSlotConfig;
   unsigned int        ulFrequency;
   unsigned char       sulFreqShift;
   unsigned short      cellId;
   union  // NL1TST_BW_KHZ_U   ulBandwidth
   {
       NL1TST_BW_SCS_15_KHZ_E  scs_15_enum;
       NL1TST_BW_SCS_30_KHZ_E  scs_30_enum;
       NL1TST_BW_SCS_60_KHZ_E  scs_60_enum;
   };
   unsigned short      vrbStart;
   unsigned short      vrbLength;
   NL1TST_SCS_E        txScs;
   NL1TST_MCS_E        mcsMode;
   short               txPowerValue;
   NL1TST_NW_SEL_E     networkSelection;
   unsigned char       txCloseLoopDisbl;
   unsigned char       amprEnbl;
   unsigned short      txRoute;
   unsigned char       enableCsr;
   unsigned char       enableMimo;
}NL1TSTCmd_StartForcePuschTx_ReqParam;

typedef struct
{
   unsigned char ulCCNum;
   NL1TSTCmd_StartForcePuschTx_ReqParam puschTxParam[NL1TST_MAX_TX_CC_NUM_V7];
}NL1TSTCmd_StartNormalPuschTx_ReqParam;

typedef struct
{
   unsigned char  puschOpMode; //0x00: normal, 0x01: force
   union
   {
      NL1TSTCmd_StartForcePuschTx_ReqParam  forcePuschTxReq;
      NL1TSTCmd_StartNormalPuschTx_ReqParam normalPuschTxReq;
   };
}NRfTestCmd_StartPuschTxCaV7;


META_RESULT __stdcall META_NRf_TxPusch_V7( const unsigned int ms_timeout, const NRfTestCmd_StartPuschTxCaV7* req, unsigned int* pSyncStatus );
META_RESULT __stdcall META_NRf_TxPusch_V7_r( const int meta_handle, const unsigned int ms_timeout, const  NRfTestCmd_StartPuschTxCaV7* req, unsigned int* pSyncStatus);
/*******************************************************************************
 * NL1TST_META_CMD_START_PUCCH_TX = 4 // maybe changed later
 ******************************************************************************/

typedef struct
{
   unsigned char        band;
   unsigned char        tddSlotConfig;
   unsigned int         ulFrequency;
   unsigned char        sulFreqShift;
   unsigned short       cellId;
   union             // ulBandwidth
   {
       NL1TST_BW_SCS_15_KHZ_E  scs_15_enum;
       NL1TST_BW_SCS_30_KHZ_E  scs_30_enum;
       NL1TST_BW_SCS_60_KHZ_E  scs_60_enum;
   };
   unsigned char        format;
   short                txPowerValue;
   NL1TST_NW_SEL_E      networkSelection;
   unsigned char        txCloseLoopDisbl;
   unsigned char        amprEnbl;
   unsigned short       txRoute;
}NL1TSTCmd_StartPucchTxV7;

META_RESULT __stdcall META_NRf_TxPucch_V7( const unsigned int ms_timeout, const NL1TSTCmd_StartPucchTxV7* req );
META_RESULT __stdcall META_NRf_TxPucch_V7_r( const int meta_handle, const unsigned int ms_timeout, const  NL1TSTCmd_StartPucchTxV7* req );

/*******************************************************************************
 * NL1TST_META_CMD_START_MIX_RX_TX = 7
 ******************************************************************************/

typedef struct
{
   /*Common parameters*/
   unsigned char        measCnt;
   unsigned int         dlFrequency;
   NL1TST_SCS_E         trxScs;
   unsigned short       band;
   unsigned char        tddSlotConfig;
   union             // ulBandwidth
   {
       NL1TST_BW_SCS_15_KHZ_E  scs_15_enum;
       NL1TST_BW_SCS_30_KHZ_E  scs_30_enum;
       NL1TST_BW_SCS_60_KHZ_E  scs_60_enum;
   };
   unsigned char        enableTx;
   short                txPowerValue;
   unsigned short       vrbStart;
   unsigned short       vrbLength;
   NL1TST_MCS_E         mcsMode;
   unsigned short       rxRoute;
   unsigned short       txRoute;
   unsigned char        lpmHpmConf;
}NL1TSTCmd_StartForceMixRx_ReqParam;

typedef struct
{
   /*Common parameters*/
   unsigned char        measCnt;
   unsigned int         dlFrequency;
   NL1TST_SCS_E         trxScs;
   unsigned short       band;
   unsigned char        tddSlotConfig;
   union             // ulBandwidth
   {
       NL1TST_BW_SCS_15_KHZ_E  scs_15_enum;
       NL1TST_BW_SCS_30_KHZ_E  scs_30_enum;
       NL1TST_BW_SCS_60_KHZ_E  scs_60_enum;
   };
   unsigned char        enableTx;
   short                txPowerValue;
   unsigned short       vrbStart;
   unsigned short       vrbLength;
   NL1TST_MCS_E         mcsMode;
   unsigned char        enableMimo;
}NL1TST_NORMAL_MIX_RX_DL_UL_PARAM_T;

typedef struct
{
   unsigned char                       numOfCC;
   NL1TST_NORMAL_MIX_RX_DL_UL_PARAM_T  param[NL1TST_MAX_RX_CC_NUM_V7];
}NL1TSTCmd_StartNormalMixRx_ReqParam;


typedef struct
{
   unsigned char  startMixRxOpMode; //0x00: normal, 0x01: force
   union
   {
       NL1TSTCmd_StartForceMixRx_ReqParam    forceRsrpRsrqCmd;
       NL1TSTCmd_StartNormalMixRx_ReqParam   normalRsrpRsrqCmd;
   };
}NRfTestCmd_StartMixRxCaV7;

META_RESULT __stdcall META_NRf_StartMixRx_V7( const unsigned int ms_timeout, const NRfTestCmd_StartMixRxCaV7* req, unsigned int* pSyncStatus );
META_RESULT __stdcall META_NRf_StartMixRx_V7_r( const int meta_handle, const unsigned int ms_timeout, const  NRfTestCmd_StartMixRxCaV7* req, unsigned int* pSyncStatus );
/*******************************************************************************
 * NL1TST_META_CMD_GET_MIX_RX_RPT = 8
 ******************************************************************************/
 
typedef struct
{
   unsigned char measRptCnt;//range 0~10
   short rssiPath0[10];
   short rssiPath1[10];
   short rssiPath2[10];
   short rssiPath3[10];
   short rsrpPath0[10];
   short rsrpPath1[10];
   short rsrpPath2[10];
   short rsrpPath3[10];
   unsigned int crcOK_cnt;
   unsigned int crcNG_cnt;
}NRfTestResult_GetMixRxReportV7;

META_RESULT __stdcall META_NRf_GetMixRxReport_V7( const unsigned int ms_timeout, const NRfTestResult_GetMixRxReportV7* cnf );
META_RESULT __stdcall META_NRf_GetMixRxReport_V7_r( const int meta_handle, const unsigned int ms_timeout, const  NRfTestResult_GetMixRxReportV7* cnf );
/*******************************************************************************
 * NL1TST_META_CMD_GET_MIMO_BAND = 9
 ******************************************************************************/
typedef struct
{
     unsigned char bandCount;
     unsigned short band[NL1TST_MAX_BAND_NUM_V7];
     unsigned char tx_band_type[NL1TST_MAX_BAND_NUM_V7];
     unsigned char rx_band_type[NL1TST_MAX_BAND_NUM_V7];
}NRfTestCmd_GetMimoBandCnfV7;
META_RESULT __stdcall META_NRf_GetMIMOBandInfo_V7( const unsigned int ms_timeout, const NRfTestCmd_GetMimoBandCnfV7* cnf );
META_RESULT __stdcall META_NRf_GetMIMOBandInfo_V7_r( const int meta_handle, const unsigned int ms_timeout, const  NRfTestCmd_GetMimoBandCnfV7* cnf);

/*******************************************************************************
 * NL1TST_META_CMD_GET_TX_ROUTE = 10
 ******************************************************************************/
typedef struct
{
     unsigned short rxRoute;
     unsigned short txRouteCount;
     unsigned short txRouteList[MMTST_MAX_TX_NUM_V7];  
}NRfTestCmd_GetTxRouteListV7;
typedef struct
{
     unsigned short rxRouteCount;
     NRfTestCmd_GetTxRouteListV7 param[MMTST_MAX_RX_T1_NUM_V7]; // only type1 has these mapping info
}NRfTestCmd_GetTxRouteByRxCnfV7;
META_RESULT __stdcall META_NRf_GetTxRouteByRx_V7( const unsigned int ms_timeout, const NRfTestCmd_GetTxRouteByRxCnfV7* cnf );
META_RESULT __stdcall META_NRf_GetTxRouteByRx_V7_r( const int meta_handle, const unsigned int ms_timeout, const  NRfTestCmd_GetTxRouteByRxCnfV7* cnf );

/*******************************************************************************
 *  NL1TST_META_CMD_GET_DL_FREQ = 11
 ******************************************************************************/
typedef struct
{
   unsigned short        band;
   unsigned int          ulFrequency;
   unsigned char         puschOpMode; //0x00: normal, 0x01: force
   unsigned short        txRoute;
}NRfTestCmd_GetDlFreqV7;

META_RESULT __stdcall META_NRf_GetPuschTxDLFreq_V7( const unsigned int ms_timeout, const NRfTestCmd_GetDlFreqV7* cnf, unsigned int* dlFrequency );
META_RESULT __stdcall META_NRf_GetPuschTxDLFreq_V7_r( const int meta_handle, const unsigned int ms_timeout, const  NRfTestCmd_GetDlFreqV7* cnf, unsigned int* dlFrequency );
/*******************************************************************************
 * NL1TST_META_CMD_RESET_COUNTER = 12
 ******************************************************************************/
META_RESULT __stdcall META_NRf_ResetCounter( const unsigned int ms_timeout );
META_RESULT __stdcall META_NRf_ResetCounter_r( const int meta_handle, const unsigned int ms_timeout );
//--------------------------------------------------------------------------//
//  NVRAM                                                                   //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  NVRAM: data structure definition                   //
//-----------------------------------------------------//

// Reset NVRAM
/**
 * \ingroup NVRAM
 * \sa FT_NVRAM_RESET_REQ
*/
typedef enum
{
    NVRAM_RESET_ALL,        /**< Reset all data items in both of user and system category */
    NVRAM_RESET_USER,       /**< Reset data items in user category    --> obsolete! just keep the enum value for backward compatibility. */
    NVRAM_RESET_SYSTEM,     /**< Reset data items in system category  --> obsolete! just keep the enum value for backward compatibility. */
    NVRAM_RESET_CERTAIN,    /**< Reset certain data item according to LID */
    NVRAM_RESET_FACTORY     /**< Reset to factory default value, all the LIDs has FACTORY attribute will be reseted */
} ResetCategory;

/**
 * \ingroup NVRAM
 * \sa META_NVRAM_Reset_r
*/
typedef struct
{
    ResetCategory   category;   /**< Reset category */
    const char*      LID;       /**< The name of logical data item ID , it will be used if and only if ResetCategory = NVRAM_RESET_CERTAIN, in other case you can just assign NULL. */
} FT_NVRAM_RESET_REQ;

/**
 * \ingroup NVRAM
 * \sa META_NVRAM_Reset_r
*/
typedef struct
{
    unsigned char   status;     /**< The status of Reset */
} FT_NVRAM_RESET_CNF;

// Read from NVRAM
/**
 * \ingroup NVRAM
 * \sa META_NVRAM_Read_r , META_NVRAM_Read_Ex_r
*/
typedef struct
{
    const char*         LID;        /**< The name of logical data item ID */
    unsigned short      RID;        /**< Record ID (the first record is 1) */
} FT_NVRAM_READ_REQ;

/**
 * \ingroup NVRAM
 * \sa META_NVRAM_Read_r , META_NVRAM_Read_Ex_r
*/
typedef struct
{
    unsigned short      LID;        /**< Logical data item ID of a EF */
    unsigned short      RID;        /**< Record ID (the first record is 1) */
    unsigned char       status;     /**< 0: read ok; others: read failed. */
    unsigned int        len;        /**< [IN] Length of Buffer, [OUT] Length of read data. The "len" field indicates the size of "buf" you allocated. When the data is read back, "len" will be replaced with the actual size of the data. */
    unsigned char*       buf;       /**< Buffer that will contains the content of record */
} FT_NVRAM_READ_CNF;

//Write to NVRAM
typedef struct
{
    const char*          LID;       ///< The name of logical data item ID
    unsigned short      RID;        ///< Record ID (the first record is 1)
    unsigned int        len;        ///< Length of write data
    unsigned char*       buf;       ///< Buffer that contains the content of record
} FT_NVRAM_WRITE_REQ;

typedef struct
{
    unsigned short      LID;        ///< Logical data item ID of a EF
    unsigned short      RID;        ///< Record ID (the first record is 1)
    unsigned char       status;     ///< 0: write ok; others: write failed.
} FT_NVRAM_WRITE_CNF;


//--------------------------------------------------------------------------//
//  AP NVRAM                                                                   //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  AP NVRAM: data structure definition                   //
//-----------------------------------------------------//

// Reset NVRAM


typedef struct
{
    ResetCategory    category;    // Reset category

    const char        *LID;        // The name of logical data item ID , it will be used
                                // if and only if ResetCategory = NVRAM_RESET_CERTAIN,
                                // in other case you can just assign NULL.
} AP_FT_NVRAM_RESET_REQ;

typedef struct
{
    unsigned char   reset_status;
    unsigned char    status;        // The status of Reset
} AP_FT_NVRAM_RESET_CNF;

// Read from NVRAM
typedef struct
{
    const char            *LID;        // The name of logical data item ID
    unsigned short         RID;        // Record ID (the first record is 1)
} AP_FT_NVRAM_READ_REQ;

typedef struct
{
    unsigned short        LID;        // Logical data item ID of a EF
    unsigned short        RID;        // Record ID (the first record is 1)
    unsigned char        status;        // 0: read ok; others: read failed.

    unsigned int        len;        // [IN] Length of Buffer, [OUT] Length of read data
                                    // The "len" field indicates the size of "buf" you 
                                    // allocated. When the data is read back, "len" will
                                    // be replaced with the actual size of the data.

    unsigned char         *buf;        // Buffer that will contains the content of record
    unsigned char        read_status;
} AP_FT_NVRAM_READ_CNF;

//Write to NVRAM
typedef struct
{
    const char            *LID;        // The name of logical data item ID
    unsigned short        RID;        // Record ID (the first record is 1)
    unsigned int        len;        // Length of write data
    unsigned char        *buf;        // Buffer that contains the content of record
} AP_FT_NVRAM_WRITE_REQ;

typedef struct
{
    unsigned short        LID;        // Logical data item ID of a EF
    unsigned short        RID;        // Record ID (the first record is 1)
    unsigned char        write_status;
    unsigned char        status;        // 0: write ok; others: write failed.
} AP_FT_NVRAM_WRITE_CNF;







typedef  struct
{
    short        max_arfcn;          ///< The maximum ARFCN of the indicated sub-band
    char         gain_offset;        ///< The maximum available gain of transceiver of the indicated sub-band
} sAGCGAINOFFSET;

typedef struct
{
    sAGCGAINOFFSET     agcPathLoss[FrequencyBandCount][PLTABLE_SIZE];
} l1cal_agcPathLoss_T;

typedef struct
{
    char gain_offset_middle;
    char gain_offset_low;
} sLNAGAINOFFSET;
/*****************************************************************
 * The lna middle/low depends on the high mode max_arfcn setting
 * (l1cal_agcPathLoss_T: high mode)
 * (l1cal_agcLnaPathLoss_T: middle/low mode)
 ****************************************************************/
typedef struct
{
    sLNAGAINOFFSET     lnaPathLoss[FrequencyBandCount][PLTABLE_SIZE];
} l1cal_lnaPathLoss_T;

typedef struct
{
    unsigned short data[8];    /**< temperature ADC */
} sTEMPERATURE_ADC_L1CAL;

typedef sTEMPERATURE_ADC_L1CAL l1cal_temperatureADC_T;

// crystalAfcData
#define XO_SlopeArea_Num       33  // change from 8 to 33, 8 is obsolete

typedef struct
{
    int     min_freq;
    short   min_dac;
    int       inv_slope;
} XO_SLOPE_AREA_DATA;

typedef struct
{
    XO_SLOPE_AREA_DATA      XO_SlopeAreaData[XO_SlopeArea_Num];
} l1cal_crystalAfcData_T;

// IMEISV
typedef struct
{
    char            imei[16];
    unsigned char   svn;
    unsigned char   pad;
} IMEISV_struct_T;

// S/W Change
typedef enum
{
    LID_VER_SAME = 0,
    LID_VER_CHANGED
} LID_STATUS;

typedef struct
{
    int     OldVer;
    int     NewVer;
    char    LID[64];
} LID_Info;

typedef struct
{
    int      target_nvramsize;   ///< current NVRAM size on target FAT file system
    int      target_freespace;   ///< current freespace of target FAT file system
    int      target_overhead;    ///< S/W upgrade operation overhead
    int      newdb_nvramsize;    ///< new NVRAM size
    unsigned char    status;     /**< 0 -> [OK] safe to upgrade to new NVRAM
                                  * 1 -> [ERROR] can't retrieve info from target
                                  * 2 -> [ERROR] freespace is not enough to upgrade to new NVRAM
                                  */
} NVRAM_GetDiskInfo_Cnf;

typedef struct
{
    unsigned short tst_port_ps;
    unsigned short         ps_port;
    unsigned long   tst_baudrate_ps;
    unsigned long   ps_baudrate;
    bool           High_Speed_SIM_Enabled;
    unsigned char          swdbg;
    unsigned char          uart_power_setting; /* For DCM, Start [Set UART POWER], CTI  */
    unsigned char          cti_uart_port;
    unsigned long   cti_baudrate;
    unsigned char           tst_port_l1;
    unsigned long   tst_baudrate_l1;
    // Support tst output to memory card
    unsigned char          tst_output_mode;
    unsigned char  usb_logging_mode;
    unsigned short  tst_port_dsp;
    unsigned long   tst_baud_rate_dsp;
} port_setting_struct;
// from: mcu\interface\hwdrv\uart_sw.h

//-----------------------------------------------------//
//  NVRAM: callback function definition                //
//-----------------------------------------------------//
/**
 * \ingroup NVRAM
 * \details The callback function of META_NVRAM_Reset_r called by META_DLL, when META_DLL receives a confirmation from the target.
 * \sa META_NVRAM_Reset_r
*/
typedef void (__stdcall* META_NVRAM_Reset_CNF)(const FT_NVRAM_RESET_CNF* cnf, const short token, void* usrData);
/**
 * \ingroup NVRAM
 * \details The callback function of META_NVRAM_Read_r & META_NVRAM_Read_Ex_r called by META_DLL, when META_DLL receives a confirmation from target.
 * \sa META_NVRAM_Read_r , META_NVRAM_Read_Ex_r
*/
typedef void (__stdcall* META_NVRAM_Read_CNF)(const FT_NVRAM_READ_CNF* cnf, const short token, void* usrData);
typedef void (__stdcall* META_NVRAM_Write_CNF)(const FT_NVRAM_WRITE_CNF* cnf, const short token, void* usrData);
typedef void (__stdcall* CB_META_NVRAM_GET_DISK_INFO_CNF)(const NVRAM_GetDiskInfo_Cnf* cnf, const short token, void* usrData);

//-----------------------------------------------------//
//  NVRAM: exported function definition                //
//-----------------------------------------------------//
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_KEY_LENGTH)(unsigned int* const length, void* usrData);
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_KEY)(char* const key, unsigned int key_length, void* usrData);
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_DATABASE_LENGTH)(unsigned int* const length, void* usrData);
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_DATABASE)(char* const database, unsigned int database_length, void* usrData);
/**
 * \ingroup NVRAM
 * \details The API set the callback function for META mode NVRAM access authentication. The callback function is used to retrieve the remote key or remote database. The user can overwrite the remote database loading or remote key loading by themselves by register valid callback function to get remote database.
 * Please set before calling META_NVRAM_Init_r if you need to customize the load database/load key operation.
 * getKey/ getKeyLength must be set at the same time (if one of the callback is NULL, then the key is retrieved by file system operation)
 * getDatabase/getDatabaseLength must be set at the same time (if one of the callback is NULL, then database is retrieved by file system operation)
 * \param [in] getKeyLength callback function to determine the remote key length.
 * \param [in] getKeyLengthArgument user argument for the getKeyLength callback
 * \param [in] getKey callback function to get the remote key into buffer.
 * \param [in] getKeyArgument user argument for the getKey callback
 * \param [in] getDatabaseLength callback function to determine the remote database size.
 * \param [in] getDatabaseLengthArgument user argument for getDatabaseLength
 * \param [in] getDatabase callback function to get the remote database into buffer.
 * \param [in] getDatabaseArgument user argument for getDatabase
 * \retval META_SUCCESS The operation completed successfully.
 * \retval Other Other error messages please use META_GetErrorString to translate the meaning.
 * \code
 * // Remote get key length user callback function implementation sample
 * // user has to set the key length
 * // META DLL will then allocate the key buffer by the length set by user
 * int __stdcall remote_key_length(unsigned int * const length, void *usrData)
 * {
 *     AfxMessageBox("remote get key length");
 *     *length = 64;
 *     return 0;
 * }
 * // Remote get key user callback function implementation sample
 * // the user has to copy the key content to the data buffer supplied by META DLL
 * int __stdcall remote_key(char* const key, unsigned int key_length, void *usrData)
 * {
 *     AfxMessageBox("remote get key");
 *     for(int i=0;i<key_length;i++)
 *     {
 *         key[i] = i;
 *     }
 *     return 0;
 * }
 * // Remote get database size user callback function implementation sample
 * // user has to set the database size
 * // META DLL will then allocate the database buffer by the size set by user
 * int __stdcall remote_db_length(unsigned int * const length, void *usrData)
 * {
 *     AfxMessageBox("remote get db length");
 *     try
 *     {
 *         ifstream ifs;
 *         ifs.open("Z:\\db", ios::binary|ios::in);
 *         ifs.seekg(0, std::ios::end);
 *         *length = ifs.tellg();
 *     }
 *     catch(...)
 *     {
 *         *length = 0;
 *     }
 *     return 0;
 * }
 * // Remote get database user callback function implementation sample
 * // the user has to copy the database content to the data buffer supplied by META DLL
 * int __stdcall remote_db(char* const database, unsigned int database_length, void *usrData)
 * {
 *     AfxMessageBox("remote get db");
 *     try
 *     {
 *         ifstream is;
 *         is.open ("Z:\\db", ios::binary );
 *         // read data as a block:
 *         is.read (database, database_length);
 *         is.close();
 *     }
 *     catch(...)
 *     {
 *         AfxMessageBox("remote get db failed");
 *     }
 *     return 0;
 * }
 * // ------------------------------------------------------------------------
 * // Example1: If the user wants to load the database or key on remote server
 * // The user has to set the callback function before doing NVRAM init
 * // ------------------------------------------------------------------------
 * static bool __stdcall remote_load_db_key(void)
 * {
 * // both key and database are loaded on remote server
 *     unsigned long addr;
 *     if(META_SUCCESS != META_NVRAM_SetCallback(
 *                 remote_key_length, NULL,
 *                 remote_key,        NULL,
 *                 remote_db_length,  NULL,
 *                 remote_db,         NULL))
 *     {
 *         AfxMessageBox("set callback failed");
 *     }
 *     if(META_SUCCESS != META_NVRAM_Init_r(0, "Z:\\db", &addr))
 *     {
 *         AfxMessageBox("init NVRAM failed");
 *     }
 *     return true;
 * }
 * // ------------------------------------------------------------------------
 * // Example2: If the user wants to load the database or key on remote server
 * // The user has to set the callback function before doing NVRAM init
 * // ------------------------------------------------------------------------
 * static bool __stdcall remote_load_key(void)
 * {
 * // key is loaded on remote server
 *     unsigned long addr;
 *     if(META_SUCCESS != META_NVRAM_SetCallback(
 *                 remote_key_length, NULL,
 *                 remote_key,        NULL,
 *                 NULL,  NULL,
 *                 NULL,         NULL))
 *     {
 *         AfxMessageBox("set callback failed");
 *     }
 *     if(META_SUCCESS != META_NVRAM_Init_r(0, "Z:\\db", &addr))
 *     {
 *         AfxMessageBox("init NVRAM failed");
 *     }
 *     return true;
 * }
 * // ------------------------------------------------------------------------
 * // Example3: If the user wants to load the database or key on remote server
 * // The user has to set the callback function before doing NVRAM init
 * // ------------------------------------------------------------------------
 * static bool __stdcall remote_load_db(void)
 * {
 * // key is loaded on remote server
 *     unsigned long addr;
 *     if(META_SUCCESS != META_NVRAM_SetCallback(
 *                 NULL, NULL,
 *                 NULL,        NULL,
 *                 remote_db_length,  NULL,
 *                 remote_db,         NULL))
 *     {
 *         AfxMessageBox("set callback failed");
 *     }
 *     if(META_SUCCESS != META_NVRAM_Init_r(0, "Z:\\db", &addr))
 *     {
 *         AfxMessageBox("init NVRAM failed");
 *     }
 *     return true;
 * }
 * \endcode
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SetCallback(
    CB_META_NVRAM_GET_REMOTE_KEY_LENGTH      getKeyLength,      void* getKeyLengthArgument,
    CB_META_NVRAM_GET_REMOTE_KEY             getKey,            void* getKeyArgument,
    CB_META_NVRAM_GET_REMOTE_DATABASE_LENGTH getDatabaseLength, void* getDatabaseLengthArgument,
    CB_META_NVRAM_GET_REMOTE_DATABASE        getDatabase,       void* getDatabaseArgument
);
/**
 * \ingroup NVRAM
 * \note In the NVRAM authenitication supported platform, the authenitication key is revieved when connection established. Therfore, developers must have to initial the nvram database at first before connect with targets.
 * \sa non-reentrant version of META_NVRAM_Init_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Init(const char* PathName, unsigned long* p_nvram_CatcherTranAddr);
/**
 * \ingroup NVRAM
 * \details init NVRAM database for current handle
 * \deprecated This API is deprecated. Please use META_NVRAM_Init_Ex_Mdtype_r instead
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] PathName the path to database file
 * \param [out] p_nvram_CatcherTranAddr the handle to the database
 * \sa META_NVRAM_Init_Ex_Mdtype_r
 * \note For multi-thread developers, here is an example pseudo code to init the database for mult-threads.
 * \code
 * META_Init();
 * META_NVRAM_Init();
 * for (i = 0; i < MAX_THREADS; ++i)
 * {
 *     META_GetAvailableHandle(&META_HANDLE);
 *     META_Init_r(META_HANDLE);
 *     CREATE_THREAD(META_HANDLE);
 * }
 * \endcode
 */
META_RESULT  __stdcall META_NVRAM_Init_r(const int meta_handle, const char* PathName, unsigned long* p_nvram_CatcherTranAddr);

/**
 * \ingroup NVRAM
 * \sa wchar_t version of META_NVRAM_Init_r
 */
META_RESULT  __stdcall META_NVRAM_Init_rW(const int meta_handle, const wchar_t* PathName, unsigned long* p_nvram_CatcherTranAddr);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Init_Ex_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Init_Ex(const unsigned int md_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \details init NVRAM database for specified MD on current handle
 * \deprecated This API is deprecated. Please use META_NVRAM_Init_Ex_Mdtype_r instead
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] md_index the index of MD
 * \param [in] db_path the path to database file
 * \param [out] p_active_db_addr the handle to the database
 * \sa META_NVRAM_Init_Ex_Mdtype_r
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex_r(const int meta_handle, const unsigned int md_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \sa wchar_t version of META_NVRAM_Init_Ex_r
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex_rW(const int meta_handle, const unsigned int md_index, const wchar_t* db_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Init_2_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Init_2(const char* db1_path, const char* db2_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \details init NVRAM database for dual talk project
 * \deprecated This API is deprecated. Please use META_NVRAM_Init_Ex_Mdtype_r instead
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] db1_path the path to database file for MD1
 * \param [in] db2_path the path to database file for MD2
 * \param [out] p_active_db_addr the handle to the database
 * \sa META_NVRAM_Init_Ex_Mdtype_r
 */
META_RESULT  __stdcall META_NVRAM_Init_2_r(const int meta_handle, const char* db1_path, const char* db2_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \sa wchar_t version of META_NVRAM_Init_2_r
 */
META_RESULT  __stdcall META_NVRAM_Init_2_rW(const int meta_handle, const wchar_t* db1_path, const wchar_t* db2_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Init_Ex_Mdtype_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Init_Ex_Mdtype(const unsigned int md_index, const unsigned int mdtype_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \details This function initializes the NVRAM-related functionality. This API is enhanced for world phone feature (multiple SW image/MD type feature.)
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] md_index Modem index in dual-tlak and world phone feature.
 * \param [in] mdtype_index Modem type index (SW image index) in dual-tlak and world phone feature.
 * \param [in] db_path the path to database file
 * \param [out] p_active_db_addr the handle to the database
 * \retval META_SUCCESS The operation completed successfully.
 * \retval META_INVALID_HANDLE meta_handle is invalid.
 * \retval META_INVALID_ARGUMENTS Some NVRAM arguments are invalid.
 * \retval META_MAUI_DB_INCONSISTENT NVRAM database is inconsistent.
 * \retval META_FILE_BAD File doesnt exist or open file failed.
 * \retval META_FAILED The requested operation was unsuccessful.
 * \note For parameter md_index, if value equals to 0, it means appointed 1st modem. If value equals to 1, it means appointed 2nd modem. For parameter mdtype_index, if value equals to 0, it means appointed 1st modem type. If value equals to 1, it means appointed 2nd modem type.
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex_Mdtype_r(const int meta_handle, const unsigned int md_index, const unsigned int mdtype_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \sa wchar_t version of META_NVRAM_Init_Ex_Mdtype_r
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex_Mdtype_rW(const int meta_handle, const unsigned int md_index, const unsigned int mdtype_index, const wchar_t* db_path, unsigned long* p_active_db_addr);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Reset_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Reset(const FT_NVRAM_RESET_REQ* req, const META_NVRAM_Reset_CNF cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 * \details This function resets the data items.
 * 1. Reset the whole USER category: You must set ResetCategory = NVRAM_RESET_USER. LID is ignored in this case.
 * 2. Reset the whole SYSTEM category: You must set ResetCategory = NVRAM_RESET_SYSTEM. LID is ignored in this case.
 * 3. Reset both of the USER and SYSTEM categories: You must set ResetCategory = NVRAM_RESET_ALL. LID is ignored in this case.
 * 4. Reset one certain LID, you must set ResetCategory = NVRAM_RESET_CERTAIN, and also specify which LID you want to reset.
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] req Request
 * \param [in] cb Callback function called by META_DLL, when META_DLL receives a confirmation from the target.
 * \param [in, out] token Token used by the user to uninstall the callback function.
 * \param [in] usrData Parameter being used by the user.
 * \retval META_SUCCESS The operation completed successfully.
 * \retval META_FAILED The requested operation was unsuccessful.
 * \retval META_COMM_FAIL Failure. This means the communication between PC and target failed.
 * \retval META_INTERNAL_DB_ERR Cannot find structure information from InternalDB.
 * \note NVRAM_RESET_ALL, NVRAM_RESET_USER, NVRAM_RESET_SYSTEM, NVRAM_RESET_CERTAIN are  obsolete since W10.12, and all branches have been patched (refer to CR:MAUI_01981104).
 */
META_RESULT  __stdcall META_NVRAM_Reset_r(const int meta_handle, const FT_NVRAM_RESET_REQ* req, const META_NVRAM_Reset_CNF cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Read_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Read(const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf, const META_NVRAM_Read_CNF cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 * \details This function reads the content of a specific record.
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] req Request
 * \param [in, out] cnf Pointer to FT_NVRAM_READ_CNF, which will be the parameter of callback function.
 * \param [in] cb Callback function called by META_DLL, when META_DLL receives a confirmation from target.
 * \param [in, out] token Token used by user to uninstall the callback function.
 * \param [in] usrData Parameter used by user.
 * \retval META_SUCCESS The operation completed successfully.
 * \retval META_FAILED The requested operation was unsuccessful.
 * \retval META_COMM_FAIL Failure. This means the communication between PC and target are failed.
 * \retval META_LID_INVALID Invalid LID.
 * \retval META_BUFFER_LEN cnf->buf is not prepared, or cnf->len error.
 * \note The "buf" field of FT_NVRAM_READ_CNF is a pointer to a buffer. User should provide this buffer for META_DLL to store the data of read record.	The "len" field of FT_NVRAM_READ_CNF indicates the size of "buf" you allocated. When the data is read back, "len" will be replaced with the actual size of the data.
 */
META_RESULT  __stdcall META_NVRAM_Read_r(const int meta_handle, const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf, const META_NVRAM_Read_CNF cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Write_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Write(const FT_NVRAM_WRITE_REQ* req, const META_NVRAM_Write_CNF cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Write_r(const int meta_handle, const FT_NVRAM_WRITE_REQ* req, const META_NVRAM_Write_CNF cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetAllLIDNameLength_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetAllLIDNameLength(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetAllLIDNameLength_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetAllLIDName_r 
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetAllLIDName(char* buf, const int buf_len, int* NofLID);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetAllLIDName_r(const int meta_handle, char* buf, const int buf_len, int* NofLID);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetLIDEnumbyName_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetLIDEnumbyName(const char* LID, unsigned int* LID_enum);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetLIDEnumbyName_r(const int meta_handle, const char* LID, unsigned int* LID_enum);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetLIDVersion_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetLIDVersion(const char* LID, unsigned short* ver);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetLIDVersion_r(const int meta_handle, const char* LID, unsigned short* ver);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetDBSWVersion_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetDBSWVersion(char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetDBSWVersion_r(const int meta_handle, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_CheckDbVersion_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_CheckDbVersion(const unsigned int md_index, const unsigned int mdtype_index);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_CheckDbVersion_r(const int meta_handle, const unsigned int md_index, const unsigned int mdtype_index);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetRecStructNameLength_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetRecStructNameLength(const char* LID, int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetRecStructNameLength_r(const int meta_handle, const char* LID, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetRecStructName_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetRecStructName(const char* LID, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetRecStructName_r(const int meta_handle, const char* LID, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetAllRecFieldNameLength_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetAllRecFieldNameLength(const char* LID, int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetAllRecFieldNameLength_r(const int meta_handle, const char* LID, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetAllRecFieldName_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetAllRecFieldName(const char* LID, char* buf, const int buf_len, int* NofField);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetAllRecFieldName_r(const int meat_handle, const char* LID, char* buf, const int buf_len, int* NofField);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_CheckFieldNameExist_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_CheckFieldNameExist(const char* LID, const char* Field, bool* result);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_CheckFieldNameExist_r(const int meta_handle, const char* LID, const char* Field, bool* result);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetRecNum_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetRecNum(const char* LID, int* num);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetRecNum_r(const int meta_handle, const char* LID, int* num);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetRecLen_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetRecLen(const char* LID, int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetRecLen_r(const int meta_handle, const char* LID, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SetRecFieldValue_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SetRecFieldValue(const char* LID, const char* field, char* buf, const int buf_len, void* value, const int value_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SetRecFieldValue_r(const int meta_handle, const char* LID, const char* field, char* buf, const int buf_len, void* value, const int value_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetRecFieldValue_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetRecFieldValue(const char* LID, const char* field, const char* buf, const int buf_len, void* value, const int value_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetRecFieldValue_r(const int meta_handle, const char* LID, const char* field, const char* buf, const int buf_len, void* value, const int value_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SetRecFieldBitValue_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SetRecFieldBitValue(const char* LID, const char* field, const char* bitname, char* buf, const int buf_len, const int bitvalue);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SetRecFieldBitValue_r(const int meta_handle, const char* LID, const char* field, const char* bitname, char* buf, const int buf_len, const int bitvalue);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetRecFieldBitValue_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetRecFieldBitValue(const char* LID, const char* field, const char* bitname, const char* buf, const int buf_len, int* bitvalue);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetRecFieldBitValue_r(const int meta_handle, const char* LID, const char* field, const char* bitname, const char* buf, const int buf_len, int* bitvalue);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_QueryRecField_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_QueryRecField(const char* LID, const char* field, unsigned int* fieldSize, unsigned int* fieldOffset);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_QueryRecField_r(const int meta_handle, const char* LID, const char* field, unsigned int* fieldSize, unsigned int* fieldOffset);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_QueryIsLIDExist_r
 */
META_RESULT  __stdcall META_NVRAM_QueryIsLIDExist(const char* LID);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_QueryIsLIDExist_r(const int meta_handle, const char* LID);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_ResetToFactoryDefault_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_ResetToFactoryDefault(unsigned int ms_timeout);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_ResetToFactoryDefault_r(const int meta_handle, unsigned int ms_timeout);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_LockDown_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_LockDown(unsigned int ms_timeout);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_LockDown_r(const int meta_handle, unsigned int ms_timeout);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_OTP_LockDown_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_OTP_LockDown(unsigned int ms_timeout);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_OTP_LockDown_r(const int meta_handle, unsigned int ms_timeout);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetFilebyEnum_r(const int meta_handle, char* p_output_file, char* file_enum_type);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetFilebyEnum_rW(const int meta_handle, const wchar_t* p_output_file, char* file_enum_type);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_MemoryDump_r(const int meta_handle, const wchar_t* p_output_file);

//for NVRAM Editor
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_QueryIsFieldStruct_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_QueryIsFieldStruct(const char* struct_name, const char* field);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_QueryIsFieldStruct_r(const int meta_handle, const char* struct_name, const char* field);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetAllFieldNameLength_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetAllFieldNameLength(const char* struct_name, int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetAllFieldNameLength_r(const int meta_handle, const char* struct_name, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetAllFieldNameName_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetAllFieldNameName(const char* struct_name, char* buf, const int buf_len, int* NofField);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetAllFieldNameName_r(const int meta_handle, const char* struct_name, char* buf, const int buf_len, int* NofField);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetFieldTypeNameLength_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetFieldTypeNameLength(const char* struct_name, const char* field, int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetFieldTypeNameLength_r(const int meta_handle, const char* struct_name, const char* field, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetFieldTypeName_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetFieldTypeName(const char* struct_name, const char* field, const int buf_len, char* buf);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetFieldTypeName_r(const int meta_handle, const char* struct_name, const char* field, const int buf_len, char* buf);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetStructSize_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetStructSize(const char* struct_name, int* size);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetStructSize_r(const int meta_handle, const char* struct_name, int* size);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_QueryField_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_QueryField(const char* struct_name, const char* field, unsigned int* fieldSize, unsigned int* fieldOffset);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_QueryField_r(const int meta_handle, const char* struct_name, const char* field, unsigned int* fieldSize, unsigned int* fieldOffset);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetFieldDimension_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetFieldDimension(const char* struct_name, const char* field, int* dim_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetFieldDimension_r(const int meta_handle, const char* struct_name, const char* field, int* dim_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetFieldDimensionDefinition_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetFieldDimensionDefinition(const char* struct_name, const char* field, int dim_len, int* dim_buf);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetFieldDimensionDefinition_r(const int meta_handle, const char* struct_name, const char* field, int dim_len, int* dim_buf);

// S/W Change
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_RetrieveChangeList_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_RetrieveChangeList(void);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_RetrieveChangeList_r(const int meta_handle);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_UpdateChangeList_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_UpdateChangeList(void);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_UpdateChangeList_r(const int meta_handle);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_GetAllChangedLIDCount_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDCount(int* NofLID);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_GetAllChangedLIDName_r
 */
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDCount_r(const int meta_handle, int* NofLID);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDName(LID_Info* p_ArrayOfLID, const int NofLID);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDName_r(const int meta_handle, LID_Info* p_ArrayOfLID, const int NofLID);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_QueryIfLIDChanged_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_QueryIfLIDChanged(const char* LID, LID_STATUS*  result);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_QueryIfLIDChanged_r(const int meta_handle, const char* LID, LID_STATUS*  result);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_ImportData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_ImportData(LID_Info* p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_ImportData_r(const int meta_handle, LID_Info* p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_Database_Compare_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_Database_Compare(const char* PathName, int* p_NumOfNewAddLID, int* p_NumOfModifiedLID, int* p_NumOfDeletedLID);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_Database_Compare_r(const int meta_handle, const char* PathName, int* p_NumOfNewAddLID, int* p_NumOfModifiedLID, int* p_NumOfDeletedLID);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_Database_Compare_rW(const int meta_handle, const wchar_t* PathName, int* p_NumOfNewAddLID, int* p_NumOfModifiedLID, int* p_NumOfDeletedLID);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_Get_Database_Compare_Result_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_Get_Database_Compare_Result(LID_Info* p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info* p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info* p_ArrayOfDeletedLID, const int NumOfDeletedLID);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_Get_Database_Compare_Result_r(const int meta_handle, LID_Info* p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info* p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info* p_ArrayOfDeletedLID, const int NumOfDeletedLID);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_Check_FAT_FreeSpace_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_Check_FAT_FreeSpace(const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_Check_FAT_FreeSpace_r(const int meta_handle, const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short* token, void* usrData);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_Enable_ForceUpgrade_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_Enable_ForceUpgrade(void);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_Enable_ForceUpgrade_r(const int meta_handle);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SWC_Disable_ForceUpgrade_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SWC_Disable_ForceUpgrade(void);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SWC_Disable_ForceUpgrade_r(const int meta_handle);

// AGC path loss
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_agcPathLoss_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_agcPathLoss_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_agcPathLoss_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_agcPathLoss_r 
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_agcPathLoss(const l1cal_agcPathLoss_T* loss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_agcPathLoss_r(const int meta_handle, const l1cal_agcPathLoss_T* loss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_agcPathLoss_r 
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_agcPathLoss(l1cal_agcPathLoss_T* loss, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_agcPathLoss_r(const int meta_handle, l1cal_agcPathLoss_T* loss, const char* buf, const int buf_len);
// AGC path loss (middle/low mode)
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_lnaPathLoss_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_lnaPathLoss_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_lnaPathLoss_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_lnaPathLoss_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_lnaPathLoss(const l1cal_lnaPathLoss_T* loss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_lnaPathLoss_r(const int meta_handle, const l1cal_lnaPathLoss_T* loss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_lnaPathLoss_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_lnaPathLoss(l1cal_lnaPathLoss_T* loss, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_lnaPathLoss_r(const int meta_handle, l1cal_lnaPathLoss_T* loss, const char* buf, const int buf_len);
// rampTable
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_rampTable_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_rampTable_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_rampTable(const l1cal_rampTable_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_rampTable_r(const int meta_handle, const l1cal_rampTable_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_rampTable(l1cal_rampTable_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_r(const int meta_handle, l1cal_rampTable_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex(const l1cal_rampTable_T_Ex* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex_r(const int meta_handle, const l1cal_rampTable_T_Ex* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex(l1cal_rampTable_T_Ex* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex_r(const int meta_handle, l1cal_rampTable_T_Ex* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex2(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex2_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex2(const l1cal_rampTable_T_Ex2* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex2_r(const int meta_handle, const l1cal_rampTable_T_Ex2* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex2(l1cal_rampTable_T_Ex2* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex2_r(const int meta_handle, l1cal_rampTable_T_Ex2* tbl, const char* buf, const int buf_len);
// GGE temperature ADC
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_temperatureADC_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_temperatureADC(const l1cal_temperatureADC_T* dac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_temperatureADC_r(const int meta_handle, const l1cal_temperatureADC_T* dac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_temperatureADC_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_temperatureADC(l1cal_temperatureADC_T* dac, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_temperatureADC_r(const int meta_handle, l1cal_temperatureADC_T* dac, const char* buf, const int buf_len);

// gain rf table : NVRAM_EF_L1_GAINRF_LID
typedef struct
{
    unsigned char m_ucNumOfGainRf;
    short         gain_rf[FrequencyBandCount][MAX_GAIN_RF_NUM];
} l1cal_gainrf_T;
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_gainRf_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_gainRf(const l1cal_gainrf_T* gainrf, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_gainRf_r(const int meta_handle, const l1cal_gainrf_T* gainrf, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_gainRf_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_gainRf(l1cal_gainrf_T* gainrf, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_gainRf_r(const int meta_handle, l1cal_gainrf_T* gainrf, const char* buf, const int buf_len);
// interRampData
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_interRampData_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_interRampData_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_interRampData_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_interRampData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_interRampData(const l1cal_interRampData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_interRampData_r(const int meta_handle, const l1cal_interRampData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_interRampData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_interRampData(l1cal_interRampData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_interRampData_r(const int meta_handle, l1cal_interRampData_T* tbl, const char* buf, const int buf_len);
// crystalAfcData
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_crystalAfcData_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_crystalAfcData_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_crystalAfcData_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_crystalAfcData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_crystalAfcData(const l1cal_crystalAfcData_T* xo_afc, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_crystalAfcData_r(const int meta_handle, const l1cal_crystalAfcData_T* xo_afc, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_crystalAfcData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_crystalAfcData(l1cal_crystalAfcData_T* xo_afc, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_crystalAfcData_r(const int meta_handle, l1cal_crystalAfcData_T* xo_afc, const char* buf, const int buf_len);
// IMEISV
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Calculate_IMEI_CD_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Calculate_IMEI_CD(const char* imei, unsigned short* p_cd);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Calculate_IMEI_CD_r(const int meta_handle, const char* imei, unsigned short* p_cd);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_IMEISV_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_IMEISV_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_IMEISV_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_IMEISV_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_IMEISV(const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_r(const int meta_handle, const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_IMEISV_NoCheck_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_NoCheck(const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_NoCheck_r(const int meta_handle, const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_IMEISV_ex_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_ex(const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len, bool DoCheckSum);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_ex_r(const int meta_handle, const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len, bool DoCheckSum);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_IMEISV_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_IMEISV(IMEISV_struct_T*  p_imeisv, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_IMEISV_r(const int meta_handle, IMEISV_struct_T*  p_imeisv, const char* buf, const int buf_len);
// RF Module Configuration
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_RFSpecialCoef_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_RFSpecialCoef_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_RFSpecialCoef_Len_r(const int meta_handle, int* len);
// Skyworks
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_SKY74045_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_SKY74045_RFSpecialCoef(const RF_SKY74045_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_SKY74045_RFSpecialCoef_r(const int meta_handle, const RF_SKY74045_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_SKY74045_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_SKY74045_RFSpecialCoef(RF_SKY74045_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_SKY74045_RFSpecialCoef_r(const int meta_handle, RF_SKY74045_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_SKY74117_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_SKY74117_RFSpecialCoef(const RF_SKY74117_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_SKY74117_RFSpecialCoef_r(const int meta_handle, const RF_SKY74117_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_SKY74117_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_SKY74117_RFSpecialCoef(RF_SKY74117_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_SKY74117_RFSpecialCoef_r(const int meta_handle, RF_SKY74117_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
// MT6139B
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_MT6139B_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_MT6139B_RFSpecialCoef(const RF_MT6139B_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_MT6139B_RFSpecialCoef_r(const int meta_handle, const RF_MT6139B_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_MT6139B_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_MT6139B_RFSpecialCoef(RF_MT6139B_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_MT6139B_RFSpecialCoef_r(const int meta_handle, RF_MT6139B_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
// MT6140
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_MT6140tx_PaVbias_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_MT6140tx_PaVbias(const mt6140tx* pavbias, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_MT6140tx_PaVbias_r(const int meta_handle, const mt6140tx* pavbias, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_MT6140tx_PaVbias_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_MT6140tx_PaVbias(mt6140tx* pavbias, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_MT6140tx_PaVbias_r(const int meta_handle, mt6140tx* pavbias, const char* buf, const int buf_len);
// Renesas Bright5P
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_BRIGHT5P_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_BRIGHT5P_RFSpecialCoef(const RF_BRIGHT5P_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_BRIGHT5P_RFSpecialCoef_r(const int meta_handle, const RF_BRIGHT5P_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_BRIGHT5P_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_BRIGHT5P_RFSpecialCoef(RF_BRIGHT5P_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_BRIGHT5P_RFSpecialCoef_r(const int meta_handle, RF_BRIGHT5P_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
// EPSK interRampData
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_EPSK_interRampData_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_EPSK_interRampData_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_EPSK_interRampData_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_EPSK_interRampData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_EPSK_interRampData(const l1cal_EPSK_interRampData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_EPSK_interRampData_r(const int meta_handle, const l1cal_EPSK_interRampData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_EPSK_interRampData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_EPSK_interRampData(l1cal_EPSK_interRampData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_EPSK_interRampData_r(const int meta_handle, l1cal_EPSK_interRampData_T* tbl, const char* buf, const int buf_len);
// TX power rollback table
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_TX_Rollback_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_TX_Rollback_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_TX_Rollback_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_TX_Rollback_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_TX_Rollback(const l1cal_tx_power_rollback_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_TX_Rollback_r(const int meta_handle, const l1cal_tx_power_rollback_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_TX_Rollback_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_TX_Rollback(l1cal_tx_power_rollback_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_TX_Rollback_r(const int meta_handle, l1cal_tx_power_rollback_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_ClosedLoopTXPC_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_ClosedLoopTXPC_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_ClosedLoopTXPC_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_ClosedLoopTXPC_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_ClosedLoopTXPC(const l1cal_txpc_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_ClosedLoopTXPC_r(const int meta_handle, const l1cal_txpc_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_ClosedLoopTXPC_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_ClosedLoopTXPC(l1cal_txpc_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_ClosedLoopTXPC_r(const int meta_handle, l1cal_txpc_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_AvgW_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_AvgW_RFSpecialCoef(const RF_AvgW_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_AvgW_RFSpecialCoef_r(const int meta_handle, const RF_AvgW_Coef_T* rf_mod_coef, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_AvgW_RFSpecialCoef_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_AvgW_RFSpecialCoef(RF_AvgW_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_AvgW_RFSpecialCoef_r(const int meta_handle, RF_AvgW_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_tempdacData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_tempdacData(const ul1cal_tempdacData_T*  dac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_tempdacData_r(const int meta_handle, const ul1cal_tempdacData_T*  dac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_tempdacData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_tempdacData(ul1cal_tempdacData_T*  dac, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_tempdacData_r(const int meta_handle, ul1cal_tempdacData_T*  dac, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_pathlossData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_pathlossData(const ul1cal_pathlossData_T*  pathloss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_pathlossData_r(const int meta_handle, const ul1cal_pathlossData_T*  pathloss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_pathlossData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_pathlossData(ul1cal_pathlossData_T*  pathloss, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_pathlossData_r(const int meta_handle, ul1cal_pathlossData_T*  pathloss, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_txdacData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_txdacData(const ul1cal_txdacData_T*  txdac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_txdacData_r(const int meta_handle, const ul1cal_txdacData_T*  txdac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_txdacData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_txdacData(ul1cal_txdacData_T*  txdac, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txdacData_r(const int meta_handle, ul1cal_txdacData_T*  txdac, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_txdacData_B_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_txdacData_B(const ul1cal_txdacData_T_B* txdac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_txdacData_B_r(const int meta_handle, const ul1cal_txdacData_T_B* txdac, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_txdacData_B_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_txdacData_B(ul1cal_txdacData_T_B*  txdac, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txdacData_B_r(const int meta_handle, ul1cal_txdacData_T_B*  txdac, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_txPaOctLevData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_txPaOctLevData(const ul1cal_txPaOctLevData_T* paoctlevdata, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_txPaOctLevData_r(const int meta_handle, const ul1cal_txPaOctLevData_T* paoctlevdata, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_txPaOctLevData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPaOctLevData(ul1cal_txPaOctLevData_T* paoctlevdata, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPaOctLevData_r(const int meta_handle, ul1cal_txPaOctLevData_T* paoctlevdata, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_pathlossRxdData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_pathlossRxdData(const ul1cal_pathlossRxdData_T*  pathloss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_pathlossRxdData_r(const int meta_handle, const ul1cal_pathlossRxdData_T*  pathloss, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_pathlossRxdData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_pathlossRxdData(ul1cal_pathlossRxdData_T*  pathloss, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_pathlossRxdData_r(const int meta_handle, ul1cal_pathlossRxdData_T*  pathloss, const char* buf, const int buf_len);
/* PA drift compensation data */
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_txPaDriftCompData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_txPaDriftCompData(const ul1Cal_txPaDriftCompData_T* txPaDriftCompData, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_txPaDriftCompData_r(const int meta_handle, const ul1Cal_txPaDriftCompData_T* txPaDriftCompData, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_txPaDriftCompData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPaDriftCompData(ul1Cal_txPaDriftCompData_T* txPaDriftCompData, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPaDriftCompData_r(const int meta_handle, ul1Cal_txPaDriftCompData_T* txPaDriftCompData, const char* buf, const int buf_len);
/*20130425 for PRACH TX Temp. Comp. */
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Compose_txPRACHTempCompData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Compose_txPRACHTempCompData(const ul1cal_txPrachTmCompData_T* txPrachTmCompData, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Compose_txPRACHTempCompData_r(const int meta_handle, const ul1cal_txPrachTmCompData_T* txPrachTmCompData, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_3G_Decompose_txPRACHTempCompData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPRACHTempCompData(ul1cal_txPrachTmCompData_T* txPrachTmCompData, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPRACHTempCompData_r(const int meta_handle, ul1cal_txPrachTmCompData_T* txPrachTmCompData, const char* buf, const int buf_len);
// sBBTxParameters
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_BBTXParameters_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_BBTXParameters_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_BBTXParameters_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_BBTXParameters_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_BBTXParameters(const BBTXParameters_T* bbtx, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_BBTXParameters_r(const int meta_handle, const BBTXParameters_T* bbtx, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_BBTXParameters_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_BBTXParameters(BBTXParameters_T* bbtx, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_BBTXParameters_r(const int meta_handle, BBTXParameters_T* bbtx, const char* buf, const int buf_len);
// ad6546tx
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_ad6546tx_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_ad6546tx(const ad6546tx* adtx, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_ad6546tx_r(const int meta_handle, const ad6546tx* adtx, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_ad6546tx_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_ad6546tx(ad6546tx* adtx, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_ad6546tx_r(const int meta_handle, ad6546tx* adtx, const char* buf, const int buf_len);
// PORT setting
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_PortSetting_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_PortSetting_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_PortSetting_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_PortSetting_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_PortSetting(const port_setting_struct* port_setting, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_PortSetting_r(const int meta_handle, const port_setting_struct* port_setting, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_PortSetting_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_PortSetting(port_setting_struct* port_setting, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_PortSetting_r(const int meta_handle, port_setting_struct* port_setting, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_PortSetting_ex_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_PortSetting_ex(const port_setting_struct* port_setting, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_PortSetting_ex_r(const int meta_handle, const port_setting_struct* port_setting, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_PortSetting_ex_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_PortSetting_ex(port_setting_struct* port_setting, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_PortSetting_ex_r(const int meta_handle, port_setting_struct* port_setting, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_GetAutoTestiFlagEnumValue_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_GetAutoTestiFlagEnumValue(int* value);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_GetAutoTestiFlagEnumValue_r(const int meta_handle, int* value);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_SetAutoTestiFlag_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_SetAutoTestiFlag(void);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_SetAutoTestiFlag_r(const int meta_handle);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Read_Ex_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Read_Ex( const unsigned int ms_timeout, const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Read_Ex_r( const int meta_handle, unsigned int ms_timeout, const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Write_Ex_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Write_Ex(const unsigned int ms_timeout, const FT_NVRAM_WRITE_REQ* req, FT_NVRAM_WRITE_CNF* cnf);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Write_Ex_r(const int meta_handle, const unsigned int ms_timeout, const FT_NVRAM_WRITE_REQ* req, FT_NVRAM_WRITE_CNF* cnf);
//---------------------------------------------------------------------------//
//  ASTRONAUT: NVRAM                                                         //
//---------------------------------------------------------------------------//
#if defined(__META_DLL_TD_A__)
#define TD_A_CAL_TEMP_SECTION 8
#define TD_A_CAL_UARFCN_SECTION 15
#define META_TD_A_CAL_LNA_MODE_NUM 3
#define META_TD_A_CAL_PA_MODE_NUM 3
#define META_TD_A_CAL_PA_DATA_NUM 4
#define META_TD_A_CAL_HYSTERESIS_NUM 2
#define META_TD_A_CAL_HYSTERESIS_POINTS 2
typedef struct
{
    unsigned short  tempdacData[TD_A_CAL_TEMP_SECTION];
} a_tl1cal_tempdacData_T;
typedef struct
{
    unsigned short initDac;
    unsigned short slope;
} a_tl1cal_afcData_T;
typedef struct
{
    unsigned int capId;
} a_tl1cal_capData_T;
typedef struct
{
    unsigned short freqTable[TD_A_CAL_UARFCN_SECTION];
    short  compByFreq[META_TD_A_CAL_LNA_MODE_NUM][TD_A_CAL_UARFCN_SECTION];
    short  compByTemp[META_TD_A_CAL_LNA_MODE_NUM][TD_A_CAL_TEMP_SECTION];
} a_tl1cal_pathlossData_T;
typedef struct
{
    unsigned short paData[META_TD_A_CAL_PA_MODE_NUM][META_TD_A_CAL_PA_DATA_NUM];
    short          paPower[META_TD_A_CAL_PA_MODE_NUM][META_TD_A_CAL_PA_DATA_NUM];
    unsigned short freqTable[TD_A_CAL_UARFCN_SECTION];
    short          compByFreq[META_TD_A_CAL_PA_MODE_NUM][TD_A_CAL_UARFCN_SECTION];
    short          compByTemp[META_TD_A_CAL_PA_MODE_NUM][TD_A_CAL_TEMP_SECTION];
    unsigned short paSwitch[META_TD_A_CAL_HYSTERESIS_NUM][META_TD_A_CAL_HYSTERESIS_POINTS];
    short          maxPaPower;
    unsigned short maxPaData;
} a_tl1cal_txdacData_T;
typedef struct
{
    short          pdCompMidChannel[3];
    short          pdCompByFreq[15];
} a_tl1cal_txPdData_T;
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_TD_A_TempADC_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_TD_A_TempADC_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_TD_A_TempADC_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_TD_A_TempADC_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TempADC(const a_tl1cal_tempdacData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TempADC_r(const int meta_handle, const a_tl1cal_tempdacData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_TD_A_TempADC_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TempADC(a_tl1cal_tempdacData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TempADC_r(const int meta_handle, a_tl1cal_tempdacData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_TD_A_AFCData_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_TD_A_AFCData_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_TD_A_AFCData_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_TD_A_AFCData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_TD_A_AFCData(const a_tl1cal_afcData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_AFCData_r(const int meta_handle, const a_tl1cal_afcData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_TD_A_AFCData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_AFCData(a_tl1cal_afcData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_AFCData_r(const int meta_handle, a_tl1cal_afcData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_TD_A_PathLossData_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_TD_A_PathLossData_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_TD_A_PathLossData_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_TD_A_PathLossData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_TD_A_PathLossData(const a_tl1cal_pathlossData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_PathLossData_r(const int meta_handle, const a_tl1cal_pathlossData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_TD_A_PathLossData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_PathLossData(a_tl1cal_pathlossData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_PathLossData_r(const int meta_handle, a_tl1cal_pathlossData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_TD_A_TxDacData_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_TD_A_TxDacData_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_TD_A_TxDacData_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_TD_A_TxDacData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TxDacData(const a_tl1cal_txdacData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TxDacData_r(const int meta_handle, const a_tl1cal_txdacData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_TD_A_TxDacData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TxDacData(a_tl1cal_txdacData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TxDacData_r(const int meta_handle, a_tl1cal_txdacData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_TD_A_TxPdData_Len_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_TD_A_TxPdData_Len(int* len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_TD_A_TxPdData_Len_r(const int meta_handle, int* len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Compose_TD_A_TxPdData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TxPdData(const a_tl1cal_txPdData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TxPdData_r(const int meta_handle, const a_tl1cal_txPdData_T* tbl, char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 * \sa non-reentrant version of META_NVRAM_Decompose_TD_A_TxPdData_r
 */
NON_REENTRANT_FUNC META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TxPdData(a_tl1cal_txPdData_T* tbl, const char* buf, const int buf_len);
/**
 * \ingroup NVRAM
 */
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TxPdData_r(const int meta_handle, a_tl1cal_txPdData_T* tbl, const char* buf, const int buf_len);
#endif // end of #if defined(__META_DLL_TD_A__)

//--------------------------------------------------------------------------//
//  BaseBand Testing                                                        //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  BaseBand Testing: data structure definition        //
//-----------------------------------------------------//
typedef struct
{
    unsigned int    addr;       ///< The address of register that is to be read.
} RegRead_Req;

typedef struct
{
    unsigned short  value;      ///< The read back value
    unsigned char   status;     ///< 0: success, others: read register fail.
} RegRead_Cnf;

typedef struct
{
    unsigned int    addr;       ///< The address of register that is to be written.
    unsigned short  value;      ///< The value that is to be written.
} RegWrite_Req;

typedef struct
{
    unsigned char   status;     ///< 0: success, others: write register fail.
} RegWrite_Cnf;

typedef struct
{
    unsigned char   channel;    ///< ADC channel number.
    unsigned short  Meacount;   ///< Number of measure times.
} ADCMeaData_Req;

typedef struct
{
    unsigned int    value;      ///< ADC value, it a sum value of each measurement data.
    int                drv_status; /// SP META use this status
    unsigned char   status;     ///< 0: success, others: get ADC measurement fail.
} ADCMeaData_Cnf;

//-----------------------------------------------------//
//  BaseBand Testing: callback function definition     //
//-----------------------------------------------------//
typedef void (__stdcall* META_BB_READREG_CNF)(const RegRead_Cnf* result, const short token, void* usrData);
typedef void (__stdcall* META_BB_WRITEREG_CNF)(const RegWrite_Cnf* result, const short token, void* usrData);
typedef void (__stdcall* META_BB_ADCGETMEADATA_CNF)(const ADCMeaData_Cnf* result, const short token, void* usrData);

//-----------------------------------------------------//
//  BaseBand Testing: exported function definition     //
//-----------------------------------------------------//
/**
  * \ingroup fpOnly
  * \sa non-reentrant version of META_BB_RegRead_r
  */
META_RESULT  __stdcall META_BB_RegRead(const RegRead_Req* req, const META_BB_READREG_CNF cb, short* token, void* usrData);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_RegRead_r(const int meta_handle, const RegRead_Req* req, const META_BB_READREG_CNF cb, short* token, void* usrData);
/**
  * \ingroup fpOnly
  * \sa non-reentrant version of META_BB_RegWrite
  */
META_RESULT  __stdcall META_BB_RegWrite(const RegWrite_Req* req, const META_BB_WRITEREG_CNF cb, short* token, void* usrData);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_RegWrite_r(const int meta_handle, const RegWrite_Req* req, const META_BB_WRITEREG_CNF cb, short* token, void* usrData);
/**
  * \ingroup fpOnly
  * \sa non-reentrant version of META_PMIC_RegRead_r
  */
META_RESULT  __stdcall META_PMIC_RegRead(unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_PMIC_RegRead_r(const int meta_handle, unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_PMIC_RegWrite(unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_PMIC_RegWrite_r(const int meta_handle, unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
/**
  * \ingroup fpOnly
  * \sa non-reentrant version of META_BB_ADCGetMeaSumData_r
  */
META_RESULT  __stdcall META_BB_ADCGetMeaSumData(const ADCMeaData_Req* req, const META_BB_ADCGETMEADATA_CNF cb, short* token, void* usrData);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_r(const int meta_handle, const ADCMeaData_Req* req, const META_BB_ADCGETMEADATA_CNF cb, short* token, void* usrData);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_Ex(const unsigned int ms_timeout, const ADCMeaData_Req* req, ADCMeaData_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_Ex_r(const int meta_handle, const unsigned int ms_timeout, const ADCMeaData_Req* req, ADCMeaData_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_RegRead_Ex(unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_RegRead_Ex_r(const int meta_handle, unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_RegWrite_Ex(unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_BB_RegWrite_Ex_r(const int meta_handle, unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
//----------------------------------------------------//
//                     RTC control                    //
//----------------------------------------------------//
//--------------------------------------------------------------------------//
//  FAT Access                                                              //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  FAT Access: data structure definition              //
//-----------------------------------------------------//
typedef enum
{
    FAT_OPEN_READ = 0,
    FAT_OPEN_WRITE
} FAT_OPEN_MODE;

typedef enum
{
    FAT_FIND_FILE = 0,
    FAT_FIND_FILE_RECURSIVE,
    FAT_FIND_DIR_RECURSIVE
} FAT_FIND_MODE;

typedef enum
{
    FAT12 = 0,
    FAT16,
    FAT32
} FAT_TYPE;

typedef struct
{
    FAT_TYPE        Type;
    unsigned int    SectorsPerCluster;
    unsigned int    TotalSize;
    unsigned int    FreeSpace;
} FAT_DiskInfo_T;

typedef struct
{
    FAT_TYPE        Type;
    unsigned int    SectorsPerCluster;
    unsigned int    TotalSize_high;
    unsigned int    FreeSpace_high;
    unsigned int    TotalSize_low;
    unsigned int    FreeSpace_low;
} FAT_DiskInfo_EX_T;

typedef struct
{
    char m_cDriveLetter;   ///< Target FAT disk drive letter such as: 'C'
    char* m_pcfilepath;    ///< File path of the file we intend to write into target FAT

} FAT_FILE_INFO_REQ_T;

typedef struct
{
    FAT_FILE_INFO_REQ_T req;
    /// target side file path to check whether existing file presents
    const char* targetFilePath;
} FAT_FILE_INFO_REQ_EX_T;

typedef struct
{
    WCHAR m_wDriveLetter;   ///< Target FAT disk drive letter such as: 'C'
    WCHAR* m_pwcFilePath;   ///< File path of the file we intend to write into target FAT
} FAT_UTF_FILE_INFO_REQ_T;

typedef struct
{
    FAT_UTF_FILE_INFO_REQ_T req;
    /// target side file path to check whether existing file presents
    const WCHAR* pwcTargetFilePath;
} FAT_UTF_FILE_INFO_REQ_EX_T;
//-----------------------------------------------------/n
//  FAT Access: callback function definition           //
//-----------------------------------------------------//
typedef int (__stdcall* CALLBACK_META_FAT_PROGRESS)(unsigned char percent, int sent_bytes, int total_bytes, const short token, void* usr_arg);

//-----------------------------------------------------//
//  FAT Access: exported function definition           //
//-----------------------------------------------------//
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Open(const char* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Open_r(const int meta_handle, const char* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Close(int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Close_r(const int meta_handle, int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_GetFileSize(const int fs_handle, int* filesize, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_GetFileSize_r(const int meta_handle, const int fs_handle, int* filesize, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Read(const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Read_r(const int meta_handle, const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Write(const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Write_r(const int meta_handle, const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Read_To_File(const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Read_To_File_r(const int meta_handle, const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Write_By_File(const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Write_By_File_r(const int meta_handle, const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Delete(const char* fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Delete_r(const int meta_handle, const char* fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Move(const char* fat_filepath, const char* new_fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Move_r(const int meta_handle, const char* fat_filepath, const char* new_fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Find_Start(const char* fat_base_dir, const char* fat_find_pattern, FAT_FIND_MODE     find_mode, int* p_find_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Find_Start_r(const int meta_handle, const char* fat_base_dir, const char* fat_find_pattern, FAT_FIND_MODE    find_mode, int* p_find_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Find_Head(int find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Find_Prev(int find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Find_Next(int find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Find_GetFileInfo(int find_handle, char* p_filepath, const int filepath_len, int* p_filesize);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Find_Close(int* p_find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_GetDiskInfo(const char DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_GetDiskInfo_r(const int meta_handle, const char DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_GetDiskInfo_Ex(const char DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_GetDiskInfo_Ex_r(const int meta_handle, const char DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_RemoveDir(const char* fat_dirpath);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_RemoveDir_r(const int meta_handle, const char* fat_dirpath);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_FAT_CheckEnoughSpace(FAT_FILE_INFO_REQ_T* req);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_FAT_CheckEnoughSpace_r(const int meta_handle, FAT_FILE_INFO_REQ_T* req);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_FAT_CheckEnoughSpaceEx(FAT_FILE_INFO_REQ_EX_T* req_ex);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_FAT_CheckEnoughSpaceEx_r(const int meta_handle, FAT_FILE_INFO_REQ_EX_T* req_ex);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Read_To_File_Ex(const int fs_handle, const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Read_To_File_Ex_r(const int meta_handle, const int fs_handle,
        const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Write_By_File_Ex(const int fs_handle,
        const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopfalg);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_Write_By_File_Ex_r(const int meta_handle,
        const int fs_handle,
        const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_CopyDirFromTarget(const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_CopyDirFromTarget_r(const int meta_handle, const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_CopyDirFromPc(const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_CopyDirFromPc_r(const int meta_handle, const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_RemoveDirEx(const char* fat_dirpath, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_RemoveDirEx_r(const int meta_handle, const char* fat_dirpath, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_DeleteEx(const char* fat_filepath, short* p_token, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_DeleteEx_r(const int meta_handle, const char* fat_filepath, short* p_token, int* p_stopflag);
/**
 * \ingroup fpOnly
 * \brief the non-reentrant version of META_FAT_GetDriveType_r
 */
META_RESULT  __stdcall META_FAT_GetDriveType(unsigned int ms_timeout, const char DriveLetter, int* p_DriveType);
/**
 * \ingroup fpOnly
 * \details get the FS drive type by given drive letter
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param DriveLetter the drive letter to be checked (MBCS)
 * \param p_DriveType the drive type NOR_DRIVE = 1,
 * NAND_DRIVE=2,
 * CARD_DRIVE = 3,
 * EXTERNAL_DRIVE = 4
 */
META_RESULT  __stdcall META_FAT_GetDriveType_r(const int meta_handle, unsigned int ms_timeout, const char DriveLetter, int* p_DriveType);

//-----------------------------------------------------------------------------
// FAT UTF(Unicode) API
//-----------------------------------------------------------------------------
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Open(const WCHAR* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Open_r(const int meta_handle, const WCHAR* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Close(int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Close_r(const int meta_handle, int* fs_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_GetFileSize(const int fs_handle, int* filesize, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_GetFileSize_r(const int meta_handle, const int fs_handle, int* filesize, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Read(const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Read_r(const int meta_handle, const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Write(const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Write_r(const int meta_handle, const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Read_To_File(const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Read_To_File_r(const int meta_handle, const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Write_By_File(const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Write_By_File_r(const int meta_handle, const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Delete(const WCHAR* fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Delete_r(const int meta_handle, const WCHAR* fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Move(const WCHAR* fat_filepath, const WCHAR* new_fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Move_r(const int meta_handle, const WCHAR* fat_filepath, const WCHAR* new_fat_filepath, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Find_Start(const WCHAR* fat_base_dir, const WCHAR* fat_find_pattern, FAT_FIND_MODE find_mode, int* p_find_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Find_Start_r(const int meta_handle, const WCHAR* fat_base_dir, const WCHAR* fat_find_pattern, FAT_FIND_MODE find_mode, int* p_find_handle, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Find_Head(int find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Find_Prev(int find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Find_Next(int find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Find_GetFileInfo(int find_handle, WCHAR* p_filepath, const int filepath_len, int* p_filesize);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Find_Close(int* p_find_handle);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo(const WCHAR DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo_r(const int meta_handle, const WCHAR DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo_Ex(const WCHAR DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo_Ex_r(const int meta_handle, const WCHAR DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_RemoveDir(const WCHAR* fat_dirpath);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_RemoveDir_r(const int meta_handle, const WCHAR* fat_dirpath);
/**
  * \ingroup fpOnly
  */

META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpace(FAT_FILE_INFO_REQ_T* req);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpace_r(const int meta_handle, FAT_UTF_FILE_INFO_REQ_T* req);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpaceEx(FAT_FILE_INFO_REQ_EX_T* req_ex);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpaceEx_r(const int meta_handle, FAT_UTF_FILE_INFO_REQ_EX_T* req_ex);

/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Read_To_File_Ex(const int fs_handle, const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Read_To_File_Ex_r(const int meta_handle, const int fs_handle,
        const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Write_By_File_Ex(const int fs_handle,
        const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopfalg);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_Write_By_File_Ex_r(const int meta_handle,
        const int fs_handle,
        const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_CopyDirFromTarget(const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_CopyDirFromTarget_r(const int meta_handle, const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_CopyDirFromPc(const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_CopyDirFromPc_r(const int meta_handle, const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS cb_progress, void* cb_progress_arg, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_RemoveDirEx(const WCHAR* fat_dirpath, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_RemoveDirEx_r(const int meta_handle, const WCHAR* fat_dirpath, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_DeleteEx(const WCHAR* fat_filepath, short* p_token, int* p_stopflag);
/**
  * \ingroup fpOnly
  */
META_RESULT  __stdcall META_FAT_UTF_DeleteEx_r(const int meta_handle, const WCHAR* fat_filepath, short* p_token, int* p_stopflag);
/**
 * \ingroup fpOnly
 * \brief the non-reentrant version of META_FAT_UTF_GetDriveType_r
 */
META_RESULT  __stdcall META_FAT_UTF_GetDriveType(unsigned int ms_timeout, const WCHAR DriveLetter, int* p_DriveType);
/**
 * \ingroup fpOnly
 * \details get the FS drive type by given drive letter
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param DriveLetter the drive letter to be checked (unicode)
 * \param p_DriveType the drive type NOR_DRIVE = 1,
 * NAND_DRIVE=2,
 * CARD_DRIVE = 3,
 * EXTERNAL_DRIVE = 4
 */
META_RESULT  __stdcall META_FAT_UTF_GetDriveType_r(const int meta_handle, unsigned int ms_timeout, const WCHAR DriveLetter, int* p_DriveType);
/**
  * \ingroup General
  * \sa non-reentrant version of META_Check_ULC_support_r
  */
META_RESULT  __stdcall META_Check_ULC_support(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_Check_ULC_support_r(const int meta_handle, unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_Check_SmartPhoneModem_support_r
  */
META_RESULT  __stdcall META_Check_SmartPhoneModem_support(unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_Check_SmartPhoneModem_support_r(const int meta_handle, unsigned int ms_timeout);


typedef enum
{
    META_VERSION_USER_DEFINE
    , META_VERSION_META_DLL_UTIL_VER
    , VER_TYPE_END

} META_VERSION_TYPE;

typedef struct
{

    META_VERSION_TYPE   m_eVerType;       /**< version type setting*/
    unsigned int        m_u4MainVersion;  /**< the main version for checking. valid when m_eVerType = META_VERSION_USER_DEFINE*/ 
    unsigned int        m_u4MinorVersion; /**< the minor version for checking. valid when m_eVerType = META_VERSION_USER_DEFINE*/
    unsigned int        m_u4BuildNum;     /**< the build number for checking. valid when m_eVerType = META_VERSION_USER_DEFINE*/
} META_UTIL_CHECK_TARGET_VER_REQ_T;

typedef struct
{    
   bool         m_bCheckPass;           /**< result of target version check. true is check pass, and false is check failed */
   unsigned int m_u4TargetMainVersion;  /**< the main version of target*/
   unsigned int m_u4TargetMinorVersion; /**< the minor version of target*/
   unsigned int m_u4TargetBuildNum;     /**< the build number of target*/
} META_UTIL_CHECK_TARGET_VER_CNF_T;
typedef struct
{
    bool  b_TargetAssertCheckFlag;
    bool  b_SetCurRecvMsgTimes;
    unsigned char m_u1CurRecvMsgTimes;  ///< valid when b_SetCurRecvMsgTimes = true
} META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T;

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_CheckTargetRequiredVersion_r
  */
META_RESULT  __stdcall META_Util_CheckTargetRequiredVersion(unsigned int ms_timeout, const META_UTIL_CHECK_TARGET_VER_REQ_T* req, META_UTIL_CHECK_TARGET_VER_CNF_T* cnf );
/**
  * \ingroup Utility
  * \details check the version of target required 
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param req the target version info for checking
  * \param cnf result from target  
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT  __stdcall META_Util_CheckTargetRequiredVersion_r(const int meta_handle, unsigned int ms_timeout, const META_UTIL_CHECK_TARGET_VER_REQ_T* req, META_UTIL_CHECK_TARGET_VER_CNF_T* cnf );

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_SetTargetAssertCheckParas_r
  */
META_RESULT  __stdcall META_Util_SetTargetAssertCheckParas(unsigned int ms_timeout, const META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T* req);

/**
  * \ingroup Utility
  * \details NOT USED NOW
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param req the target version info for checking
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT  __stdcall META_Util_SetTargetAssertCheckParas_r(const int meta_handle, unsigned int ms_timeout, const META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T* req);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_CheckIfTargetNVSecOn_r
  */
META_RESULT  __stdcall META_Util_CheckIfTargetNVSecOn(unsigned int ms_timeout, bool* bOn);
/**
  * \ingroup Utility
  * \details check target nvram security is on or off 
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param bOn the check value. false is off. true is on.
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT  __stdcall META_Util_CheckIfTargetNVSecOn_r(const int meta_handle, unsigned int ms_timeout, bool* bOn);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_RebootToNormalMode_r
  */
META_RESULT __stdcall META_Util_RebootToNormalMode(unsigned int ms_timeout, unsigned short timeout);
/**
  * \ingroup Utility
  * \details reboot to normal mode 
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param timeout wait the timeout to reboot
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT __stdcall META_Util_RebootToNormalMode_r(const int meta_handle, unsigned int ms_timeout, unsigned short timeout);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_QueryBTWiFiSingleAntennaCap_r
  */
META_RESULT __stdcall META_Util_QueryBTWiFiSingleAntennaCap(unsigned int ms_timeout, bool* bOn);
/**
  * \ingroup Utility
  * \details not supports
  */
META_RESULT __stdcall META_Util_QueryBTWiFiSingleAntennaCap_r(const int meta_handle, unsigned int ms_timeout, bool* bOn);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_SetAntennaPathToBT_r
  */
META_RESULT __stdcall META_Util_SetAntennaPathToBT(const unsigned int ms_timeout);
/**
  * \ingroup Utility
  * \details not supports
  */
META_RESULT __stdcall META_Util_SetAntennaPathToBT_r(const int meta_handle, const unsigned int ms_timeout);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_SetAntennaPathToWiFi_r
  */
META_RESULT __stdcall META_Util_SetAntennaPathToWiFi(const unsigned int ms_timeout);
/**
  * \ingroup Utility
  * \details not supports
  */
META_RESULT __stdcall META_Util_SetAntennaPathToWiFi_r(const int meta_handle, const unsigned int ms_timeout);

#define META_LIPTON_OPTION_ON   0x00000001
#define META_TC01_OPTION_ON     0x00000002
#define META_AST_TD_OPTION_ON   0x00000004

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_QueryTargetOptionInfo_r
  */
META_RESULT __stdcall META_Util_QueryTargetOptionInfo(const unsigned int ms_timeout, unsigned int* info);

/**
  * \ingroup Utility
  * \details query the information of target option 
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param info option value. 0x1 => LIPTON_OPTION_ON, 0x2 => META_TC01_OPTION_ON, 0x4 => META_AST_TD_OPTION_ON
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.  
  */
META_RESULT __stdcall META_Util_QueryTargetOptionInfo_r(const int meta_handle, const unsigned int ms_timeout, unsigned int* info);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_QueryTargetLimitedStateIndicator_r
  */
META_RESULT __stdcall META_Util_QueryTargetLimitedStateIndicator(const unsigned int ms_timeout, unsigned int* info);

/**
  * \ingroup Utility
  * \details query the limited state indicator of target 
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param info information of limited state indicator
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT __stdcall META_Util_QueryTargetLimitedStateIndicator_r(const int meta_handle, const unsigned int ms_timeout, unsigned int* info);

typedef struct
{
    /// number of elements in the list
    unsigned int validNumber;
    /// voltage list (unit: micro volt 10^-6)
    unsigned int voltageList[255];
    /// register value of each voltageList
    unsigned int registerValue[255];
} MetaVpaVoltageList;
/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_QueryVpaVoltageList_r
  */
META_RESULT __stdcall META_Util_QueryVpaVoltageList(const unsigned int ms_timeout, MetaVpaVoltageList* vpaVoltageList);

/**
  * \ingroup Utility
  * \details query the vpa voltage list of target 
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param vpaVoltageList the list of vpa voltage
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT __stdcall META_Util_QueryVpaVoltageList_r(const int meta_handle, const unsigned int ms_timeout, MetaVpaVoltageList* vpaVoltageList);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_QueryDriveAvailableForFileSize_r
  */
META_RESULT __stdcall META_Util_QueryDriveAvailableForFileSize(unsigned int ms_timeout, unsigned int size, short* driveLetter);

/**
  * \ingroup Utility
  * \details query whether the target has driver avaiable for requested file
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param size requested file size
  * \param driveLetter returned drive letter (<0: not found)
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT __stdcall META_Util_QueryDriveAvailableForFileSize_r(const int meta_handle, unsigned int ms_timeout, unsigned int size, short* driveLetter);

/**
  * \ingroup Utility
  * \sa non-reentrant version of META_Util_QueryMaxControlBuffer_r
  */
META_RESULT __stdcall META_Util_QueryMaxControlBuffer(unsigned int ms_timeout, unsigned int* size);

/**
  * \ingroup Utility
  * \details query the size of max control buffer
  * \param meta_handle meta handle
  * \param ms_timeout time out (ms)
  * \param size requested max control buffer size
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT __stdcall META_Util_QueryMaxControlBuffer_r(const int meta_handle, unsigned int ms_timeout, unsigned int* size);

/**
 * \ingroup Utility
 * \sa non-reentrant version of META_Util_QueryAdcModuleSupport_r
 */
META_RESULT __stdcall META_Util_QueryAdcModuleSupport(unsigned int ms_timeout, unsigned char* support);
/**
 * \ingroup Utility
 * \details query the ADC module support
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param support 1:suport 0:not support
 */
META_RESULT __stdcall META_Util_QueryAdcModuleSupport_r(const int meta_handle, unsigned int ms_timeout, unsigned char* support);
/**
 * \ingroup Utility
 * \sa non-reentrant version of META_Util_QueryRtcModuleSupport_r
 */
META_RESULT __stdcall META_Util_QueryRtcModuleSupport(unsigned int ms_timeout, unsigned char* support);
/**
 * \ingroup Utility
 * \details query the RTC module support
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param support 1:suport 0:not support
 */
META_RESULT __stdcall META_Util_QueryRtcModuleSupport_r(const int meta_handle, unsigned int ms_timeout, unsigned char* support);
/**
 * \ingroup Utility
 * \sa non-reentrant version of META_Util_EnableTstMetaTraceMode_r
 */
META_RESULT __stdcall META_Util_EnableTstMetaTraceMode(const unsigned int ms_timeout, const unsigned char trace_mode);
/**
 * \ingroup Utility
 * \details enable META mode trace
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param trace_mode 0: disable 1: catcher relay 2: file dump
 */
META_RESULT __stdcall META_Util_EnableTstMetaTraceMode_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char trace_mode);
/**
 * \ingroup Utility
 * \sa non-reentrant version of META_Util_QueryTstMetaTraceMode_r
 */
META_RESULT __stdcall META_Util_QueryTstMetaTraceMode(const unsigned int ms_timeout, unsigned char* trace_mode);
/**
 * \ingroup Utility
 * \details query status of META mode trace
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param trace_mode 0: disable 1: catcher relay 2: file dump
 */
META_RESULT __stdcall META_Util_QueryTstMetaTraceMode_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* trace_mode);
//----------------------------------------------------------------------//
//       META MDLogging: exported functions for modem logging
//----------------------------------------------------------------------//
/**
 * \ingroup MDLogging
 * \sa non-reentrant version of META_MDLogging_SetModemLogFilterToTarget_r
 */
META_RESULT __stdcall META_MDLogging_SetFilterToTarget (const char* filter_file_path);
/**
 * \ingroup MDLogging
 * \details set the modem log filter to target
 * \param meta_handle meta handle
 * \param filter_file_path the path of the modem log filter
 * \retval META_SUCCESS  success in transmitting the modem log filter to target
 * \retval Other error code  use META_GetErrorString to translate the meaning.
 */
META_RESULT __stdcall META_MDLogging_SetFilterToTarget_r (const int meta_handle, const char* filter_file_path);
#ifdef _WIN32
/**
 * \ingroup MDLogging
 * \sa non-reentrant version of META_MDLogging_SetModemLogFilterToTarget_Unicode_r
 */
META_RESULT __stdcall META_MDLogging_SetFilterToTarget_Unicode (WCHAR* filter_file_path);
/**
 * \ingroup MDLogging
 * \details set the modem log filter to target
 * \param meta_handle meta handle
 * \param filter_file_path the path of the modem log filter
 * \retval META_SUCCESS  success in transmitting the modem log filter to target
 * \retval Other error code  use META_GetErrorString to translate the meaning.
 */
META_RESULT __stdcall META_MDLogging_SetFilterToTarget_Unicode_r (const int meta_handle, WCHAR* filter_file_path);
#endif // #ifdef _WIN32

/**
  * \ingroup MDLogging
  * \sa non-reentrant version of META_MDLogging_GetMetaDefaultFilterFile_rW
  */
META_RESULT  __stdcall META_MDLogging_GetMetaDefaultFilterFile_r(const int meta_handle, const char* db_path, char* p_output_filter_folder);

/**
  * \ingroup MDLogging
  * \details get the meat default filter file from target
  * \param meta_handle meta handle
  * \param db_path the path of the meta data base.
  * \param p_output_filter_folder the output filter folder path.
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT  __stdcall META_MDLogging_GetMetaDefaultFilterFile_rW(const int meta_handle, const wchar_t* db_path, char* p_output_filter_folder);

/**
  * \ingroup MDLogging
  * \sa non-reentrant version of META_MDlogging_GetMemoryDumpFile_rW
  */
META_RESULT  __stdcall META_MDlogging_GetMemoryDumpFile_r(const int meta_handle, const char* db_path, char* p_output_file);

/**
  * \ingroup MDLogging
  * \details get the memory dump file from target
  * \param meta_handle meta handle
  * \param db_path the path of the meta data base.
  * \param p_output_file the output file path.
  * \retval META_SUCCESS  The operation completed successfully
  * \retval Other error code  use META_GetErrorString to translate the meaning.
  */
META_RESULT  __stdcall META_MDlogging_GetMemoryDumpFile_rW(const int meta_handle, const wchar_t* db_path, const wchar_t* p_output_file);

//----------------------------------------------------------------------//
//       META Misc: backup and restore calibration Data
//----------------------------------------------------------------------//
typedef void (__stdcall* CALLBACK_MISC_PROGRESS)(unsigned char m_u1TotalNum, unsigned char m_u1BackupNum, void* usr_arg);
typedef void (__stdcall* CALLBACK_MISC_IMEI_PROGRESS)(const int imei_max_num, const char** errMsg, const char** imei, void* usr_arg);
typedef void (__stdcall* CALLBACK_MISC_MACADDR_PROGRESS)(const char* message, const char* mac_addr, void* usr_arg);

typedef enum
{
    META_STORAGE_TYPE_FAT = 0,
    META_STORAGE_TYPE_OTP,
    META_STORAGE_TYPE_SECRO,
    META_STORAGE_TYPE_END
} META_IMEI_LOC_enum;

typedef struct
{
    char*                    m_pIniFilePath;
    char*                    m_pBackupFolderPath; // Let customer choose the backup folder
    //Note: it should be different by meta_handle!
    CALLBACK_MISC_PROGRESS  cb_progress;
    void*                    cb_progress_arg;
} MISC_BACKUP_REQ_T;

typedef struct
{
    const wchar_t*          m_pIniFilePath;
    const wchar_t*          m_pBackupFolderPath; // Let customer choose the backup folder
    //Note: it should be different by meta_handle!
    CALLBACK_MISC_PROGRESS  cb_progress;
    void*                   cb_progress_arg;
} MISC_BACKUP_REQ_TW;

typedef struct
{
    char*                    m_pIniFilePath;
    char*                    m_pBackupFolderPath; // the folder which store the backup data
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                     cb_progress_arg;

} MISC_RESTORE_REQ_T;

typedef struct
{
    const wchar_t*           m_pIniFilePath;
    const wchar_t*           m_pBackupFolderPath; // the folder which store the backup data
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                    cb_progress_arg;

} MISC_RESTORE_REQ_TW;

typedef struct
{
    /// restore request
    MISC_RESTORE_REQ_T              restoreRequest;
    /// file transfer progress callback function
    CALLBACK_META_FAT_PROGRESS      cb_filetransfer_progress;
    /// user argument for file transfer progress callback
    void*                           filetransfer_arg;
} MISC_RESTORE_REQ_EX_T;

typedef struct
{
    /// restore request
    MISC_RESTORE_REQ_TW            restoreRequest;
    /// file transfer progress callback function
    CALLBACK_META_FAT_PROGRESS      cb_filetransfer_progress;
    /// user argument for file transfer progress callback
    void*                           filetransfer_arg;
} MISC_RESTORE_REQ_EX_TW;

typedef struct
{
    char                 m_strBackupFolder[MAX_PATH];
    bool                 m_bISNewLoad;
    META_IMEI_LOC_enum   m_enumImeiLoc; // only valid when m_bISNewLoad = true;
    unsigned  char       m_ImeiData[10]; // only valid when m_bISNewLoad = true
    int                  m_i4ComPort;
    int                  m_i4BackupFileNum;

} BACKUP_RESULT_T;

typedef struct
{

    char                    m_strRestoreFromFolder[MAX_PATH];
    bool                    m_bISNewLoad;
    META_IMEI_LOC_enum      m_enumImeiLoc; // only valid when m_bISNewLoad = true;
    unsigned char           m_ImeiData[10]; // only valid when m_bISNewLoad = true;
    int                     m_i4ComPort;
    int                     m_i4BackupFileNum;


} RESTORE_RESULT_T;

typedef struct
{
    char*                    m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                     cb_progress_arg;

} MISC_UPLOAD_REQ_T;

typedef struct
{
    const wchar_t*           m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                    cb_progress_arg;
} MISC_UPLOAD_REQ_TW;

typedef struct
{
    char*                    m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                     cb_progress_arg;
    CALLBACK_MISC_IMEI_PROGRESS   cb_imei_progress;
    void*                     cb_imei_progress_arg;
} MISC_UPLOAD_REQ_EX_T;

typedef struct
{
    const wchar_t*              m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS      cb_progress;
    void*                       cb_progress_arg;
    CALLBACK_MISC_IMEI_PROGRESS cb_imei_progress;
    void*                       cb_imei_progress_arg;
} MISC_UPLOAD_REQ_EX_TW;

typedef struct
{
    MISC_UPLOAD_REQ_EX_T            uploadRequest;
    CALLBACK_META_FAT_PROGRESS      cb_filetransfer_progress;
    void*                           filetransfer_arg;
    CALLBACK_MISC_MACADDR_PROGRESS  cb_macaddr_progress;
    void*                           macaddr_arg;
} MISC_UPLOAD_REQ_EX2_T;

typedef struct
{
    MISC_UPLOAD_REQ_EX_TW          uploadRequest;
    CALLBACK_META_FAT_PROGRESS      cb_filetransfer_progress;
    void*                           filetransfer_arg;
    CALLBACK_MISC_MACADDR_PROGRESS  cb_macaddr_progress;
    void*                           macaddr_arg;
} MISC_UPLOAD_REQ_EX2_TW;

typedef struct
{
    unsigned short record_index;  /**< \brief [IN]  the index of imei record, if want to read record1 must be set 1 */
    char           imei[16];      /**< \brief [OUT] the value of IMEI */
    unsigned char  svn;           /**< \brief [OUT] the svn of IMEI */
} META_GET_IMEI_T;

typedef struct
{
    unsigned short record_index;  /**< \brief [IN]  the index of barcode record, if want to read record1 must be set 1 */
    unsigned int   bufferLength;  /**< \brief [IN]  the length of barcode buffer */
    char*          buffer;        /**< \brief [OUT] the buffer of barcode */
} META_GET_BARCODE_T;

/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetIMEILocation_r
  */
META_RESULT __stdcall META_MISC_GetIMEILocation(const unsigned int ms_timeout, META_IMEI_LOC_enum* storagetype);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetIMEILocation_r(const int meta_handle, const unsigned int ms_timeout, META_IMEI_LOC_enum* storagetype);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetIMEIRecNum_r
  */
META_RESULT __stdcall META_MISC_GetIMEIRecNum(const unsigned int ms_timeout, unsigned short* rec_num);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetIMEIRecNum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* rec_num);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_QueryNVRAMFolderAmount_r
  */
META_RESULT __stdcall META_MISC_QueryNVRAMFolderAmount(const unsigned int ms_timeout, unsigned char* folder_amount);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_QueryNVRAMFolderAmount_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* folder_amount);
/**
 * \ingroup General
 * \sa non-reentrant version of META_MISC_CheckSIM1Inserted_r
 */
META_RESULT __stdcall META_MISC_CheckSIM1Inserted(const unsigned int ms_timeout, unsigned char* inserted);
/**
 * \ingroup General
 * \details check the SIM1 HW status via SIM module
 * \param [in] meta_handle context handle to specific DUT
 * \param [in] ms_timeout API transaction timeout value in milliseconds
 * \param [out] inserted 1: inserted 0: not inserted
 */
META_RESULT __stdcall META_MISC_CheckSIM1Inserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* inserted);

/**
 * \ingroup General
 * \sa non-reentrant version of META_MISC_CheckSIM2Inserted_r
 */
META_RESULT __stdcall META_MISC_CheckSIM2Inserted(const unsigned int ms_timeout, unsigned char* inserted);
/**
 * \ingroup General
 * \details check the SIM2 HW status via SIM module
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param inserted 1: inserted 0: not inserted
 */

META_RESULT __stdcall META_MISC_CheckSIM2Inserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* inserted);

/**
 * \ingroup General
 * \sa non-reentrant version of META_MISC_CheckGeminiPlusSIMInserted_r
 */
META_RESULT __stdcall META_MISC_CheckGeminiPlusSIMInserted(const unsigned int ms_timeout, unsigned char sim_module_index, unsigned char* inserted);
/**
 * \ingroup General
 * \details check the SIM HW status via SIM module
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param sim_module_index index of SIM module
 * \param inserted 1: inserted 0: not inserted
 */
META_RESULT __stdcall META_MISC_CheckGeminiPlusSIMInserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char sim_module_index, unsigned char* inserted);

/**
 * \ingroup General
 * \sa non-reentrant version of META_MISC_SimHwTest_r
 */
META_RESULT __stdcall META_MISC_SimHwTest(const unsigned int ms_timeout, unsigned char simModuleId, int* status);
/**
 * \ingroup General 
 * \details check the SIM HW status via SIM driver
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param simModuleId index of SIM driver module (0: sim1, 1: sim2...)
 * \param status the status of HW test (0: OK, otherwise: error code for SIM driver)
 */
META_RESULT __stdcall META_MISC_SimHwTest_r(const int meta_handle, const unsigned int ms_timeout, unsigned char simModuleId, int* status);
#define MUIC_MODE_CHARGE_ON     0
#define MUIC_MODE_CHARGE_OFF    1
#define MUIC_MODE_USB_500       2
#define MUIC_MODE_ISET_PROGRAM  3
#define MUIC_MODE_USB_100       4
#define MUIC_MODE_TEST_MODE     5
#define MUIC_MODE_USB_100_2     6
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_SetMuicChargerMode_r
  */
META_RESULT __stdcall META_MISC_SetMuicChargerMode(const unsigned int ms_timeout, const unsigned char* req_mode);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_SetMuicChargerMode_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char* req_mode);


typedef struct
{
    const char*          LID;   /**< The name of logical data item ID */
    unsigned short      u2RID;  /**< Record ID (the first record is 1) */
} META_MISC_CAL_DATA_INTEGRITY_ENTRY;

typedef struct
{

    bool                bAllPass;  /**< true: check pass, false: no items or check fail */
    unsigned short      u2LastLID;  /**< valid when bAllPass == false */
    unsigned short      u2LastRID;  /**< valid when bAllPass == false */
} META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T;

/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_StartRec_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec(const unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec_r(const int meta_handle, const unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_StartRec_Ex_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec_Ex(const unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec_Ex_r(const int meta_handle, const unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_StopRec_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec(const unsigned int ms_timeout, int* rec_num);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec_r(const int meta_handle, const unsigned int ms_timeout, int* rec_num);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_StopRec_Ex_R
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec_Ex(const unsigned int ms_timeout, int* rec_num);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec_Ex_r(const int meta_handle, const unsigned int ms_timeout, int* rec_num);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_AddOne_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_AddOne_Ex_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne_Ex(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne_Ex_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_DelOne_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_DelOne_Ex_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne_Ex(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne_Ex_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_DelAll_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll(const unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll_r(const int meta_handle, const unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_DelAll_Ex_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll_Ex(const unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll_Ex_r(const int meta_handle, const unsigned int ms_timeout);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_CheckOne_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_CalDataIntegrity_CheckAll_r
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckAll(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T* cnf);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckAll_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T* cnf);

#define META_MISC_SUPPORTED_MAX_ADC_CHN_NUM 20

typedef struct
{
    bool bADCStoredInEfuse;  /**< true: ADC is stored in EFUSE, not in NVRAM data. */
    int  i4ADCChnNum;  /**< specify the adc channel number supported by this phone */
    int  i4ADCSlope[META_MISC_SUPPORTED_MAX_ADC_CHN_NUM]; /**< [0 ~ iADCChnNum-1] is valid when bADCStoredInEfuse = true */
    int  i4ADCOffset[META_MISC_SUPPORTED_MAX_ADC_CHN_NUM];/**< [0 ~ iADCChnNum-1] is valid when bADCStoredInEfuse = true */
} META_MISC_GET_ADC_FROM_EFUSE_CNF_T;

/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetADCFromEFuse_r
  */
META_RESULT __stdcall META_MISC_GetADCFromEFuse(const unsigned int ms_timeout, META_MISC_GET_ADC_FROM_EFUSE_CNF_T* cnf);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetADCFromEFuse_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_GET_ADC_FROM_EFUSE_CNF_T* cnf);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetCalFlagEnum_r
  */
META_RESULT __stdcall META_MISC_GetCalFlagEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetCalFlagEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetRfCalEnvEnum_r
  */
META_RESULT __stdcall META_MISC_GetRfCalEnvEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetRfCalEnvEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetRfCalLossSettingEnum_r
  */
META_RESULT __stdcall META_MISC_GetRfCalLossSettingEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetRfCalLossSettingEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetRfTestPowerResultEnum_r
  */
META_RESULT __stdcall META_MISC_GetRfTestPowerResultEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetRfTestPowerResultEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetADCMaxChannel_r
  */
META_RESULT __stdcall META_MISC_GetADCMaxChannel(const unsigned int ms_timeout, unsigned char* u1Val);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetADCMaxChannel_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* u1Val);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetTADCChannelIndex_r
  */
META_RESULT __stdcall META_MISC_GetTADCChannelIndex(const unsigned int ms_timeout, unsigned char* u1Val);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetTADCChannelIndex_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* u1Val);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetRID_r
  */
META_RESULT __stdcall META_MISC_GetRID(const unsigned int ms_timeout, unsigned char* u1Rid, const unsigned int ui_RidLen);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetRID_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* u1Rid, const unsigned int ui_RidLen);

/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetIMEIValue_r
  */
META_RESULT __stdcall META_MISC_GetIMEIValue(const unsigned int ms_timeout, META_GET_IMEI_T* req);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetIMEIValue_r(const int meta_handle, const unsigned int ms_timeout, META_GET_IMEI_T* req);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetBarCodeValue_r
  */
META_RESULT __stdcall META_MISC_GetBarCodeValue(const unsigned int ms_timeout, META_GET_BARCODE_T* req);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetBarCodeValue_r(const int meta_handle, const unsigned int ms_timeout, META_GET_BARCODE_T* req);

/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BackupCalibrationData(const MISC_BACKUP_REQ_T* req, int* p_backupstop );
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BackupCalibrationData_r(const int meta_handle, const MISC_BACKUP_REQ_T* req, int* p_backupstop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BackupCalibrationData_rW(const int meta_handle, const MISC_BACKUP_REQ_TW* req, int* p_backupstop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_RestoreCalibrationData(const MISC_RESTORE_REQ_T* req, int* p_restorestop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_RestoreCalibrationData_r(const int meta_handle, const MISC_RESTORE_REQ_T* req, int* p_restorestop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_RestoreCalibrationData_rW(const int meta_handle, const MISC_RESTORE_REQ_TW* req, int* p_restorestop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_RestoreCalibrationDataEx(const MISC_RESTORE_REQ_EX_T* req, int* p_restorestop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_RestoreCalibrationDataEx_r(const int meta_handle, const MISC_RESTORE_REQ_EX_T* req, int* p_restorestop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_RestoreCalibrationDataEx_rW(const int meta_handle, const MISC_RESTORE_REQ_EX_TW* req, int* p_restorestop);

typedef struct
{
    /// full path to the file
    const char*   fullPath;
    /// file size (0: means not-avaialble in the context)
    int           fileSize;
    /// LID name or enum value
    const char*   lidOrEnum;
    /// type of the NVRAM file (0: normal, 1: imei, 2: SML)
    unsigned char fileType;
} META_MISC_RestoreFileNotFoundInBackupResult_T;
typedef struct
{
    /// file prefix of the NVRAM item
    const char*    filePrefix;
    /// verno of the NVRAM item
    const char*    versionNumber;
    /// enum value
    unsigned short enumValue;
    /// type of the NVRAM file (0: normal, 1: imei, 2: SML)
    unsigned char  fileType;
    /// file size (0: means not-avaialble in the context)
    unsigned int   fileSize;
} META_MISC_BackupFileNotFoundInNvram_T;
typedef META_MISC_BackupFileNotFoundInNvram_T META_MISC_RestoreTargetNotFoundInNvram_T;
typedef struct
{
    /// key name
    const char*   keyName;
    /// value string
    const char*   value;
} META_MISC_BackupMoreFileNotFoundInNvram_T;
typedef struct
{
    /// where we download from the target side
    const char*     backupPath;
    unsigned int    fileSize;
    /// 1: nvram sec, 2: target sec
    unsigned char   fileSection;
    /// where we store the files in PC side
    const wchar_t*  localPath;
    bool            hasLidInfo;
    /// meaningful when m_bHasLID == true;
    const char*     lidInfo;
    /// -1: not exist 0: general LID, 1: IMEI, 2: SML
    char            lidType;
    /// store the target file path we will restore!
    const char*     restorePath;
} META_MISC_BackupFileResultEntry_T;
typedef struct
{
    META_MISC_BackupFileResultEntry_T               backupResult;
    META_MISC_RestoreFileNotFoundInBackupResult_T   restoreFileInfo;
} META_MISC_BackupFileRestoreTargetSizeMismatch_T;
typedef union
{
    META_MISC_RestoreFileNotFoundInBackupResult_T   restoreFileNotFoundInBackupResultInfo;
    META_MISC_BackupFileNotFoundInNvram_T           backupFileNotFoundInNvramInfo;
    META_MISC_RestoreTargetNotFoundInNvram_T        restoreTargetNotFoundInNvramInfo;
    META_MISC_BackupMoreFileNotFoundInNvram_T       backupMoreFileNotFoundInNvramInfo;
    META_MISC_BackupFileRestoreTargetSizeMismatch_T backupFileRestoreTargetSizeMismatchInfo;
    DWORD                                           systemErrorCode;
} META_MISC_BKRSCustomizedInformation;
typedef struct
{
    META_RESULT errorCode;
    const char* message;
    int messageLength;
    META_MISC_BKRSCustomizedInformation info;
} META_MISC_BKRSCustomizedCallbackParameter;
/**
  * \ingroup fpOnly
  */
typedef int (__stdcall* CALLBACK_BKRS_ERROR_HANDLER)(const META_MISC_BKRSCustomizedCallbackParameter* param, void* userArg);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_MISC_SetBackupRestoreErrorCallback(CALLBACK_BKRS_ERROR_HANDLER cb, void* user_arg);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_MISC_SetBackupRestoreErrorCallback_r(const int meta_handle, CALLBACK_BKRS_ERROR_HANDLER cb, void* user_arg);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_DeleteAllFilesInBackupFolder(const char* pBackupFolderPath);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_DeleteAllFilesInBackupFolder_r(const int meta_handle, const char* pBackupFolderPath);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_DeleteAllFilesInBackupFolder_rW(const int meta_handle, const wchar_t* pBackupFolderPath);

/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_GetRestoreResultInfo_r(const int meta_handle, const char* backup_folder, RESTORE_RESULT_T* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_GetRestoreResultInfo_rW(const int meta_handle, const wchar_t* backup_folder, RESTORE_RESULT_T* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_GetRestoreResultInfo(const char* backup_folder, RESTORE_RESULT_T* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_GetBackupResultInfo(const char* backup_folder, BACKUP_RESULT_T* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_GetBackupResultInfo_r(const int meta_handle, const char* backup_folder, BACKUP_RESULT_T* cnf);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_GetBackupResultInfo_rW(const int meta_handle, const wchar_t* backup_folder, BACKUP_RESULT_T* cnf);

// be used in old load when IMEI and SML NVRAM files can not be accessed by File System APIs!
// i.e., IMEI and SML NVRAM files will not be backuped and restored!
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BasicBackupCalibrationData_r(const int meta_handle, const MISC_BACKUP_REQ_T* req, int* p_backupstop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BasicBackupCalibrationData_rW(const int meta_handle, const MISC_BACKUP_REQ_TW* req, int* p_backupstop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BasicBackupCalibrationData(const MISC_BACKUP_REQ_T* req, int* p_backupstop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BasicRestoreCalibrationData_r(const int meta_handle, const MISC_RESTORE_REQ_T* req, int* p_restorestop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BasicRestoreCalibrationData_rW(const int meta_handle, const MISC_RESTORE_REQ_TW* req, int* p_restorestop);
/**
  * \ingroup fpOnly
  */
META_RESULT __stdcall META_BasicRestoreCalibrationData(const MISC_RESTORE_REQ_T* req, int* p_restorestop);

/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget(MISC_UPLOAD_REQ_T* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_r(const int meta_handle, MISC_UPLOAD_REQ_T* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_rW(const int meta_handle, MISC_UPLOAD_REQ_TW* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_Ex(MISC_UPLOAD_REQ_EX_T* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_Ex_r(const int meta_handle, MISC_UPLOAD_REQ_EX_T* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_Ex_rW(const int meta_handle, MISC_UPLOAD_REQ_EX_TW* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_Ex2(MISC_UPLOAD_REQ_EX2_T* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_Ex2_r(const int meta_handle, MISC_UPLOAD_REQ_EX2_T* req, int* p_uploadstop);
/**
   * \ingroup NoDefYet
  */
META_RESULT __stdcall META_UploadFilesToTarget_Ex2_rW(const int meta_handle, MISC_UPLOAD_REQ_EX2_TW* req, int* p_uploadstop);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_GetMmiCacheEnumIndex_r
  */
META_RESULT __stdcall META_MISC_GetMmiCacheEnumIndex(const unsigned int ms_timeout, unsigned short enum_value, unsigned short* index);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_GetMmiCacheEnumIndex_r(const int meta_handle, const unsigned int ms_timeout, unsigned short enum_value, unsigned short* index);
typedef struct
{
    unsigned char sec;    /**< seconds after the minute   - [0,59] */
    unsigned char min;    /**< minutes after the hour     - [0,59] */
    unsigned char hour;   /**< hours after the midnight   - [0,23] */
    unsigned char day;    /**< day of the month           - [1,31] */
    unsigned char mon;    /**< months                         - [1,12] */
    unsigned char wday;   /**< days in a week                 - [1,7]; not correct information, so don't care. */
    unsigned char year;   /**< years                      - [0,127] */
} META_RCT_INFO_T;

#define META_ERS_FILE_NAME_WCHAR_CNT  100

typedef struct
{
    WCHAR            wQueryKey[META_ERS_FILE_NAME_WCHAR_CNT];//ers_filename[META_ERS_FILE_NAME_WCHAR_CNT];
    META_RCT_INFO_T  ers_ctime;
} META_ERS_INFO_T;

/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_EX_GetErsCount_r
  */
META_RESULT __stdcall META_MISC_EX_GetErsCount(const unsigned int ms_timeout,  int* pCnt);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_GetErsCount_r(const int meta_handle, const unsigned int ms_timeout, int* pCnt);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_EX_GetErsDataInfoByIndex_r
  */
META_RESULT __stdcall META_MISC_EX_GetErsDataInfoByIndex(const unsigned int ms_timeout,  const int index, META_ERS_INFO_T* pCnf);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_GetErsDataInfoByIndex_r(const int meta_handle, const unsigned int ms_timeout, const int index, META_ERS_INFO_T* pCnf);

/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_GetErsSize(const unsigned int ms_timeout, unsigned int* pSize);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_GetErsSize_r(const int meta_handle, const unsigned int ms_timeout, unsigned int* pSize);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_GetErsData(const unsigned int ms_timeout, WCHAR* wfilepath, const unsigned int ers_data_buf_size, unsigned char* ers_data_buffer);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_GetErsData_r(const int meta_handle, const unsigned int ms_timeout, WCHAR* wfilepath, const unsigned int ers_data_buf_size, unsigned char* ers_data_buffer);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_EX_InitBPAreaFromNVRAM_r
  */
META_RESULT __stdcall META_MISC_EX_InitBPAreaFromNVRAM(const unsigned int ms_timeout);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_InitBPAreaFromNVRAM_r(const int meta_handle, const unsigned int ms_timeout);
typedef enum
{
    META_BP_AREA_STATUS_OK = 0,
    META_BP_AREA_STATUS_EMPTY = 1,
    META_BP_AREA_STATUS_BROKEN = 2,
    META_BP_AREA_STATUS_NO_SYNC = 3,
    META_BP_AREA_STATUS_UNKNOWN = 4
} META_BP_AREA_STATUS_E;
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_EX_VerifyBPArea_r
  */
META_RESULT __stdcall META_MISC_EX_VerifyBPArea(const unsigned int ms_timeout, bool* bFastVerify, META_BP_AREA_STATUS_E* cnf);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_VerifyBPArea_r(const int meta_handle, const unsigned int ms_timeout, bool* bFastVerify, META_BP_AREA_STATUS_E* cnf);
/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_EX_BackupCalibrationToStorage_r
  */
META_RESULT __stdcall META_MISC_EX_BackupCalibrationToStorage(const unsigned int ms_timeout, unsigned int storage_mode, unsigned int* status);
/**
  * \ingroup General
  */
META_RESULT __stdcall META_MISC_EX_BackupCalibrationToStorage_r(const int meta_handle, const unsigned int ms_timeout, unsigned int storage_mode, unsigned int* status);
typedef enum
{
    SET_DL_FLAG = 0,      ///< set brom download flag
    CLR_DL_FLAG = 1,      ///< clear download flag
    SET_BL_DL_FLAG = 2  ///< set bootloader download flag
} SYSTEM_EX_CMD;

/**
  * \ingroup General
  * \sa non-reentrant version of META_MISC_EX_SetCommandToSystem_r
  */
META_RESULT  __stdcall META_MISC_EX_SetCommandToSystem(unsigned int ms_timeout, const SYSTEM_EX_CMD command);
/**
  * \ingroup General
  */
META_RESULT  __stdcall META_MISC_EX_SetCommandToSystem_r(const int meta_handle, unsigned int ms_timeout, const SYSTEM_EX_CMD command);

typedef struct
{
    char            imei[16];
    unsigned short  record_index;
    unsigned char   svn;
} META_SET_IMEI_T;
typedef struct
{
    unsigned char wifi_mac[6];
} META_SET_WIFI_T;

/**
 * \ingroup General
 * \details Set IMEI Value API for internal flashtool usage
 * \param req IMEI record setting
 * \param record_index the index of RID
 */
META_RESULT __stdcall META_MISC_SetIMEIValue_r(const int meta_handle, const unsigned int ms_timeout, META_SET_IMEI_T* req, unsigned short* record_index);
/**
 * \ingroup General
 * \sa non-reentrant version of META_MISC_SetIMEIValue_r
 */
META_RESULT __stdcall META_MISC_SetIMEIValue(const unsigned int ms_timeout, META_SET_IMEI_T* req, unsigned short* record_index);



 /**
 * \ingroup General 
 * \details Set WiFi MAC Value API for internal flashtool usage
 * \param req Wifi MAC Addresss etting
 * \param status the status code
 * \endinternal
 */
META_RESULT __stdcall META_MISC_SetWifiMacAddr_r(const int meta_handle, const unsigned int ms_timeout, META_SET_WIFI_T* req, unsigned int* status);
/**
 * \ingroup General 
 * \sa non-reentrant version of META_MISC_SetWifiMacAddr_r
 */
META_RESULT __stdcall META_MISC_SetWifiMacAddr(const unsigned int ms_timeout, META_SET_WIFI_T* req, unsigned int* status);

/*********************
 * Ram Disk dump API *
 *********************/
/**
 * \ingroup General
 * \sa non-reentrant version of META_MISC_EX_CheckRamDiskExist_r
 */
META_RESULT  __stdcall  META_MISC_EX_CheckRamDiskExist(const int timeout, char* cExist);
/**
 * \ingroup General  
 * \details Check ram disk existing or not.
 * \param[in] meta_handle meta handler
 * \param [in] timeout time out (ms)
 * \param [out] cExist 0: ramdisk is not existing. 1: ramdisk is existing.
 * \retval META_SUCCESS ram disk is existing
 * \retval META_FAILED  ram disk is not existing
 **/
META_RESULT  __stdcall  META_MISC_EX_CheckRamDiskExist_r(const int meta_handle, const int timeout, char* cExist);
/**
 * \ingroup General  
 * \sa non-reentrant version of META_MISC_EX_RamDisk_GetSize_r
 */
META_RESULT  __stdcall  META_MISC_EX_RamDisk_GetSize(const int timeout, unsigned int* i4Size);
/**
 * \ingroup General 
 * \brief Get ram disk size.
 * \param [in] meta_handle meta handler
 * \param [in] timeout time out (ms)
 * \param [out] i4Size ram disk size
 * \retval META_SUCCESS ram disk size getting successed
 * \retval META_FAILED ram disk size getting failed
 **/
META_RESULT  __stdcall  META_MISC_EX_RamDisk_GetSize_r(const int meta_handle, const int timeout, unsigned int* i4Size);
/**
  * \ingroup General
  */
META_RESULT  __stdcall  META_MISC_EX_RamDisk_Backup_To_File(const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token, int* p_stopflag);
/**
 * \ingroup General 
 * \brief Back up ram disk to file
 * \param [in] meta_handle meta handler
 * \param [in] local_filepath the path and file name to store the back up binary image
 * \param [in] cb_progress the callback of progress report
 * \param [in] cb_progress_arg the arugement of callback of progress report
 * \param [out] p_token identify token
 * \param [in] p_stopflag the stop control flag, when the flag set to true. The back up progress will stop.
 * \retval META_SUCCESS back up successfuly
 * \retval META_FAILED back up failed
 **/
META_RESULT  __stdcall  META_MISC_EX_RamDisk_Backup_To_File_r(const int meta_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token, int* p_stopflag);
/**
 * \ingroup General
 * \sa non-reentrant version of META_Customer_Func_r
 */
META_RESULT __stdcall META_Customer_Func(int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);
/**
 * \ingroup General
 * \details the virtual channel for customized test commands
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param data_in virtual channel data (input: to target side)
 * \param data_in_len length of input data
 * \param data_out virtual channel data (output: to host side)
 * \param data_out_len length of output data
 */
META_RESULT __stdcall META_Customer_Func_r(int meta_handle, int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);

/**
 * \ingroup TDSCDMA
 * \sa non-reentrant version of META_Aux_Func_r
 */
META_RESULT __stdcall META_Aux_Func(int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);
/**
 * \ingroup TDSCDMA
 * \details the virtual channel for TD test commands
 * \param meta_handle meta handle
 * \param ms_timeout time out in ms
 * \param data_in virtual channel data (input: to target side)
 * \param data_in_len length of input data
 * \param data_out virtual channel data (output: to host side)
 * \param data_out_len length of output data
 */
META_RESULT __stdcall META_Aux_Func_r(int meta_handle, int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);
#ifdef _WIN32
//--------------------------------------------------------------------------//
//  META Audio / Speech APIs
//--------------------------------------------------------------------------//
#include "meta_dll_audio.h"
//--------------------------------------------------------------------------//
//  META Multi-Media APIs
//--------------------------------------------------------------------------//
#include "meta_dll_mm.h"
//--------------------------------------------------------------------------//
//  META Connecitivty APIs
//--------------------------------------------------------------------------//
//#include "meta_dll_connectivity.h"
#endif // #ifdef _WIN32

//--------------------------------------------------------------------------//
//  META Virtual Channel APIs
//--------------------------------------------------------------------------//
typedef enum
{
    META_MODEM_SRV_INVALID = 0,
    META_MODEM_SRV_TST = 1,
    META_MODEM_SRV_DHL = 2,
    META_MODEM_SRV_ETS = 3,
    META_MODEM_SRV_NUM,
    META_MODEM_SRV_END = 0x0fffffff
} META_MODEM_SRV;

typedef enum
{
    META_MODEM_CH_NATIVE_INVALID = 0,
    META_MODEM_CH_NATIVE_TST = 1,
    META_MODEM_CH_TUNNELING = 2,
    META_MODEM_CH_TUNNELING_IGNORE_CKSM = 3,
    META_MODEM_CH_NATIVE_ETS = 4,
    META_MODEM_CH_NUM,
    META_MODEM_CH_END = 0x0fffffff
} META_MODEM_CH_TYPE;

typedef void (*MetaVCRxMsgHandler_CB)(const unsigned char* frameBuffer, unsigned int length, void* arg);
/**
  * \ingroup C2K
  */
META_RESULT __stdcall META_VC_SendData_r(int meta_handle, int vc_idx, char* buf, unsigned int len);
/**
  * \ingroup C2K
  */
META_RESULT __stdcall META_VC_RegisterReceiveHandler_r(int meta_handle, int vc_idx, MetaVCRxMsgHandler_CB  cb, void* para);

typedef void (*MetaCrfRxMsgHandler_CB)(const unsigned char* frameBuffer, unsigned int length, void* arg);
/**
  * \ingroup C2K
  */
META_RESULT __stdcall META_Crf_SendData_r(int meta_handle, char* buf, unsigned int len);
/**
  * \ingroup C2K
  */
META_RESULT __stdcall META_Crf_RegisterReceiveHandler_r(int meta_handle, MetaVCRxMsgHandler_CB  cb, void* para);

/* set dump trace file */
/**
  * \ingroup MDLogging
  * \sa non-reentrant version of META_SetModemLogDumpFilePath_rW
  */
bool __stdcall META_SetModemLogDumpFilePath_r(const int meta_handle, char* p_dump_file_path);

/**
  * \ingroup MDLogging
  * \details set the modem log dump file path
  * \param meta_handle meta handle
  * \param p_dump_file_path the path of the modem dump file path
  * \retval true false
  */
bool __stdcall META_SetModemLogDumpFilePath_rW(const int meta_handle, const wchar_t* p_dump_file_path);

/**
  * \ingroup MDLogging
  * \sa non-reentrant version of META_SetModemLogDumpFileName_rW
  */
bool __stdcall META_SetModemLogDumpFileName_r(const int meta_handle, char* p_dump_file_name);

/**
  * \ingroup MDLogging
  * \details set the modem log dump file name
  * \param meta_handle meta handle
  * \param p_dump_file_name the name of the modem dump file name
  * \retval true false
  */
bool __stdcall META_SetModemLogDumpFileName_rW(const int meta_handle, const wchar_t* p_dump_file_name);

typedef void (__cdecl *LogObserver)(unsigned int level, const char* message);
/**
   * \ingroup General
  * \details register a kernel dll log observer by meta handle
  * \param meta_handle specify the meta handle, -1 refers to the system default logger
  * \param levelBitmap set observeration log levels, you can OR bitwise this parameter to monitor multiple levels(Verbos = 1, Info = 1 << 1, Debug = 1 << 2, Report  = 1 << 3, Statistic = 1 << 4, Warning  = 1 << 5, Error  = 1 << 6, Fatal  = 1 << 7)
  * \param observer the observation callback function
  * \return return the registeration id, value -1 means registeration failed
  */
int __stdcall META_RegisterLogObserver_r(const int meta_handle, unsigned int levelBitmap, LogObserver observer);

/**
  * \ingroup General
  * \details unregister a kernel dll log observer 
  * \param meta_handle specify the meta handle, -1 refer to the system default logger
  * \param observerId the targeted unregisteration observer
  * \return true false
  */
bool __stdcall META_UnRegisterLogObserver_r(const int meta_handle, int observerId);

/**
  * \ingroup General
  * \details set kernel dll logging level
  * \param meta_handle specify the meta handle, -1 refer to the system default logger
  * \param level logging level (Verbos = 1, Info = 1 << 1, Debug = 1 << 2, Report  = 1 << 3, Statistic = 1 << 4, Warning  = 1 << 5, Error  = 1 << 6, Fatal  = 1 << 7)
  * \return true false
  */
bool  __stdcall META_SetDebugLevel_r(const int meta_handle, const int level);

void __stdcall META_SetAPITimoutValue(unsigned long msMinTime, unsigned long msDebugTime);
typedef struct
{
    int req_id;
    int cnf_id;
    unsigned int cmdType;
    char* reqLocal;
    unsigned int reqLocalLength;
    char* reqPeer;
    unsigned int reqPeerLength;
} META_Engineering_Request_Struct_t;
typedef struct
{
    char* cnfLocal;
    unsigned int cnfLocalLength;
    char* cnfPeer;
    unsigned int cnfPeerLength;
} META_Engineering_Confirm_Struct_t;
/**
  * \ingroup NoDefYet
  */
META_RESULT __stdcall META_EngineeringFunction_r(const int metaHandle, const unsigned int msTimeout,
                                       const META_Engineering_Request_Struct_t* req,
                                       META_Engineering_Confirm_Struct_t* cnf);
typedef void (__stdcall* TYPE_EngineeringCallbackFunction_fp)(const int metaHandle, const unsigned short cnfId, const unsigned int cmdType, const short token, const char* cnfParamBuf, const int cnfParamBufLen, const char* cnfPduBuf, const int cnfPduBufLen, void* arg);
/**
  * \ingroup NoDefYet
  */
META_RESULT __stdcall META_EngineeringFunctionNonBlocking_r(const int metaHandle,
                                       const META_Engineering_Request_Struct_t* req,
                                       TYPE_EngineeringCallbackFunction_fp cb, void* arg, short* token);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_L4_SwitchMetaModeReady_r(const int meta_handle, unsigned int ms_waiting_time, unsigned int mode);

/* Proxy flow */
typedef struct
{
    int proxyClientType;
    META_Connect_Ex_Req req;
} META_ProxyConnect_Req;
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectCOMChannelWithMultiTargetThroughProxy_r(const int meta_handle, const META_ProxyConnect_Req* req);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithMultiModeTargetThroughProxy_r(const int meta_handle, const META_ProxyConnect_Req* req, const unsigned int requestLengthlength, int* p_bootstop, META_Connect_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithMultiModeXl1SimThroughProxy_r(const int meta_handle, const META_ProxyConnect_Req* proxy_req, const unsigned int requestLength, int* p_bootstop, META_Connect_Report*  p_report);
/**
  * \ingroup InitConn
  */
META_RESULT  __stdcall META_ConnectWithMultiModeTargetXl1Sim_r(const int meta_handle, const META_Connect_Ex_Req* req, const unsigned int requestLength, int* p_bootstop, META_Connect_Report* p_report);

/**
* SP META API
*/
//-----------------------------------------------------//
//  UTILITY--ENABLE WATCHDOG                           //
//-----------------------------------------------------//
#define GPIO_DEV_LED_MAINLCD 0
//#define GPIO_DEV_LED_SUBLCD 1

typedef struct  {
    unsigned char            lcd_light_level;
}LCDLevel_REQ;

typedef struct  {
    int            status;
}LCDLevel_CNF;

typedef struct  {
    int                onoff;
    char                    DIV;
    char                    DUTY;
}KeypadBK_REQ;

typedef struct  {
    int            status;
}KeypadBK_CNF;

typedef struct{
    unsigned int LedNum;
    int  OFFON;
}NLED_REQ;

typedef struct{
    int ret;
}NLED_CNF;

typedef struct{
   int     Notused;
   unsigned char BackupTime[64];
}SetCleanBootFlag_REQ;

typedef struct{
   int     drv_status;
}SetCleanBootFlag_CNF;



typedef struct  {
    unsigned short        interval;
}WatchDog_REQ;

typedef struct  {
    unsigned short        rtc_sec;    
    unsigned short        rtc_min;    
    unsigned short        rtc_hour;   
    unsigned short        rtc_day;    
    unsigned short        rtc_mon;    
    unsigned short        rtc_wday;  
    unsigned short        rtc_year;  
    unsigned short        status;
}WatchDog_CNF;


//META_RESULT  __stdcall META_EnableWatchDogTimer(unsigned int ms_timeout, FtWatchDog *req);
//META_RESULT  __stdcall META_EnableWatchDogTimer_r(const int meta_handle, unsigned int ms_timeout, FtWatchDog *req);


META_RESULT  __stdcall SP_META_SetLEDLightLevelforMT6573(unsigned int ms_timeout, NLED_REQ *req);
META_RESULT  __stdcall SP_META_SetLEDLightLevelforMT6573_r(const int meta_handle, unsigned int ms_timeout, NLED_REQ *req);
META_RESULT  __stdcall SP_META_SetVibratorOnOff(unsigned int ms_timeout, NLED_REQ *req);
META_RESULT  __stdcall SP_META_SetVibratorOnOff_r(const int meta_handle, unsigned int ms_timeout, NLED_REQ *req);
META_RESULT  __stdcall SP_META_SetSignalIndicatorOnOff(unsigned int ms_timeout, NLED_REQ *req);
META_RESULT  __stdcall SP_META_SetSignalIndicatorOnOff_r(const int meta_handle, unsigned int ms_timeout, NLED_REQ *req);
META_RESULT  __stdcall SP_META_QueryLocalTime(unsigned int  ms_timeout, WatchDog_CNF  *cnf);
META_RESULT  __stdcall SP_META_QueryLocalTime_r(const int meta_handle, unsigned int  ms_timeout, WatchDog_CNF  *cnf);
META_RESULT  __stdcall SP_META_SetMainSubLCDLightLevel(unsigned int ms_timeout, LCDLevel_REQ *req);
META_RESULT  __stdcall SP_META_SetMainSubLCDLightLevel_r(const int meta_handle, unsigned int ms_timeout, LCDLevel_REQ *req);
// timer-related APIs
META_RESULT  __stdcall SP_META_StartTimer(void);
META_RESULT  __stdcall SP_META_StartTimer_r(const int meta_handle);
META_RESULT  __stdcall SP_META_StopTimer(void);
META_RESULT  __stdcall SP_META_StopTimer_r(const int meta_handle);
META_RESULT  __stdcall SP_META_GetProcessTime(unsigned int  *pProcessTime, unsigned short *pNumAPIs);
META_RESULT  __stdcall SP_META_GetProcessTime_r(const int meta_handle, unsigned int *pProcessTime, unsigned short *pNumAPIs);
const char * __stdcall SP_META_GetErrorString(META_RESULT  ErrCode);
const char * __stdcall SP_META_BaudrateEnumToName(META_COMM_BAUDRATE  baudrate);
// Initialization 
META_RESULT  __stdcall SP_META_GetAvailableHandle(int *p_meta_handle);
META_RESULT  __stdcall SP_META_Init(const META_Error_CallBack  cb);
META_RESULT  __stdcall SP_META_Init_r(const int meta_handle, const META_Error_CallBack  cb);
META_RESULT  __stdcall SP_META_SetSysTraceCallback(const META_SysTrace_CallBack  sys_cb);
META_RESULT  __stdcall SP_META_SetSysTraceCallback_r(const int meta_handle, const META_SysTrace_CallBack  sys_cb);
void  __stdcall SP_META_Deinit(void);
void  __stdcall SP_META_Deinit_r(int *p_meta_handle);


//-----------------------------------------------------//
//  Switch TST message format                          //
//-----------------------------------------------------//

META_RESULT  __stdcall SP_META_SetTstMsgFormat(META_TST_MSG_FORMAT  msg_fmt);
META_RESULT  __stdcall SP_META_SetTstMsgFormat_r(const int meta_handle, META_TST_MSG_FORMAT  msg_fmt);

// connect with target 
META_RESULT  __stdcall SP_META_ConnectWithTarget(const META_Connect_Req  *req, int *p_bootstop, META_Connect_Report  *p_report);
META_RESULT  __stdcall SP_META_ConnectWithTarget_r(const int meta_handle, const META_Connect_Req  *req, int *p_bootstop, META_Connect_Report  *p_report);
// disconnect and shutdown target
META_RESULT  __stdcall SP_META_DisconnectWithTarget(void);
META_RESULT  __stdcall SP_META_DisconnectWithTarget_r(const int meta_handle);

// connect with target when target already in meta mode 
META_RESULT  __stdcall SP_META_ConnectInMetaMode(const WM_META_ConnectInMETA_Req  *req, int *p_bootstop, WM_META_ConnectInMETA_Report  *p_report);
META_RESULT  __stdcall SP_META_ConnectInMetaMode_r(const int meta_handle, const WM_META_ConnectInMETA_Req  *req, int *p_bootstop, WM_META_ConnectInMETA_Report  *p_report);

// disconnect without shutdown target
META_RESULT  __stdcall SP_META_DisconnectInMetaMode(void);
META_RESULT  __stdcall SP_META_DisconnectInMetaMode_r(const int meta_handle);

META_RESULT  __stdcall SP_META_DisconnectATMMeta(int flag);
META_RESULT  __stdcall SP_META_DisconnectATMMeta_r(const int meta_handle, int flag);
// USB-related connect
META_RESULT  __stdcall SP_META_ConnectInMetaModeByUSB(const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);
META_RESULT  __stdcall SP_META_ConnectInMetaModeByUSB_r(const int meta_handle, const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);

META_RESULT  __stdcall SP_META_ConnectWithTargetByUSB(const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);
META_RESULT  __stdcall SP_META_ConnectWithTargetByUSB_r(const int meta_handle, const META_ConnectByUSB_Req  *req, int *p_bootstop, META_ConnectByUSB_Report  *p_report);
META_RESULT  __stdcall SP_META_GetDynamicUSBComPort(unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop);
META_RESULT  __stdcall SP_META_GetDynamicUSBComPort_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop);

// Get target S/W, H/W and Melody version
META_RESULT  __stdcall SP_META_GetTargetVerInfo(const META_GET_VERSION_INFO_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_GetTargetVerInfo_r(const int meta_handle, const META_GET_VERSION_INFO_CNF  cb, short *token, void *usrData);

// Get target S/W, H/W, melody and build version
META_RESULT  __stdcall SP_META_GetTargetVerInfoV2(VerInfo_V2_Cnf  *cnf_v2, short *token, void *usrData);
META_RESULT  __stdcall SP_META_GetTargetVerInfoV2_r(const int meta_handle, VerInfo_V2_Cnf  *cnf_v2, short *token, void *usrData);

// Get Chip Info
META_RESULT  __stdcall SP_META_GetTargetChipInfo(const META_GET_CHIP_INFO_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_GetTargetChipInfo_r(const int meta_handle, const META_GET_CHIP_INFO_CNF  cb, short *token, void *usrData);

// Get build properity
typedef struct
{
    unsigned char tag[64];
    
} BUILD_PROP_REQ_S;

typedef struct
{
    unsigned char content[128];
    
} BUILD_PROP_CNF_S;

META_RESULT  __stdcall SP_META_GetTargetBuildProp(BUILD_PROP_REQ_S * pReq, BUILD_PROP_CNF_S * pCnf);
META_RESULT  __stdcall SP_META_GetTargetBuildProp_r(const int meta_handle, BUILD_PROP_REQ_S * pReq, BUILD_PROP_CNF_S * pCnf);


// Shutdown target 
META_RESULT  __stdcall SP_META_ShutDownTarget(void);
META_RESULT  __stdcall SP_META_ShutDownTarget_r(const int meta_handle);
META_RESULT  __stdcall SP_META_ShutDownTarget_internal_r(const int meta_handle , unsigned int mode);

// Close Com Port
META_RESULT  __stdcall SP_META_CloseComPort(void);
META_RESULT  __stdcall SP_META_CloseComPort_r(const int meta_handle);

// Close Com Port and reboot
META_RESULT  __stdcall SP_META_CloseComPortReboot(void);
META_RESULT  __stdcall SP_META_CloseComPortReboot_r(const int meta_handle);

META_RESULT  __stdcall SP_META_RebootTarget(unsigned int delay);
META_RESULT  __stdcall SP_META_RebootTarget_r(const int meta_handle,unsigned int delay);

// ***** Expired Functions -- BEGIN ***** //
// these functions are expired, we encourage you to use META_ConnectWithTarget and META_DisconnectWithTarget 
META_RESULT  __stdcall SP_META_COMM_Set_Baudrate(const META_COMM_BAUDRATE  baudrate);
META_RESULT  __stdcall SP_META_COMM_Set_Baudrate_r(const int meta_handle, const META_COMM_BAUDRATE  baudrate);
META_RESULT  __stdcall SP_META_COMM_Start(const int comm_port, const META_FLOWCTRL  flowctrl);
META_RESULT  __stdcall SP_META_COMM_Start_r(const int meta_handle, const int comm_port, const META_FLOWCTRL  flowctrl);
META_RESULT  __stdcall SP_META_COMM_Stop(void);
META_RESULT  __stdcall SP_META_COMM_Stop_r(const int meta_handle);
META_RESULT  __stdcall SP_META_WaitForTargetReady(unsigned int ms_waiting_time, unsigned int request_count);
META_RESULT  __stdcall SP_META_WaitForTargetReady_r(const int meta_handle, unsigned int ms_waiting_time, unsigned int request_count);
META_RESULT  __stdcall SP_META_GetTargetRequiredMetaVer(unsigned int *p_meta_ver_required_by_target);
META_RESULT  __stdcall SP_META_GetTargetRequiredMetaVer_r(const int meta_handle, unsigned int *p_meta_ver_required_by_target);


META_RESULT  __stdcall SP_META_SetVersionInfo(VerInfo_Cnf *vinfo);

META_RESULT  __stdcall SP_META_BackupEFuseToFile( unsigned int ms_timeout, char * path);
META_RESULT  __stdcall SP_META_BackupEFuseToFile_r(const int meta_handle, unsigned int ms_timeout,char * path);
    
int __stdcall SP_META_ComPortEnumerate(unsigned short *p_com_port_array, unsigned short *p_com_port_count);



// WiFi 
typedef struct {
    unsigned char    mac_addr[6];
} WiFi_MacAddress_S;

typedef struct {
    unsigned char    CCKTxPWR[14]; 
    unsigned char    OFDMTxPWR[14]; 
} WiFi_TxPower_2400M_S;

typedef struct {
    unsigned char    TxPWR[34]; 
} WiFi_TxPower_5000M_S;

typedef struct {
    unsigned char    i_ch_offset;
    unsigned char    q_ch_offset;
} WiFi_DAC_DC_Offset_S;

typedef struct {
    unsigned char txAlcCCK[14];
    unsigned char txOutputPowerDBCCK[14];
    unsigned char txAlcOFDM [8][14];
    unsigned char txOutputPowerDBOFDM[8][14];
} WiFi_ALC_2400M_S;

typedef struct
{
    unsigned char alcSlop1Divider;
    unsigned char alcSlop1Dividend;
    unsigned char alcSlop2Divider;
    unsigned char alcSlop2Dividend;
} WiFi_TxALC_2400M_S;
typedef struct
{
   unsigned char BluetoothAddress[6];
   unsigned char MinEncryptionSize[1];
   unsigned char MaxEncryptionSize[1];
   unsigned char HCITransportLayerParameters[3];
   unsigned char FixedPIN[16];
   unsigned char FixedPINLength[1];
   unsigned char SleepEnableMask[1];
   unsigned char LowPowerClockParameter[8];
   unsigned char PowerControlConfiguration[13];
   unsigned char SleepControlParameters[12];
   unsigned char DebugControl[4];
   unsigned char LCandRMOverrideEnable[4];
   unsigned char RadioRegisterOverride[6];
   unsigned char CodecConfiguration[8];
   unsigned char CVSDGainVolumeSettings[6];
   unsigned char VoiceSettings[2];
   unsigned char UserBaudRate[3];

   unsigned char LowPowerDriftRate[1];
   unsigned char MaxTxPowerLevel[1];
   unsigned char AdaptiveFrequencyHoppingParameters[29];
   unsigned char BufferSize[4];
   unsigned char GpioMapping[16];
   unsigned char GpioPolarity[4];
}  nvram_ef_btradio_rfmd3500_struct;

typedef struct
{
    unsigned char BDAddr[6];
    unsigned char ClassOfDevice[3];
    unsigned char LinkKeyType[1];
    unsigned char UnitKey[16];
    unsigned char Encryption[3];
    unsigned char PinCodeType[1];
    unsigned char Voice[2];
    unsigned char Codec[1];
    unsigned char Radio[30];
    unsigned char Sleep[6];
    unsigned char MainOscillatorInfo[5];
    unsigned char LPOInfo[4];
    unsigned char AFH[9];
    unsigned char PTA[49];
    unsigned char WDT[2];
    unsigned char Debug[1];
    unsigned char UART[2];
}  nvram_ef_btradio_mt6601_struct;


typedef struct
{
    unsigned char addr[6];
    unsigned char CapId[1];
    unsigned char Codec[1];
    
} NVRAM_BTRADIO_MT6611_S;

//delete old struct define
/*
typedef struct
{
    unsigned char addr[6];
    unsigned char Voice[2];
    unsigned char Codec[4];
    unsigned char Radio[6];
    unsigned char Sleep[7];
    unsigned char BtFTR[2];
    unsigned char TxPWOffset[3];
    
} NVRAM_BTRADIO_MT6620_S;
*/

typedef struct
{
    unsigned char addr[6];
    unsigned char Voice[2];
    unsigned char Codec[4];
    unsigned char Radio[6];
    unsigned char Sleep[7];
    unsigned char BtFTR[2];
    unsigned char TxPWOffset[3];
    unsigned char CoexAdjust[6];      // BT/WIFI coexistence performance adjustment
    unsigned char Reserved1[2];       // Reserved
    unsigned char Reserved2[2];       // Reserved
    unsigned char Reserved3[4];       // Reserved
    unsigned char Reserved4[4];       // Reserved
    unsigned char Reserved5[8];       // Reserved
    unsigned char Reserved6[8];       // Reserved
    
} NVRAM_BTRADIO_MT6620_S;

typedef struct
{
    unsigned char addr[6];
    unsigned char CapId[1];
    unsigned char LinkKeyType[1];
    unsigned char UintKey[16];
    unsigned char Encryption[3];
    unsigned char PinCodeType[1];
    unsigned char Voice[2];
    unsigned char Codec[4];
    unsigned char Radio[6];
    unsigned char Sleep[7];
    unsigned char BtFTR[2];
    unsigned char TxPWOffset[3];
    unsigned char ECLK_SEL[1];
    unsigned char Reserved1[1];
    unsigned char Reserved2[2];
    unsigned char Reserved3[4];
    unsigned char Reserved4[4];
    unsigned char Reserved5[16];
    unsigned char Reserved6[16];
    
}NVRAM_BTRADIO_MT6626_S;

//-----------------------------------------------------//
//  NVRAM: callback function definition                //
//-----------------------------------------------------//
typedef void (__stdcall *SP_META_NVRAM_Reset_CNF)(const AP_FT_NVRAM_RESET_CNF *cnf, const short token, void *usrData);
typedef void (__stdcall *SP_META_NVRAM_Read_CNF)(const AP_FT_NVRAM_READ_CNF *cnf, const short token, void *usrData);
typedef void (__stdcall *SP_META_NVRAM_Write_CNF)(const AP_FT_NVRAM_WRITE_CNF *cnf, const short token, void *usrData);
typedef void (__stdcall *SP_CB_META_NVRAM_GET_DISK_INFO_CNF)(const NVRAM_GetDiskInfo_Cnf *cnf, const short token, void *usrData);



//-----------------------------------------------------//
//  NVRAM: exported function definition                //
//-----------------------------------------------------//
META_RESULT  __stdcall SP_META_NVRAM_Init(const char *PathName, unsigned long *p_nvram_CatcherTranAddr);
META_RESULT  __stdcall SP_META_NVRAM_Init_r(const int meta_handle,const char *PathName, unsigned long *p_nvram_CatcherTranAddr);
META_RESULT  __stdcall SP_META_NVRAM_Init_rW(const int meta_handle,const wchar_t *PathName, unsigned long *p_nvram_CatcherTranAddr);
META_RESULT  __stdcall SP_META_NVRAM_Reset(const AP_FT_NVRAM_RESET_REQ *req, const SP_META_NVRAM_Reset_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_Reset_r(const int meta_handle, const AP_FT_NVRAM_RESET_REQ *req, const SP_META_NVRAM_Reset_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_Read(const AP_FT_NVRAM_READ_REQ *req, AP_FT_NVRAM_READ_CNF *cnf, const SP_META_NVRAM_Read_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_Read_r(const int meta_handle, const AP_FT_NVRAM_READ_REQ *req, AP_FT_NVRAM_READ_CNF *cnf, const SP_META_NVRAM_Read_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_Write(const AP_FT_NVRAM_WRITE_REQ *req, const SP_META_NVRAM_Write_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_Write_r(const int meta_handle, const AP_FT_NVRAM_WRITE_REQ *req, const SP_META_NVRAM_Write_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_GetAllLIDNameLength(int *len);
META_RESULT  __stdcall SP_META_NVRAM_GetAllLIDName(char *buf, const int buf_len, int *NofLID);
META_RESULT  __stdcall SP_META_NVRAM_GetLIDVersion(const char *LID,unsigned short *ver);
META_RESULT  __stdcall SP_META_NVRAM_GetRecStructNameLength(const char *LID, int *len);
META_RESULT  __stdcall SP_META_NVRAM_GetRecStructName(const char *LID, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_GetAllRecFieldNameLength(const char *LID, int *len);
META_RESULT  __stdcall SP_META_NVRAM_GetAllRecFieldName(const char *LID, char *buf, const int buf_len, int *NofField);
META_RESULT  __stdcall SP_META_NVRAM_CheckFieldNameExist(const char *LID, const char *Field, bool *result);
META_RESULT  __stdcall SP_META_NVRAM_GetRecNum(const char *LID, int *num);
META_RESULT  __stdcall SP_META_NVRAM_GetRecLen(const char *LID, int *len);
META_RESULT  __stdcall SP_META_NVRAM_SetRecFieldValue(const char *LID, const char *field, char *buf, const int buf_len, void *value, const int value_len);
META_RESULT  __stdcall SP_META_NVRAM_GetRecFieldValue(const char *LID, const char *field, const char *buf, const int buf_len, void *value, const int value_len);
META_RESULT  __stdcall SP_META_NVRAM_SetRecFieldBitValue(const char *LID, const char *field, const char *bitname, char *buf, const int buf_len, const int bitvalue);
META_RESULT  __stdcall SP_META_NVRAM_GetRecFieldBitValue(const char *LID, const char *field, const char *bitname, const char *buf, const int buf_len, int *bitvalue);
META_RESULT  __stdcall SP_META_NVRAM_QueryIsLIDExist(const char *LID);
META_RESULT  __stdcall SP_META_NVRAM_ResetToFactoryDefault(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_NVRAM_ResetToFactoryDefault_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_NVRAM_LockDown(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_NVRAM_LockDown_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_NVRAM_OTP_LockDown(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_NVRAM_OTP_LockDown_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_NVRAM_CheckAPDbVersion(void);
META_RESULT  __stdcall SP_META_NVRAM_CheckAPDbVersion_r(const int meta_handle);

// S/W Change
META_RESULT  __stdcall SP_META_NVRAM_SWC_RetrieveChangeList(void);
META_RESULT  __stdcall SP_META_NVRAM_SWC_RetrieveChangeList_r(const int meta_handle);
META_RESULT  __stdcall SP_META_NVRAM_SWC_UpdateChangeList(void);
META_RESULT  __stdcall SP_META_NVRAM_SWC_UpdateChangeList_r(const int meta_handle);
META_RESULT  __stdcall SP_META_NVRAM_SWC_GetAllChangedLIDCount(int *NofLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_GetAllChangedLIDCount_r(const int meta_handle, int *NofLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_GetAllChangedLIDName(LID_Info *p_ArrayOfLID, const int NofLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_GetAllChangedLIDName_r(const int meta_handle, LID_Info *p_ArrayOfLID, const int NofLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_QueryIfLIDChanged(const char *LID, LID_STATUS  *result);
META_RESULT  __stdcall SP_META_NVRAM_SWC_QueryIfLIDChanged_r(const int meta_handle, const char *LID, LID_STATUS  *result);
META_RESULT  __stdcall SP_META_NVRAM_SWC_ImportData(LID_Info *p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
META_RESULT  __stdcall SP_META_NVRAM_SWC_ImportData_r(const int meta_handle, LID_Info *p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
META_RESULT  __stdcall SP_META_NVRAM_SWC_Database_Compare(const char *PathName, int *p_NumOfNewAddLID, int *p_NumOfModifiedLID, int *p_NumOfDeletedLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Database_Compare_r(const int meta_handle, const char *PathName, int *p_NumOfNewAddLID, int *p_NumOfModifiedLID, int *p_NumOfDeletedLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Database_Compare_rW(const int meta_handle, const wchar_t *PathName, int *p_NumOfNewAddLID, int *p_NumOfModifiedLID, int *p_NumOfDeletedLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Get_Database_Compare_Result(LID_Info *p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info *p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info *p_ArrayOfDeletedLID, const int NumOfDeletedLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Get_Database_Compare_Result_r(const int meta_handle, LID_Info *p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info *p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info *p_ArrayOfDeletedLID, const int NumOfDeletedLID);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Check_FAT_FreeSpace(const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Check_FAT_FreeSpace_r(const int meta_handle, const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Enable_ForceUpgrade(void);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Enable_ForceUpgrade_r(const int meta_handle);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Disable_ForceUpgrade(void);
META_RESULT  __stdcall SP_META_NVRAM_SWC_Disable_ForceUpgrade_r(const int meta_handle);


// AGC path loss 
META_RESULT  __stdcall SP_META_NVRAM_agcPathLoss_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_agcPathLoss(const l1cal_agcPathLoss_T *loss, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_agcPathLoss(l1cal_agcPathLoss_T *loss, const char *buf, const int buf_len);

META_RESULT  __stdcall SP_META_NVRAM_rampTable_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_rampTable(const l1cal_rampTable_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_rampTable(l1cal_rampTable_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_rampTable_Len_Ex(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_rampTable_Ex(const l1cal_rampTable_T_Ex *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_rampTable_Ex(l1cal_rampTable_T_Ex *tbl, const char *buf, const int buf_len);

// rampTable
META_RESULT  __stdcall SP_META_NVRAM_rampTable_Len_Ex2(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_rampTable_Ex2(const l1cal_rampTable_T_Ex2 *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_rampTable_Ex2(l1cal_rampTable_T_Ex2 *tbl, const char *buf, const int buf_len);

// interRampData
META_RESULT  __stdcall SP_META_NVRAM_interRampData_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_interRampData(const l1cal_interRampData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_interRampData(l1cal_interRampData_T *tbl, const char *buf, const int buf_len);
// crystalAfcData
META_RESULT  __stdcall SP_META_NVRAM_crystalAfcData_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_crystalAfcData(const l1cal_crystalAfcData_T *xo_afc, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_crystalAfcData(l1cal_crystalAfcData_T *xo_afc, const char *buf, const int buf_len);
// IMEISV
META_RESULT  __stdcall SP_META_NVRAM_Calculate_IMEI_CD(const char *imei, unsigned short *p_cd);
META_RESULT  __stdcall SP_META_NVRAM_IMEISV_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_IMEISV(const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_IMEISV_NoCheck(const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_IMEISV_ex(const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len,bool DoCheckSum);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_IMEISV(IMEISV_struct_T  *p_imeisv, const char *buf, const int buf_len);

// RF Module Configuration 
META_RESULT  __stdcall SP_META_NVRAM_RFSpecialCoef_Len(int *len);
// Skyworks 
META_RESULT  __stdcall SP_META_NVRAM_Compose_SKY74045_RFSpecialCoef(const RF_SKY74045_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_SKY74045_RFSpecialCoef(RF_SKY74045_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_SKY74117_RFSpecialCoef(const RF_SKY74117_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_SKY74117_RFSpecialCoef(RF_SKY74117_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
// MT6139B 
META_RESULT  __stdcall SP_META_NVRAM_Compose_MT6139B_RFSpecialCoef(const RF_MT6139B_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_MT6139B_RFSpecialCoef(RF_MT6139B_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
// MT6140
META_RESULT  __stdcall SP_META_NVRAM_Compose_MT6140tx_RFSpecialCoef(const mt6140tx *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_MT6140tx_RFSpecialCoef(mt6140tx *rf_mod_coef, const char *buf, const int buf_len);

META_RESULT  __stdcall SP_META_NVRAM_Compose_MT6140tx_PaVbias(const mt6140tx *pavbias, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_MT6140tx_PaVbias(mt6140tx *pavbias, const char *buf, const int buf_len);

// Renesas Bright5P 
META_RESULT  __stdcall SP_META_NVRAM_Compose_BRIGHT5P_RFSpecialCoef(const RF_BRIGHT5P_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_BRIGHT5P_RFSpecialCoef(RF_BRIGHT5P_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
// EPSK interRampData 
META_RESULT  __stdcall SP_META_NVRAM_EPSK_interRampData_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_EPSK_interRampData(const l1cal_EPSK_interRampData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_EPSK_interRampData(l1cal_EPSK_interRampData_T *tbl, const char *buf, const int buf_len);




META_RESULT  __stdcall SP_META_NVRAM_3G_Compose_tempdacData(const ul1cal_tempdacData_T  *dac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Decompose_tempdacData(ul1cal_tempdacData_T  *dac, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Compose_pathlossData(const ul1cal_pathlossData_T  *pathloss, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Decompose_pathlossData(ul1cal_pathlossData_T  *pathloss, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Compose_txdacData(const ul1cal_txdacData_T  *txdac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Decompose_txdacData(ul1cal_txdacData_T  *txdac, const char *buf, const int buf_len);


//BT
typedef enum 
{
  BT_CHIP_ID_MT6611 = 0,
  BT_CHIP_ID_MT6612,
  BT_CHIP_ID_MT6616,
  BT_CHIP_ID_MT6620,
  BT_CHIP_ID_MT6622,
  BT_CHIP_ID_MT6626,
  BT_CHIP_ID_MT6628,
  BT_CHIP_ID_MT6572,
  BT_CHIP_ID_MT6582,
  BT_CHIP_ID_MT6592,
  BT_CHIP_ID_MT6630,
  BT_CHIP_ID_END
  
} BT_CHIP_ID_E;

META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_RFMD3500Radio(const nvram_ef_btradio_rfmd3500_struct  *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_RFMD3500Radio(nvram_ef_btradio_rfmd3500_struct  *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6601Radio(const nvram_ef_btradio_mt6601_struct  *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6601Radio(nvram_ef_btradio_mt6601_struct  *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6611Radio(const NVRAM_BTRADIO_MT6611_S *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6611Radio(NVRAM_BTRADIO_MT6611_S *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6620Radio(const NVRAM_BTRADIO_MT6620_S *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6620Radio(NVRAM_BTRADIO_MT6620_S *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6626Radio(const NVRAM_BTRADIO_MT6626_S *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6626Radio(NVRAM_BTRADIO_MT6626_S *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_QueryChipByStructSize(BT_CHIP_ID_E * chipID);

// sBBTxParameters
META_RESULT  __stdcall SP_META_NVRAM_BBTXParameters_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_BBTXParameters(const BBTXParameters_T *bbtx, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_BBTXParameters(BBTXParameters_T *bbtx, const char *buf, const int buf_len);


//--------------------------------------------------------------------------//
//  Audio Testing                                                           //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  Audio Testing: data structure definition           //
//-----------------------------------------------------//

typedef    struct
{
    char    receiver_test;        // receiver_test true mean enable
}ft_l4aud_receiver_test;

typedef    struct
{
    char    left_channel;        // true mean enable
    char    right_channel;        // true mean enable
}ft_l4aud_loudspk;





META_RESULT  __stdcall SP_META_Audio_Receiver_Test(unsigned int ms_timeout, ft_l4aud_receiver_test *req);
META_RESULT  __stdcall SP_META_Audio_Receiver_Test_r(const int meta_handle, unsigned int ms_timeout, ft_l4aud_receiver_test *req);
META_RESULT  __stdcall SP_META_Audio_LoudSpk_Test(unsigned int ms_timeout, ft_l4aud_loudspk *req);
META_RESULT  __stdcall SP_META_Audio_LoudSpk_Test_r(const int meta_handle, unsigned int ms_timeout, ft_l4aud_loudspk *req);


//--------------------------------------------------------------------------//
//  BaseBand Testing                                                        //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  BaseBand Testing: data structure definition        //
//-----------------------------------------------------//

typedef struct{
    unsigned int        addr;
    unsigned char        bytenum;
}CPU_REG_READ_REQ;

typedef struct{
    unsigned int        value;
    unsigned char        status;
}CPU_REG_READ_CNF;

typedef struct{
    unsigned int        addr;
    unsigned int        value;
    unsigned char        bytenum;
}CPU_REG_WRITE_REQ;

typedef struct{
    unsigned char        status;
}CPU_REG_WRITE_CNF;


typedef struct{
    unsigned char     registernumber;    /// the valid value: 0--96
}WM_CMD_ReadPMICRegister_REQ_T;

typedef struct{
    unsigned char         value;
    int        status;
}WM_CMD_ReadRegister_CNF_T;

typedef struct{
    unsigned char registernumber;   //the valid value: 20~~ 96
    unsigned char registervalue;
}WM_CMD_WritePMICRegister_REQ_T;

typedef struct{
    int value;   //not used
    int        status;
}WM_CMD_WriteRegister_CNF_T;


//add by dian.wang for MT6573 PMIC
typedef struct{
    unsigned long     registernumber;    /// the valid value: 0--96
}WM_CMD_ReadPMICRegister_DWORD_REQ_T;

typedef struct{
    unsigned int  value;
    unsigned char status;
}WM_CMD_ReadRegister_DWORD_CNF_T;

typedef struct{
    unsigned long registernumber;   //the valid value: 20~~ 96
    unsigned short registervalue;
}WM_CMD_WritePMICRegister_DWORD_REQ_T;

typedef struct{
    unsigned int    value;   //not used
    unsigned char    status;
}WM_CMD_WriteRegister_DWORD_CNF_T;

////////////////////////////////////////


typedef struct {
    int num;
    int delay;
    int tolerance;
} GS_CMD_CALI;

typedef struct {
    int x;
    int y;
    int z; 
} GS_ACK_CALI;

typedef struct {
    int dummy;
} GS_CMD_READ_RAW;

typedef struct {
    int x;
    int y;
    int z;
} GS_ACK_READ_RAW;

typedef struct {
    int x;
    int y;
    int z;    
} GS_CMD_WRITE_NVRAM;

typedef struct {
    int   dummy;
} GS_ACK_WRITE_NVRAM;

typedef struct {
    int   dummy;
} GS_CMD_READ_NVRAM;

typedef struct {
    int x;
    int y;
    int z;    
} GS_ACK_READ_NVRAM;



META_RESULT  __stdcall SP_META_GS_Perform_Calibration(unsigned int ms_timeout, const  GS_CMD_CALI *req, GS_ACK_CALI *cnf);
META_RESULT  __stdcall SP_META_GS_Perform_Calibration_r(const int meta_handle, unsigned int ms_timeout, const  GS_CMD_CALI *req, GS_ACK_CALI *cnf);

META_RESULT  __stdcall SP_META_GS_Write_NVRAM(unsigned int ms_timeout, const  GS_CMD_WRITE_NVRAM *req, GS_ACK_WRITE_NVRAM *cnf);
META_RESULT  __stdcall SP_META_GS_Write_NVRAM_r(const int meta_handle, unsigned int ms_timeout, const  GS_CMD_WRITE_NVRAM *req, GS_ACK_WRITE_NVRAM *cnf);

META_RESULT  __stdcall SP_META_GS_Read_Raw(unsigned int ms_timeout, const  GS_CMD_READ_RAW *req, GS_ACK_READ_RAW *cnf);
META_RESULT  __stdcall SP_META_GS_Read_Raw_r(const int meta_handle, unsigned int ms_timeout, const  GS_CMD_READ_RAW *req, GS_ACK_READ_RAW *cnf);

typedef struct {
    int num;
    int delay;
    int tolerance;
} GYRO_CMD_CALI;

typedef struct {
    int x;
    int y;
    int z; 
} GYRO_ACK_CALI;

typedef struct {
    int dummy;
} GYRO_CMD_READ_RAW;

typedef struct {
    int x;
    int y;
    int z;
} GYRO_ACK_READ_RAW;

typedef struct {
    int x;
    int y;
    int z;    
} GYRO_CMD_WRITE_NVRAM;

typedef struct {
    int   dummy;
} GYRO_ACK_WRITE_NVRAM;

typedef struct {
    int   dummy;
} GYRO_CMD_READ_NVRAM;

typedef struct {
    int x;
    int y;
    int z;    
} GYRO_ACK_READ_NVRAM;


META_RESULT  __stdcall SP_META_GYRO_Perform_Calibration(unsigned int ms_timeout, const  GYRO_CMD_CALI*req, GYRO_ACK_CALI *cnf);
META_RESULT  __stdcall SP_META_GYRO_Perform_Calibration_r(const int meta_handle, unsigned int ms_timeout, const  GYRO_CMD_CALI*req, GYRO_ACK_CALI *cnf);


META_RESULT  __stdcall SP_META_GYRO_Write_NVRAM(unsigned int ms_timeout, const  GYRO_CMD_WRITE_NVRAM*req, GYRO_ACK_WRITE_NVRAM *cnf);
META_RESULT  __stdcall SP_META_GYRO_Write_NVRAM_r(const int meta_handle, unsigned int ms_timeout, const  GYRO_CMD_WRITE_NVRAM*req, GYRO_ACK_WRITE_NVRAM *cnf);


META_RESULT  __stdcall SP_META_GYRO_Read_Raw(unsigned int ms_timeout, const  GYRO_CMD_READ_RAW *req, GYRO_ACK_READ_RAW *cnf);
META_RESULT  __stdcall SP_META_GYRO_Read_Raw_r(const int meta_handle, unsigned int ms_timeout, const  GYRO_CMD_READ_RAW *req, GYRO_ACK_READ_RAW *cnf);



//-----------------------------------------------------//
//  BaseBand Testing: callback function definition     //
//-----------------------------------------------------//
typedef void (__stdcall *SP_META_BB_READREG_CNF)(const CPU_REG_READ_CNF *result, const short token, void *usrData);
typedef void (__stdcall *SP_META_BB_WRITEREG_CNF)(const CPU_REG_WRITE_CNF *result, const short token, void *usrData);
typedef void (__stdcall *SP_META_BB_ADCGETMEADATA_CNF)(const ADCMeaData_Cnf *result, const short token, void *usrData);

//-----------------------------------------------------//
//  BaseBand Testing: exported function definition     //
//-----------------------------------------------------//

//META_RESULT  __stdcall SP_META_BB_RegRead(const CPU_REG_READ_REQ *req, const SP_META_BB_READREG_CNF cb, short *token, void *usrData);
//META_RESULT  __stdcall SP_META_BB_RegRead_r(const int meta_handle, const CPU_REG_READ_REQ *req, const SP_META_BB_READREG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_BB_RegWrite(const CPU_REG_WRITE_REQ *req, const SP_META_BB_READREG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_BB_RegWrite_r(const int meta_handle, const CPU_REG_WRITE_REQ *req, const SP_META_BB_WRITEREG_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_BB_ADCGetMeaSumData(const ADCMeaData_Req *req, const SP_META_BB_ADCGETMEADATA_CNF cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_BB_ADCGetMeaSumData_r(const int meta_handle, const ADCMeaData_Req *req, const SP_META_BB_ADCGETMEADATA_CNF cb, short *token, void *usrData);

//--------------------------------------------------------------------------//
//  WiFi Calibration                                                        //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  WiFi Calibration: data structure definition        //
//-----------------------------------------------------//

// WiFi Baseband Chip ID 
#define WIFI_BB_MT5911        0x00000001

// WiFi RF Chip ID 
#define WIFI_RF_AL2236        0x00000001
#define WIFI_RF_MAX2827        0x00000002

typedef enum {
    WIFI_TEST_RATE_1M = 0,     /* 1M          */
    WIFI_TEST_RATE_2M,         /* 2M          */
    WIFI_TEST_RATE_5_5M,       /* 5.5M        */
    WIFI_TEST_RATE_11M,        /* 11M         */
    WIFI_TEST_RATE_6M,         /* 6M          */
    WIFI_TEST_RATE_9M,         /* 9M          */
    WIFI_TEST_RATE_12M,        /* 12M         */
    WIFI_TEST_RATE_18M,        /* 18M         */
    WIFI_TEST_RATE_24M,        /* 24M         */
    WIFI_TEST_RATE_36M,        /* 36M         */
    WIFI_TEST_RATE_48M,        /* 48M         */
    WIFI_TEST_RATE_54M,        /* 54M         */
    WIFI_TEST_RATE_COUNT       /* Total count */
} WiFi_TestRate_E;

typedef enum {
     WNDRV_HOST_INTERFACE_SDIO = 0
    ,WNDRV_HOST_INTERFACE_HPI
    ,WNDRV_HOST_INTERFACE_SPI
    ,WNDRV_HOST_INTERFACE_CF_MEM
    ,WNDRV_HOST_INTERFACE_CF_IO  
} WiFi_HostInterface_E;

typedef enum {
    WIFI_TX_ALL_ZEROS,
    WIFI_TX_ALL_ONES,
    WIFI_TX_ALTERNATE_BITS,
    WIFI_TX_PSEUDO_RANDOM
} WiFi_TestPktTxPattern_E;

typedef enum {
    WIFI_POWER_MODE_NORMAL,
    WIFI_POWER_MODE_IDLE,
    WIFI_POWER_MODE_SLEEP
} WiFi_PowerManagementMode_E;

typedef enum {    
    WIFI_RF_RX_TEST_MODE = 1  /* For RF Test use */
} WiFi_TestPktRxMode_E;

typedef enum {
    WIFI_RX_ANT_DIVERSITY_AGC,  /* AGC based selection */
    WIFI_RX_ANT_DIVERSITY_MPDU, /* MPDU based selection */
    WIFI_RX_ANT_FIXED_0,        /* Always 0 */
    WIFI_RX_ANT_FIXED_1         /* Always 1 */
} WiFi_RxAntSel_E;

typedef struct {
    unsigned int    bb_chip_id;
    char            bb_chip_ver[32];
    unsigned int    rf_chip_id;
    char            rf_chip_ver[32];
    unsigned char    support_802_11b;
    unsigned char    support_802_11a;
    unsigned char    support_802_11g;
    bool            eeprom_exist;
    unsigned int    eeprom_size;
    WiFi_HostInterface_E    host_interface;
} WiFi_ChipCapability_S;

typedef struct {
    unsigned int        ch_freq; /* Frq, units are kHz */
    WiFi_TestRate_E        tx_rate;
    int                    dbm;
} WiFi_DBM2DAC_Set_S;

typedef struct {
    unsigned short        tx_gain_dac;
} WiFi_DBM2DAC_Query_S;

typedef struct {
    unsigned int        ch_freq;/* Frq, units are kHz */
    WiFi_TestRate_E        tx_rate;
    unsigned char        txAnt; /* 0 for Antenna 0; 1 for Antenna 1 */
    unsigned short        tx_gain_dac;
} WiFi_TestTx_S;

typedef struct {
    unsigned int            ch_freq;            /* Frq, units are kHz */
    WiFi_TestRate_E            tx_rate;
    unsigned short            tx_gain_dac;
    unsigned int            pktCount;
    unsigned int            pktInterval;        /* interval between each Tx Packet */
    unsigned int            pktLength;            /* 24~1500 */
    WiFi_TestPktTxPattern_E    pattern;            /* content of the Tx Packet */
    unsigned char            txAnt;                /* 0 for Antenna 0; 1 for Antenna 1 */
    unsigned char            is_short_preamble;    /* 0 for long preamble and 1 for short preamble */
    unsigned char            mac_header[ 24 ];    /* Frame Ctrl, Duration = 2bytes + 2bytes */
                                                /* Address 1 = 6 bytes */
                                                /* Address 2 = 6 bytes */
                                                /* Address 3 = 6 bytes */
                                                /* Sequence Ctrl = 2 bytes */
} WiFi_TestPktTx_S;

typedef struct {
    unsigned int            ch_freq;            /* Frq, units are kHz */
    WiFi_TestRate_E            tx_rate;
    unsigned short            tx_gain_dac;
    unsigned int            pktCount;
    unsigned int            pktInterval;        /* interval between each Tx Packet */
    unsigned int            pktLength;            /* 24~1500 */
    WiFi_TestPktTxPattern_E    pattern;            /* content of the Tx Packet */
    unsigned char            txAnt;                /* 0 for Antenna 0; 1 for Antenna 1 */
    unsigned int            txFlags;
    unsigned int            targetAlc;
    unsigned char            is_short_preamble;    /* 0 for long preamble and 1 for short preamble */
    unsigned char            mac_header[ 24 ];    /* Frame Ctrl, Duration = 2bytes + 2bytes */
                                                /* Address 1 = 6 bytes */
                                                /* Address 2 = 6 bytes */
                                                /* Address 3 = 6 bytes */
                                                /* Sequence Ctrl = 2 bytes */
} WiFi_TestPktTx_Ex_S;

typedef struct {    
    unsigned int        pkt_sent_count;  /* total num sent */
    unsigned int        pkt_sent_acked;  /* acked num */   
} WiFi_TxStatus_S;


typedef struct {    
    unsigned int        pkt_sent_count;  /* total num sent */
    unsigned int        pkt_sent_acked;  /* acked num */   
    unsigned short        avgAlc;
    unsigned char        cckGainControl;
    unsigned char        ofdmGainControl;
} WiFi_TxStatus_Ex_S;

typedef struct {
    unsigned int                ch_freq;  /* Frq, units are kHz */
    WiFi_TestPktRxMode_E        mode;
    WiFi_RxAntSel_E                rxAnt;
} WiFi_TestPktRx_S;

typedef struct {    
    unsigned int        int_rx_ok_num;     /* number of packets that Rx ok from interrupt */
    unsigned int        int_crc_err_num;   /* number of packets that CRC error from interrupt */
    unsigned int        pau_rx_pkt_count;  /* number of packets that Rx ok from PAU */
    unsigned int        pau_crc_err_count; /* number of packets that CRC error from PAU */
    unsigned int        pau_cca_count;     /* CCA rising edge count */
    unsigned int        pau_rx_fifo_full_count; /* number of lost packets due to FiFo full */
    unsigned int        int_long_preamble_num;
    unsigned int        int_short_preamble_num;
    unsigned int        int_rate_ok_num[ WIFI_TEST_RATE_COUNT ];
    unsigned int        int_rate_crc_err_num[ WIFI_TEST_RATE_COUNT ];
    int                    int_rssi_max;
    int                    int_rssi_min;
    int                    int_rssi_mean;
    int                    int_rssi_variance;
} WiFi_RxStatus_S;

typedef struct {    
    int  ED;
    int  OSD;
    int  SQ1;
    int  SFD;
    int  CRC16;
} WiFi_RxCounter_S;

typedef struct {    
    unsigned int    channel_num;
    unsigned char    channel_list[64];
} WiFi_ChannelList_S;

typedef struct {    
    unsigned char    country_code[2];
} WiFi_RegDomain_S;

typedef struct {
    unsigned int    index;        // 32bits alignment index, +4 
    unsigned int    mcr_data32;
} WiFi_MACReg32_S;

typedef struct {
    unsigned int    index;        // 16bits alignment index, +2 
    unsigned short    mcr_data16;
} WiFi_MACReg16_S;

typedef struct {
    unsigned int    index;        // 8bits alignment index, +1 
    unsigned char    bbcr_data8;
} WiFi_BBReg8_S;

typedef struct {
    unsigned int    index;        // 16bits alignment index, +2 
    unsigned short    eeprom_data16;
} WiFi_EEPROM_S;


// Wei Fang 2011-12-8
META_RESULT __stdcall SP_META_WiFi_switchAntenna_r(const int meta_handle, unsigned int ms_timeout,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_switchAntenna(unsigned int ms_timeout,unsigned int value);


//--------------------------------------------------------------------------//
//  BT Calibration                                                          //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  BT Calibration: data structure definition          //
//-----------------------------------------------------//

// BT Module ID 
#define BT_NOT_SUPPORT        0x00000000
#define BTMODULE_MT6601        0x00000011
#define BTMODULE_MT6611        0x00000012
#define BTMODULE_RFMD3500   0x00000021 
#define BTMODULE_RFMD4020    0x00000022

//#define BT_PACKET_LEN       339
#define BT_PACKET_LEN       1021  // because BT2.0 support at most 1021 bytes per packet
#define BT_BUFFER_LEN       1024
#define BT_DATA_LEN           1026
typedef struct {
    unsigned char    id;
} BT_ModuleID_S;

typedef struct {
    unsigned char   m_event;
    char             m_status;
    unsigned short  m_handle;
    unsigned char    m_len;
    unsigned char    m_parms[256];
} BT_HCI_EVENT;

typedef struct {
    unsigned short    m_opcode;
    unsigned char    m_len;
    unsigned char    m_cmd[256];
} BT_HCI_COMMAND;
typedef struct {
    unsigned short           m_con_hdl;
    unsigned short           m_len;          
    unsigned char            m_buffer[BT_BUFFER_LEN]; 
} BT_HCI_BUFFER;
typedef struct {
    unsigned short           m_len;
    unsigned char            m_data[BT_DATA_LEN];
} BT_HCI_PACKET;
typedef struct {
    unsigned short           m_con_hdl;
    unsigned short           m_len;          
    unsigned short           m_total_pks; 
} BT_HCI_TX_PURE_TEST;

typedef struct {
    unsigned int             m_used_time;
    unsigned short           m_len;     
} BT_HCI_TX_PURE_TEST_STAT;

typedef struct {
    unsigned int             m_used_time;
    unsigned short           m_len;     
} BT_HCI_RX_PURE_TEST_STAT;

typedef struct {
    unsigned int             m_u4UsedTime;
    unsigned short           m_u2PktSentNum; 
    
} BT_HCI_TX_PURE_TEST_STAT_V2;


//-----------------------------------------------------//
//  BT Calibration Functions                           //
//-----------------------------------------------------//
META_RESULT  __stdcall SP_META_BT_QueryModuleID(unsigned int  ms_timeout, BT_ModuleID_S  *cnf);
META_RESULT  __stdcall SP_META_BT_QueryModuleID_r(const int meta_handle, unsigned int  ms_timeout, BT_ModuleID_S  *cnf);

typedef void (__stdcall *META_BT_HCI_CNF)(const BT_HCI_EVENT *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_HCI_TXDATA_CNF)(const BT_HCI_PACKET *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_AUTO_HCI_CNF)(const BT_HCI_EVENT *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_HCI_RXDATA_CNF)(const BT_HCI_BUFFER *cnf, const short token, void *usrData);

typedef void (__stdcall *META_BT_HCI_TXTEST_CNF)(const BT_HCI_TX_PURE_TEST_STAT *cnf, const short token, void *usrData);
typedef void (__stdcall *META_BT_HCI_RXTEST_CNF)(const BT_HCI_RX_PURE_TEST_STAT *cnf, const short token, void *usrData);

typedef void (__stdcall *META_BT_HCI_TXTEST_V2_CNF)(const BT_HCI_TX_PURE_TEST_STAT_V2 *cnf, const short token, void *usrData);

typedef struct{
    META_BT_HCI_TXDATA_CNF      m_SendDataCallback;
    META_BT_HCI_RXDATA_CNF        m_RecvDataCallback;
    META_BT_AUTO_HCI_CNF        m_AutoCallback;
    META_BT_HCI_TXTEST_CNF        m_TxTestCallback;
    META_BT_HCI_RXTEST_CNF        m_RxTestCallback;
    META_BT_HCI_TXTEST_V2_CNF   m_TxTestCallback_V2;
} BT_OtherCallBack;

META_RESULT  __stdcall SP_META_BT_SendHCICommand(unsigned int  ms_timeout,BT_HCI_COMMAND *req, META_BT_HCI_CNF  cb, void  *cb_arg, unsigned char Cmpltcode);
META_RESULT  __stdcall SP_META_BT_SendHCICommand_r(const int meta_handle, unsigned int  ms_timeout,BT_HCI_COMMAND *req, META_BT_HCI_CNF  cb, void  *cb_arg, unsigned char Cmpltcode);
META_RESULT  __stdcall SP_META_BT_CancelHCICommand(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_CancelHCICommand_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_SendHCIData(unsigned int  ms_timeout,BT_HCI_BUFFER *snd, META_BT_HCI_TXDATA_CNF  cb_tx, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_SendHCIData_r(const int meta_handle, unsigned int  ms_timeout,BT_HCI_BUFFER *snd, META_BT_HCI_TXDATA_CNF  cb_tx, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_RegisterAutoCallback(META_BT_AUTO_HCI_CNF cb_auto);
META_RESULT  __stdcall SP_META_BT_RegisterAutoCallback_r(const int meta_handle,META_BT_AUTO_HCI_CNF cb_auto);
META_RESULT  __stdcall SP_META_BT_ReceiveHCIData(META_BT_HCI_RXDATA_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_ReceiveHCIData_r(const int meta_handle,META_BT_HCI_RXDATA_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_RemoveAutoCallback(void);
META_RESULT  __stdcall SP_META_BT_RemoveAutoCallback_r(const int meta_handle);
META_RESULT  __stdcall SP_META_BT_RemoveReceiveHCIDataCallback(void);
META_RESULT  __stdcall SP_META_BT_RemoveReceiveHCIDataCallback_r(const int meta_handle);

META_RESULT  __stdcall SP_META_BT_GetChipID(unsigned int  ms_timeout, unsigned int * pID);
META_RESULT  __stdcall SP_META_BT_GetChipID_r(const int meta_handle, unsigned int  ms_timeout, unsigned int * pID);


//----------------------------------------------------------------//
//                              FM                                //
//----------------------------------------------------------------//
typedef enum
{
  FM_CHIP_ID_MT6189AN = 0,
  FM_CHIP_ID_MT6189BN_CN = 1,
  FM_CHIP_ID_MT6188A = 3,
  FM_CHIP_ID_MT6188C = 4,
  FM_CHIP_ID_MT6188D = 5,
  FM_CHIP_ID_MT6616 = 6,
  FM_CHIP_ID_AR1000 = 7,
  FM_CHIP_ID_MT6620 = 8,
  FM_CHIP_ID_MT6626 = 9,
  FM_CHIP_ID_MT6628 = 10,
  FM_CHIP_ID_MT6627 = 11,
  FM_CHIP_ID_MT6630 = 12,
  FM_CHIP_ID_MT6580 = 13
}FM_CHIP_ID_E;

typedef struct{
    unsigned char pty;         // 0~31 integer
    unsigned char rds_rbds;    // 0:RDS, 1:RBDS
    unsigned char dyn_pty;     // 0:static, 1:dynamic
    unsigned short pi_code;    // 2-byte hex
    unsigned char ps_buf[8];     // hex buf of PS
    unsigned char ps_len;      // length of PS, must be 0 / 8"
    unsigned char af;          // 0~204, 0:not used, 1~204:(87.5+0.1*af)MHz
    unsigned char ah;          // Artificial head, 0:no, 1:yes
    unsigned char stereo;      // 0:mono, 1:stereo
    unsigned char compress;    // Audio compress, 0:no, 1:yes
    unsigned char tp;          // traffic program, 0:no, 1:yes
    unsigned char ta;          // traffic announcement, 0:no, 1:yes
    unsigned char speech;      // 0:music, 1:speech
}FM_RDS_TX_REQ_T;

typedef struct
{
    unsigned char  m_ucChipId;
}FM_CHIP_ID_CNF_T;

typedef struct
{
    short m_i2CurFreq;  // freq range is [875, 1080]
}FM_FREQ_REQ_T;



typedef struct
{
    //unsigned char m_ucSignalLevel;
    int m_ucSignalLevel;
}FM_RSSI_CNF_T;

typedef struct
{
    //unsigned char m_ucIfCnt;
    unsigned short m_u2IfCnt;
    
}FM_IF_CNT_CNF_T;

typedef struct
{
    unsigned short m_u2MonoOrStereo;  // 0: mono, 1: stereo
    unsigned short m_u2SblendOnOrOff; // 0: sblend off, 1: sblend on
    unsigned int   m_u4ItemValue;  // 0: disable, 1: enable

}FM_MONO_STEREO_BLEND_REQ_T;

typedef struct  // freq range is [875, 1080]
{
   short m_i2StartFreq;    // note: when we try to search next: start freq should <= stop freq 
   short m_i2StopFreq;     // note: when we try to search prev: start freq should >= stop freq

}FM_FREQ_RANGE_REQ_T;

typedef struct
{
    unsigned char m_ucExit;      // 0: don't exist, 1: exist
    short         m_i2ValidFreq; // -1: settings error, 0: invalid freq, others: 875-1080 valid

}FM_VAILD_FREQ_CNF_T;

typedef struct
{
   unsigned int m_u4RssiThreshold;

}FM_RSSI_THRESHOLD_REQ_T;

typedef struct
{
   unsigned int m_u4IfCntDelta;

}FM_IF_CNT_DELTA_REQ_T;


typedef struct
{
    unsigned char m_ucAddr;
    
}FM_READ_BYTE_ADDR_REQ_T;


typedef struct
{
   unsigned short m_u2ReadByte;

}FM_READ_BYTE_CNF_T;


typedef struct
{
    unsigned char m_ucAddr;
    unsigned short m_u2WriteByte;
}FM_WRITE_BYTE_REQ_T;

typedef struct
{
    unsigned char m_bOnOff;  // 0: off, 1: on

}FM_SOFT_MUTE_ONOFF_REQ_T;

typedef struct
{
    unsigned char m_ucStage;  // 1~3
}FM_STAGE_REQ_T;

typedef struct
{
    unsigned char  m_ucHighOrLow;
}FM_HL_Side_CNF_T;

typedef struct
{
    unsigned char m_ucStereoOrMono;

}FM_Stereo_Mono_CNF_T;

// for MT6616 new API
typedef struct
{
    unsigned char m_ucVolume;
    char m_cDigitalGainIndex;
}FM_Volume_Setting_REQ_T;

typedef struct
{
   // unsigned short m_u2Bitmap[16]; for 100KHz
    unsigned short m_u2Bitmap[26]; //for 50KHz
}FM_AutoScan_CNF_T;

typedef struct
{
    unsigned char m_ucRDSOn;
}FM_SetRDS_REQ_T;

typedef struct
{
    unsigned char m_ucRXFilterBW;
}FM_RX_FilterBW_CNF_T;

typedef struct
{
    unsigned char m_ucPAMDLevel;
}FM_PAMD_Level_CNF_T;

typedef struct
{
    unsigned char m_ucMR;
}FM_MR_CNF_T;

typedef struct
{
    unsigned int m_u4DecodeMode;
}FM_Decode_Mode_REQ_T;

typedef struct
{
    unsigned int m_u4HCC;
}FM_HCC_REQ_T;

typedef struct
{
    unsigned int m_u4PAMDThreshold;
}FM_PAMD_Threshold_REQ_T;

typedef struct
{
    unsigned int m_u4SoftmuteEnable;
}FM_Softmute_Enable_REQ_T;

typedef struct
{
    unsigned int m_u4DeemphasisLevel;
}FM_Deemphasis_Level_REQ_T;

typedef struct
{
    unsigned int m_u4HLSide;
}FM_HL_Side_REQ_T;

typedef struct
{
    unsigned int m_u4DemodBandwidth;
}FM_Demod_Bandwidth_REQ_T;

typedef struct
{
    unsigned int m_u4DynamicLimiter;
}FM_DynamicLimiter_REQ_T;

typedef struct
{
    unsigned int m_u4SoftmuteRate;
}FM_Softmute_Rate_REQ_T;

typedef enum
{
    RDS_CMD_NONE = 0,   // No command. This is usually an error.
    RDS_CMD_PI_CODE,
    RDS_CMD_PTY_CODE,
    RDS_CMD_PROGRAMNAME,
    RDS_CMD_LOCDATETIME,
    RDS_CMD_UTCDATETIME,
    RDS_CMD_LAST_RADIOTEXT,
    RDS_CMD_AF,
    RDS_CMD_AF_LIST,  
    RDS_CMD_AFON,
    RDS_CMD_TAON,
    RDS_CMD_TAON_OFF
}RdsCmd;

typedef enum
{
    RDS_FLAG_IS_TP                                = 0x0001, // Program is a traffic program
    RDS_FLAG_IS_TA                            = 0x0002, // Program currently broadcasts a traffic ann.
    RDS_FLAG_IS_MUSIC                     = 0x0004, // Program currently broadcasts music
    RDS_FLAG_IS_STEREO                  = 0x0008, // Program is transmitted in stereo
    RDS_FLAG_IS_ARTIFICIAL_HEAD = 0x0010, // Program is an artificial head recording
    RDS_FLAG_IS_COMPRESSED       = 0x0020, // Program content is compressed
    RDS_FLAG_IS_DYNAMIC_PTY       = 0x0040, // Program type can change 
    RDS_FLAG_TEXT_AB                      = 0x0080  // If this flag changes state, a new radio text                      string begins
}RdsFlag;

typedef enum {
   RDS_EVENT_FLAGS          = 0x0001, // One of the RDS flags has changed state
   RDS_EVENT_PI_CODE        = 0x0002, // The program identification code has changed
   RDS_EVENT_PTY_CODE       = 0x0004, // The program type code has changed
   RDS_EVENT_PROGRAMNAME    = 0x0008, // The program name has changed
   RDS_EVENT_UTCDATETIME    = 0x0010, // A new UTC date/time is available
   RDS_EVENT_LOCDATETIME    = 0x0020, // A new local date/time is available
   RDS_EVENT_LAST_RADIOTEXT = 0x0040, // A radio text string was completed
   RDS_EVENT_AF                   = 0x0080, // Current Channel RF signal strength too weak, need do AF switch  
   RDS_EVENT_AF_LIST        = 0x0100, // An alternative frequency list is ready
   RDS_EVENT_AFON_LIST        = 0x0200, // An alternative frequency list is ready
   RDS_EVENT_TAON        = 0x0400,  // Other Network traffic announcement start
   RDS_EVENT_TAON_OFF        = 0x0800 // Other Network traffic announcement finished.
} RdsEvent;

typedef struct
{
    RdsCmd m_eCmd;
}FM_RDS_Info_REQ_T;

typedef struct
{
    unsigned char m_buffer[64];
}FM_RDS_Info_CNF_T;

typedef struct
{
    RdsFlag m_eFlag;
    unsigned char m_buffer[64];
}FM_RDS_Status_CNF_T;

typedef struct  
{
    char TP;
    char TA;
    char Music;
    char Stereo;
    char Artificial_Head;
    char Compressed;
    char Danamic_PTY;
    char Text_AB;
    int falg_status;
}RDSFlag_Struct;

typedef struct
{
        unsigned short Month;
        unsigned short Day;
        unsigned short Year;
        unsigned short Hour;
        unsigned short Minute;
        unsigned char Local_Time_offset_signebit;
        unsigned char Local_Time_offset_half_hour;
}CT_Struct;

typedef struct
{
    unsigned short m_u2GoodBlock;
}FM_RDS_Good_Block_Counter_CNF_T;

typedef struct
{
    unsigned short m_u2BadBlock;
}FM_RDS_Bad_Block_Counter_CNF_T;

/*
typedef struct
{
    unsigned short m_u2GroupCounter[32];
}FM_RDS_Group_Counter_CNF_T;
*/

typedef struct
{
    short m_i2StartFreq;
    unsigned char m_ucDirection;
}FM_HWSeek_REQ_T;

typedef struct
{
    short m_i2EndFreq;
}FM_HWSeek_CNF_T;


typedef struct
{
    unsigned short m_u2StereoBlendControl;
}FM_SetStereoBlend_REQ_T;


typedef struct  
{
    unsigned short DECODE_MODE;
    unsigned short STEREO_BLEND;
    unsigned short HCC;
    unsigned short PAMD_THRESHOLD;
    unsigned short RSSI_THRESHOLD;
    unsigned short SOFTMUTE;
    unsigned short COSTAS;
    unsigned short DE_EMPHASIS_LEV;
    unsigned short HL_SIDE;
    unsigned short DEMOD_BANDWIDTH;
    unsigned short DYNAMIC_LIMITER;
    unsigned short SOFTMUTE_RATE;
    unsigned short AFC;
    unsigned short SET_BW;
    unsigned short CAP_ARRAY;
    unsigned short DEMOD_TYPE;
}FM_SETStatus_REQ_T;

typedef struct  
{
    unsigned short RSSI;               //RSSI
    unsigned short RSSI_HEX;           //RSSI(Hex)
    unsigned short RSSI_DBM;            //
    unsigned short STA_BW;              //BW
    unsigned short PAMD;
    unsigned short PAMD_HEX;
    unsigned short PAMD_DBM;
    unsigned short MR;
    unsigned short STEREO_MONO;            //Stereo/Mono
    unsigned short BLEND_GAIN;            //Blend gain
    unsigned short BLEND_FILTER_NUMBER; //Blend filter number
    unsigned short SOFTMUTE_GMS;
    unsigned short SOFTMUTE_GFS;
    unsigned short DYNAMIC_GAIN;
    unsigned short PILOT_LOCKED_FLAG;
    unsigned short SOFTMUTE_SELECTION_FLAG;
    unsigned short RSSI_HCC;
    unsigned short PAMD_HCC;
    unsigned short RSSI_OFF_B;
    unsigned short RSSI_OFF_H;
    unsigned short PAMD_OFF_B;
    unsigned short PAMD_OFF_H;
    unsigned short HCC_FILTER;
    unsigned short SOFTMUTE_STEP;
    unsigned short GAIN_COUNTER;
    unsigned short PGA_GAIN;
    unsigned short LNA_GAIN;
    unsigned short PGA_GAIN_INDEX;
    unsigned short LNA_GAIN_INDEX;
    unsigned short TOTAL_GAIN;
    unsigned short PULSE_RATIO;
    unsigned short FAST_PAMD;
    unsigned short POWER_DETECTOR;
    unsigned short CHIP_ID;
}FM_Status_CNF_T;

//--------------------------//
//      FM Functions        //
//--------------------------//

META_RESULT  __stdcall SP_META_FM_SetRDSTX(unsigned int ms_timeout,FM_RDS_TX_REQ_T req );
META_RESULT  __stdcall SP_META_FM_SetRDSTX_r(const int meta_handle, unsigned int ms_timeout,FM_RDS_TX_REQ_T req);
META_RESULT  __stdcall SP_META_FM_SetStatus(unsigned int ms_timeout, char * fileName,FM_SETStatus_REQ_T req);
META_RESULT  __stdcall SP_META_FM_SetStatus_r(const int meta_handle, unsigned int ms_timeout, char * fileName,FM_SETStatus_REQ_T req);
META_RESULT  __stdcall SP_META_FM_GetStatus( unsigned int ms_timeout, char * fileName,FM_Status_CNF_T* cnf);
META_RESULT  __stdcall SP_META_FM_GetStatus_r(const int meta_handle, unsigned int ms_timeout, char * fileName,FM_Status_CNF_T* cnf);
META_RESULT  __stdcall SP_META_FM_GetChipId(unsigned int ms_timeout, FM_CHIP_ID_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetChipId_r(const int meta_handle, unsigned int ms_timeout, FM_CHIP_ID_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_PowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_PowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_TXPowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_TXPowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_PowerOff(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_PowerOff_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_TxSetFreq(unsigned int ms_timeout, FM_FREQ_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_TxSetFreq_r(const int meta_handle,unsigned int ms_timeout, FM_FREQ_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetFreq(unsigned int ms_timeout, FM_FREQ_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_GetRSSI(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_RSSI_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetRSSI_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_RSSI_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetIfCnt(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_IF_CNT_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetIfCnt_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_IF_CNT_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SearchNextFreq(unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SearchNextFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SearchPrevFreq(unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SearchPrevFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T *req, FM_VAILD_FREQ_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SetMonoOrStereo_Blend(unsigned int ms_timeout, FM_MONO_STEREO_BLEND_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetMonoOrStereo_Blend_r(const int meta_handle, unsigned int ms_timeout, FM_MONO_STEREO_BLEND_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetRssiThreold(unsigned int ms_timeout, FM_RSSI_THRESHOLD_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetRssiThreold_r(const int meta_handle, unsigned int ms_timeout, FM_RSSI_THRESHOLD_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetIfCntDelta(unsigned int ms_timeout, FM_IF_CNT_DELTA_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetIfCntDelta_r(const int meta_handle, unsigned int ms_timeout, FM_IF_CNT_DELTA_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_ReadByte(unsigned int ms_timeout, FM_READ_BYTE_ADDR_REQ_T *req, FM_READ_BYTE_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_ReadByte_r(const int meta_handle, unsigned int ms_timeout, FM_READ_BYTE_ADDR_REQ_T *req, FM_READ_BYTE_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_WriteByte(unsigned int ms_timeout, FM_WRITE_BYTE_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_WriteByte_r(const int meta_handle, unsigned int ms_timeout, FM_WRITE_BYTE_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetSoftMute(unsigned int ms_timeout, FM_SOFT_MUTE_ONOFF_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetSoftMute_r(const int meta_handle, unsigned int ms_timeout, FM_SOFT_MUTE_ONOFF_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SelectSoftMuteStage(unsigned int ms_timeout, FM_STAGE_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SelectSoftMuteStage_r(const int meta_handle, unsigned int ms_timeout, FM_STAGE_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SelectSBlendStage(unsigned int ms_timeout, FM_STAGE_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SelectSBlendStage_r(const int meta_handle, unsigned int ms_timeout, FM_STAGE_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_GetHighOrLowSide(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_HL_Side_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetHighOrLowSide_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_HL_Side_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetStereoOrMono(unsigned int ms_timeout, FM_Stereo_Mono_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetStereoOrMono_r(const int meta_handle, unsigned int ms_timeout, FM_Stereo_Mono_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SetVolume(unsigned int ms_timeout, FM_Volume_Setting_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetVolume_r(const int meta_handle, unsigned int ms_timeout, FM_Volume_Setting_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_AutoScan(unsigned int ms_timeout, FM_AutoScan_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_AutoScan_r(const int meta_handle, unsigned int ms_timeout, FM_AutoScan_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SetRDS(unsigned int ms_timeout, FM_SetRDS_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetRDS_r(const int meta_handle, unsigned int ms_timeout, FM_SetRDS_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_GetRXFilterBW(unsigned int ms_timeout, FM_RX_FilterBW_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetRXFilterBW_r(const int meta_handle, unsigned int ms_timeout, FM_RX_FilterBW_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetPAMDLevel(unsigned int ms_timeout, FM_FREQ_REQ_T *req, FM_PAMD_Level_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetPAMDLevel_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_PAMD_Level_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetMR(unsigned int ms_timeout, FM_MR_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetMR_r(const int meta_handle, unsigned int ms_timeout, FM_MR_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_SetDecodeMode(unsigned int ms_timeout, FM_Decode_Mode_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetDecodeMode_r(const int meta_handle, unsigned int ms_timeout, FM_Decode_Mode_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetHCC(unsigned int ms_timeout, FM_HCC_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetHCC_r(const int meta_handle, unsigned int ms_timeout, FM_HCC_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetPAMDThreshold(unsigned int ms_timeout, FM_PAMD_Threshold_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetPAMDThreshold_r(const int meta_handle, unsigned int ms_timeout, FM_PAMD_Threshold_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_YUSU_SetSoftmute(unsigned int ms_timeout, FM_Softmute_Enable_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_YUSU_SetSoftmute_r(const int meta_handle, unsigned int ms_timeout, FM_Softmute_Enable_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetDeemphasisLevel(unsigned int ms_timeout, FM_Deemphasis_Level_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetDeemphasisLevel_r(const int meta_handle, unsigned int ms_timeout, FM_Deemphasis_Level_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetHLSide(unsigned int ms_timeout, FM_HL_Side_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetHLSide_r(const int meta_handle, unsigned int ms_timeout, FM_HL_Side_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetDemodBW(unsigned int ms_timeout, FM_Demod_Bandwidth_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetDemodBW_r(const int meta_handle, unsigned int ms_timeout, FM_Demod_Bandwidth_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetDynamicLimiter(unsigned int ms_timeout, FM_DynamicLimiter_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetDynamicLimiter_r(const int meta_handle, unsigned int ms_timeout, FM_DynamicLimiter_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetSoftmuteRate(unsigned int ms_timeout, FM_Softmute_Rate_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_SetSoftmuteRate_r(const int meta_handle, unsigned int ms_timeout, FM_Softmute_Rate_REQ_T *req);
META_RESULT  __stdcall SP_META_FM_GetPI(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetPI_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetPTY(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetPTY_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetPS(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetPS_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetAF(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetAF_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetRT(unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetRT_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T *req, FM_RDS_Info_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetTP(unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetTP_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetTA(unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetTA_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetMS(unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetMS_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetGoodBlockCounter(unsigned int ms_timeout, FM_RDS_Good_Block_Counter_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetGoodBlockCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Good_Block_Counter_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetBadBlockCounter(unsigned int ms_timeout, FM_RDS_Bad_Block_Counter_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_GetBadBlockCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Bad_Block_Counter_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_ResetBlockCounter(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_ResetBlockCounter_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_ResetGroupCounter(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_ResetGroupCounter_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_HWSeek(unsigned int ms_timeout, FM_HWSeek_REQ_T *req, FM_HWSeek_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_HWSeek_r(const int meta_handle, unsigned int ms_timeout, FM_HWSeek_REQ_T *req, FM_HWSeek_CNF_T *cnf);
META_RESULT  __stdcall SP_META_FM_HWSearch_Stop(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_HWSearch_Stop_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_SetStereoBlend(unsigned int ms_timeout, FM_SetStereoBlend_REQ_T* req);
META_RESULT  __stdcall SP_META_FM_SetStereoBlend_r(const int meta_handle, unsigned int ms_timeout, FM_SetStereoBlend_REQ_T* req);


//New API using workflow
typedef enum
{
    FMTX_1K_TONE = 1, 
    FMTX_2K_TONE = 2,
    FMTX_3K_TONE = 3,
    FMTX_4K_TONE = 4,
    FMTX_5K_TONE = 5,
    FMTX_6K_TONE = 6,
    FMTX_7K_TONE = 7,
    FMTX_8K_TONE = 8,
    FMTX_9K_TONE = 9,
    FMTX_10K_TONE = 10,
    FMTX_11K_TONE = 11,
    FMTX_12K_TONE = 12,
    FMTX_13K_TONE = 13,
    FMTX_14K_TONE = 14,
    FMTX_15K_TONE = 15,
    FMTX_MAX_TONE
    
}FM_TX_TONE_T;

typedef enum
{
    FM_TX_AUDIO_ANALOG = 0,
    FM_TX_AUDIO_I2S = 1,
    FM_RX_AUDIO_ANALOG = 2,
    FM_RX_AUDIO_I2S = 3,
    FM_AUDIO_MAX
    
}FM_TX_AUDIO_PATH_T;

typedef enum
{
    FM_ANA_LONG = 0,
    FM_ANA_SHORT=1,
    FM_ANA_MAX
    
}FM_ANA_T;


typedef struct
{
    FM_TX_AUDIO_PATH_T m_audioPath;
    
}FM_SetTxAudioPath_REQ_T;

typedef struct
{
    FM_TX_TONE_T m_audioFreq;
    
}FM_SetTxAudioFreq_REQ_T;


#define MAX_RDS_LOGDATA_LEN 256

typedef struct
{
    unsigned int dataLen;
    char data[MAX_RDS_LOGDATA_LEN];
    
} FM_RDS_LOGDATA_T;

typedef struct
{
    unsigned long total;
    unsigned long groupA[16]; //RDS groupA counter
    unsigned long groupB[16]; //RDS groupB counter
    
} FM_RDS_GROUPCOUNTER_T;

typedef struct
{
    int ana;
}FM_SetAntenna_REQ_T;

typedef struct
{
    int m_uCapArray;
}FM_CapArray_CNF_T;


typedef struct
{
    int  m_i4Step;
}FM_STEP_MODE_CNF_T;



META_RESULT  __stdcall SP_META_FM_SetTxAudioPath(unsigned int ms_timeout, FM_SetTxAudioPath_REQ_T path);
META_RESULT  __stdcall SP_META_FM_SetTxAudioPath_r(const int meta_handle, unsigned int ms_timeout, FM_SetTxAudioPath_REQ_T path);
META_RESULT  __stdcall SP_META_FM_SetTxAudioFreq(unsigned int ms_timeout, FM_SetTxAudioFreq_REQ_T freq);
META_RESULT  __stdcall SP_META_FM_SetTxAudioFreq_r(const int meta_handle, unsigned int ms_timeout, FM_SetTxAudioFreq_REQ_T freq);
META_RESULT  __stdcall SP_META_FM_GetRDSLogData(unsigned int ms_timeout, FM_RDS_LOGDATA_T * pCnf);
META_RESULT  __stdcall SP_META_FM_GetRDSLogData_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_LOGDATA_T * pCnf);
META_RESULT  __stdcall SP_META_FM_GetRDSBlerRatio(unsigned int ms_timeout, unsigned short * pBler);
META_RESULT  __stdcall SP_META_FM_GetRDSBlerRatio_r(const int meta_handle, unsigned int ms_timeout, unsigned short * pBler);
META_RESULT  __stdcall SP_META_FM_GetRDSGroupCounter(unsigned int ms_timeout, FM_RDS_GROUPCOUNTER_T * pCnf);
META_RESULT  __stdcall SP_META_FM_GetRDSGroupCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_GROUPCOUNTER_T * pCnf);
META_RESULT  __stdcall SP_META_FM_SetAntenna(unsigned int ms_timeout, FM_SetAntenna_REQ_T * pReq);
META_RESULT  __stdcall SP_META_FM_SetAntenna_r(const int meta_handle, unsigned int ms_timeout, FM_SetAntenna_REQ_T * pReq);
META_RESULT  __stdcall SP_META_FM_GetCapArray(unsigned int ms_timeout, FM_CapArray_CNF_T * pCnf);
META_RESULT  __stdcall SP_META_FM_GetCapArray_r(const int meta_handle, unsigned int ms_timeout, FM_CapArray_CNF_T * pCnf);
META_RESULT  __stdcall SP_META_FM_GetStepMode(unsigned int ms_timeout, FM_STEP_MODE_CNF_T * pCnf);
META_RESULT  __stdcall SP_META_FM_GetStepMode_r(const int meta_handle, unsigned int ms_timeout, FM_STEP_MODE_CNF_T * pCnf);




typedef void (__stdcall *WM_META_FM_RDS_INFO_UPDATE_CNF)(const FM_RDS_Info_CNF_T *cnf, const short token, void *usrData);
typedef void (__stdcall *WM_META_FM_RDS_STATUS_UPDATE_CNF)(const FM_RDS_Status_CNF_T *cnf, const short token, void *usrData);
typedef struct
{
    WM_META_FM_RDS_INFO_UPDATE_CNF m_RDSInfoUpdateCallback;
    WM_META_FM_RDS_STATUS_UPDATE_CNF m_RDSStatusUpdateCallback;
} FM_RDSCallBack;

META_RESULT  __stdcall SP_META_FM_RegisterRDSInfoUpdateCallback(WM_META_FM_RDS_INFO_UPDATE_CNF cb);
META_RESULT  __stdcall SP_META_FM_RegisterRDSInfoUpdateCallback_r(const int meta_handle, WM_META_FM_RDS_INFO_UPDATE_CNF cb);
META_RESULT  __stdcall SP_META_FM_RegisterRDSStatusUpdateCallback(WM_META_FM_RDS_STATUS_UPDATE_CNF cb);
META_RESULT  __stdcall SP_META_FM_RegisterRDSStatusUpdateCallback_r(const int meta_handle, WM_META_FM_RDS_STATUS_UPDATE_CNF cb);
META_RESULT  __stdcall SP_META_FM_RemoveRDSInfoUpdateCallback(void);
META_RESULT  __stdcall SP_META_FM_RemoveRDSInfoUpdateCallback_r(const int meta_handle);
META_RESULT  __stdcall SP_META_FM_RemoveRDSStatusUpdateCallback(void);
META_RESULT  __stdcall SP_META_FM_RemoveRDSStatusUpdateCallback_r(const int meta_handle);

// FM Audio Test
META_RESULT  __stdcall SP_META_FM_AudioTest(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_FM_AudioTest_r(const int meta_handle, unsigned int ms_timeout);


//-----------------------------------------------------//
//  WM META UnitTest
//-----------------------------------------------------//

typedef struct {
    unsigned int    m_TestCaseID;
    const char *    m_pDescription;
} WM_META_UT_TestCaseID_T;

void __stdcall SP_META_QueryTestCase(WM_META_UT_TestCaseID_T  **ppTestCase, unsigned int  *pTestCaseCount);
void __stdcall SP_META_UnitTest(const unsigned int  *p_TestCaseID_Array, unsigned int  TestCaseCount);


// --------------------------------------------------------------------------------
//      WM_Battery:    data structure definition     addey by yuying 2008-12-18     
// --------------------------------------------------------------------------------
typedef enum{
    FILE_START,
    FILE_ONGOING,
    FILE_CLOSE,
    FILE_ONCE
}WM_Bat_Image_OP_TYPE;

typedef enum{
    FILE_Success,
    FILE_Fail
}WM_Bat_File_Err_TYPE;

 typedef enum{
  WM_BAT_WRITE_DATA=0,
  WM_BAT_COMPARA_DATA,
  WM_BAT_DELAY
}WM_BAT_Upload_OP_TYPE;

typedef struct{
    int                nReqDLImageStatus;
    unsigned int        image_size;  //the size of whole image
    unsigned int        block_size;  //the size of current transfer.
}WM_Bat_DLImage_REQ_T;

typedef struct{
    int    nCnfDLImageStatus;
    int    DL_Status;        //0-success 1-failed
}WM_Bat_DLImage_CNF_T;

typedef struct{
    //int    nReqUPImageStatus;
    WM_Bat_Image_OP_TYPE    nReqStartStatus;
     WM_BAT_Upload_OP_TYPE     nReqUpdateOpStatus;
      char                      StartAddress;        
      unsigned short             delaytime;
    unsigned short            nLen;
    char                    Buf[96];
}WM_Bat_UPImage_REQ_T;

typedef struct{
    WM_Bat_Image_OP_TYPE    nCnfStartStatus;    //0-first 1-
    int    nCnfUpdateStatus;  //0-success 1-fail
}WM_Bat_UPImage_CNF_T;


//wifi
typedef struct
{    
    unsigned int        int_rx_ok_num;
    unsigned int        int_crc_err_num;
    unsigned int        int_rssi_max;
    unsigned int        int_rssi_min;
    unsigned int        int_rssi_mean;
    unsigned int        int_rssi_variance;
} WIFI_RXSTATUS_T;

typedef enum _ENUM_CFG_SRC_TYPE_T
{
    CFG_SRC_TYPE_EEPROM,    //cfg data is queried/set from/to EEPROM
    CFG_SRC_TYPE_NVRAM,        //cfg data is queried/set from/to NVRAM
    CFG_SRC_TYPE_BOTH,        //cfg data is queried/set from/to NVRAM, and E2PROM presents too
    CFG_SRC_TYPE_AUTO
} ENUM_CFG_SRC_TYPE_T;

typedef struct
{
    int bufSize;
    int bLongPreamble;
    int txRate;
    int pktCount;
    int pktInterval;
    int bGainControl;
    int gainControl;
    int bTrackAlc;
    int bTargetAlc;
    int targetAlcValue;
    int txAntenna;
    
} WIFI_TX_PARAM_T;

META_RESULT  __stdcall SP_META_WiFi_QueryConfig(unsigned int ms_timeout, ENUM_CFG_SRC_TYPE_T *bufType);
META_RESULT  __stdcall SP_META_WiFi_QueryConfig_r(int meta_handle, unsigned int ms_timeout, ENUM_CFG_SRC_TYPE_T *bufType);
META_RESULT  __stdcall SP_META_WiFi_setPacketRx(unsigned int ms_timeout, int condition, int nAntenna);
META_RESULT  __stdcall SP_META_WiFi_setPacketRx_r(const int meta_handle, unsigned int ms_timeout, int condition, int nAntenna);
META_RESULT  __stdcall SP_META_WiFi_readMCR32(unsigned int ms_timeout, unsigned int offset, unsigned long *value);
META_RESULT  __stdcall SP_META_WiFi_readMCR32_r(const int meta_handle, unsigned int ms_timeout, unsigned int offset, unsigned long *value);
META_RESULT  __stdcall SP_META_WiFi_writeMCR32(unsigned int ms_timeout, unsigned int offset, unsigned int value);
META_RESULT  __stdcall SP_META_WiFi_writeMCR32_r(const int meta_handle, unsigned int ms_timeout, unsigned int offset, unsigned int value);


META_RESULT  __stdcall SP_META_WiFi_ReadConfigData(unsigned int ms_timeout, unsigned int offset, unsigned long *value, ENUM_CFG_SRC_TYPE_T type);
META_RESULT  __stdcall SP_META_WiFi_ReadConfigData_r(int meta_handle, unsigned int ms_timeout, unsigned int offset, unsigned long *value, ENUM_CFG_SRC_TYPE_T type);
META_RESULT  __stdcall SP_META_WiFi_WriteConfigData(unsigned int ms_timeout, unsigned int offset, unsigned int value, ENUM_CFG_SRC_TYPE_T type);
META_RESULT  __stdcall SP_META_WiFi_WriteConfigData_r(int meta_handle, unsigned int ms_timeout, unsigned int offset, unsigned int value, ENUM_CFG_SRC_TYPE_T type);

#define SP_META_WiFi_readEEPRom16(ms_timeout, offset, value)    \
    META_WiFi_ReadConfigData(ms_timeout, offset, value, CFG_SRC_TYPE_AUTO)
#define SP_META_WiFi_writeEEPRom16(ms_timeout, offset, value)    \
    META_WiFi_WriteConfigData(ms_timeout, offset, value, CFG_SRC_TYPE_AUTO)
#define SP_META_WiFi_readEEPRom16_r(meta_handle, ms_timeout, offset, value)    \
SP_META_WiFi_ReadConfigData_r(meta_handle, ms_timeout, offset, value, CFG_SRC_TYPE_AUTO)
#define SP_META_WiFi_writeEEPRom16_r(meta_handle, ms_timeout, offset, value)    \
SP_META_WiFi_WriteConfigData_r(meta_handle, ms_timeout, offset, value, CFG_SRC_TYPE_AUTO)

META_RESULT  __stdcall SP_META_WiFi_eepromReadByteStr(unsigned int ms_timeout, unsigned int u4Addr, unsigned int u4Length, char *pszStr);
META_RESULT  __stdcall SP_META_WiFi_eepromReadByteStr_r(const int meta_handle, unsigned int ms_timeout, unsigned int u4Addr, unsigned int u4Length, char *pszStr);
META_RESULT  __stdcall SP_META_WiFi_eepromWriteByteStr(unsigned int ms_timeout, unsigned int u4Addr, unsigned int u4Length, char *pszStr);
META_RESULT  __stdcall SP_META_WiFi_eepromWriteByteStr_r(const int meta_handle, unsigned int ms_timeout, unsigned int u4Addr, unsigned int u4Length, char *pszStr);
META_RESULT  __stdcall SP_META_WiFi_getChannel(unsigned int ms_timeout, long *channelConfig_p);
META_RESULT  __stdcall SP_META_WiFi_getChannel_r(const int meta_handle, unsigned int ms_timeout, long *channelConfig_p);
META_RESULT  __stdcall SP_META_WiFi_setPacketTxEx(unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam);
META_RESULT  __stdcall SP_META_WiFi_setPacketTxEx_r(const int meta_handle, unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam);
META_RESULT  __stdcall SP_META_WiFi_GetATParam(unsigned int ms_timeout, unsigned int offset, unsigned long *value);
META_RESULT  __stdcall SP_META_WiFi_GetATParam_r(const int meta_handle, unsigned int ms_timeout, unsigned int offset, unsigned long *value);
META_RESULT  __stdcall SP_META_WiFi_SetATParam(unsigned int ms_timeout, unsigned int offset, unsigned int value);
META_RESULT  __stdcall SP_META_WiFi_SetATParam_r(const int meta_handle, unsigned int ms_timeout, unsigned int offset, unsigned int value);
META_RESULT  __stdcall SP_META_WiFi_setOutputPower(unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam);
META_RESULT  __stdcall SP_META_WiFi_setOutputPower_r(const int meta_handle, unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam);
META_RESULT  __stdcall SP_META_WiFi_setStandBy(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_setStandBy_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_setCarrierSuppression(unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam);
META_RESULT  __stdcall SP_META_WiFi_setCarrierSuppression_r(const int meta_handle, unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam);
META_RESULT  __stdcall SP_META_WiFi_setLocalFrequecy(unsigned int ms_timeout, int txPower, int txAntenna);
META_RESULT  __stdcall SP_META_WiFi_setLocalFrequecy_r(const int meta_handle, unsigned int ms_timeout, int txPower, int txAntenna);
META_RESULT  __stdcall SP_META_WiFi_setNormalMode(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_setNormalMode_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_setOutputPin(unsigned int ms_timeout, int pinIndex, int outputLevel);
META_RESULT  __stdcall SP_META_WiFi_setOutputPin_r(const int meta_handle, unsigned int ms_timeout, int pinIndex, int outputLevel);
META_RESULT  __stdcall SP_META_WiFi_setPnpPower(unsigned int ms_timeout, int i4PowerMode);
META_RESULT  __stdcall SP_META_WiFi_setPnpPower_r(const int meta_handle, unsigned int ms_timeout, int i4PowerMode);
META_RESULT  __stdcall SP_META_WiFi_setTestMode(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_setTestMode_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_setChannel(unsigned int ms_timeout, int channelConfig);
META_RESULT  __stdcall SP_META_WiFi_setChannel_r(const int meta_handle, unsigned int ms_timeout, int channelConfig);
META_RESULT  __stdcall SP_META_WiFi_readTxPowerFromEEPromEx(unsigned int ms_timeout, int channelFreq, int rate, long *nTxPwr, long *outputPower, long *targetAlc);
META_RESULT  __stdcall SP_META_WiFi_readTxPowerFromEEPromEx_r(const int meta_handle, unsigned int ms_timeout, int channelFreq, int rate, long *nTxPwr, long *outputPower, long *targetAlc);
META_RESULT  __stdcall SP_META_WiFi_getPacketRxStatus(unsigned int ms_timeout, WIFI_RXSTATUS_T *pRxStatus);
META_RESULT  __stdcall SP_META_WiFi_getPacketRxStatus_r(const int meta_handle, unsigned int ms_timeout, WIFI_RXSTATUS_T *pRxStatus);
META_RESULT  __stdcall SP_META_WiFi_setXtalTrimToCr(unsigned int ms_timeout, unsigned int u4Value);
META_RESULT  __stdcall SP_META_WiFi_setXtalTrimToCr_r(const int meta_handle, unsigned int ms_timeout, unsigned int u4Value);
META_RESULT  __stdcall SP_META_WiFi_queryThermoInfo(unsigned int ms_timeout, long * pi4Enable, unsigned long * pu4RawVal);
META_RESULT  __stdcall SP_META_WiFi_queryThermoInfo_r(const int meta_handle, unsigned int ms_timeout, long * pi4Enable, unsigned long * pu4RawVal);
META_RESULT  __stdcall SP_META_WiFi_setThermoEn(unsigned int ms_timeout, long i4Enable);
META_RESULT  __stdcall SP_META_WiFi_setThermoEn_r(const int meta_handle, unsigned int ms_timeout, long i4Enable);


//add by dian.wang for MT6620
META_RESULT __stdcall SP_META_WiFi_readTxPower(unsigned int ms_timeout, unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_readTxPower_r(const int meta_handle, unsigned int ms_timeout, unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_setRxTest(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_setRxTest_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_setBandwidth(unsigned int ms_timeout,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_setBandwidth_r(const int meta_handle, unsigned int ms_timeout,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_setGuardinterval( unsigned int ms_timeout,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_setGuardinterval_r(const int meta_handle, unsigned int ms_timeout,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_setModeSelect(unsigned int ms_timeout,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_setModeSelect_r(const int meta_handle, unsigned int ms_timeout,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_setTxRxIQCalibration( unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_setTxRxIQCalibration_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_setDPDCalibration( unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_setDPDCalibration_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_getResultInformation( unsigned int ms_timeout,unsigned int index,unsigned long * length);
META_RESULT __stdcall SP_META_WiFi_getResultInformation_r(const int meta_handle, unsigned int ms_timeout,unsigned int index,unsigned long * length);
META_RESULT __stdcall SP_META_WiFi_getCalResult(unsigned int ms_timeout,unsigned int index,unsigned int offset,unsigned long * data);
META_RESULT __stdcall SP_META_WiFi_getCalResult_r(const int meta_handle, unsigned int ms_timeout,unsigned int index,unsigned int offset,unsigned long * data);
META_RESULT __stdcall SP_META_WiFi_getTemperatureSensorResult( unsigned int ms_timeout,unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_getTemperatureSensorResult_r(const int meta_handle, unsigned int ms_timeout,unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_getVoltageSensorResult(unsigned int ms_timeout,unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_getVoltageSensorResult_r(const int meta_handle, unsigned int ms_timeout,unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_readEFuseAddr( unsigned int ms_timeout,unsigned int addr,unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_readEFuseAddr_r(const int meta_handle, unsigned int ms_timeout,unsigned int addr,unsigned long *value);
META_RESULT __stdcall SP_META_WiFi_writeEFuseAddr(unsigned int ms_timeout,unsigned int addr,unsigned int value);
META_RESULT __stdcall SP_META_WiFi_writeEFuseAddr_r(const int meta_handle, unsigned int ms_timeout,unsigned int addr,unsigned int value);
/*DEPRECATED*/META_RESULT __stdcall SP_META_WiFi_setTSSIEnableorDisable(unsigned int ms_timeout,unsigned int flag);
/*DEPRECATED*/META_RESULT __stdcall SP_META_WiFi_setTSSIEnableorDisable_r(const int meta_handle, unsigned int ms_timeout,unsigned int flag);
/*DEPRECATED*/META_RESULT __stdcall SP_META_WiFi_getTSSICalibrationResult( unsigned int ms_timeout,unsigned long * value);
/*DEPRECATED*/META_RESULT __stdcall SP_META_WiFi_getTSSICalibrationResult_r(const int meta_handle, unsigned int ms_timeout,unsigned long * value);
META_RESULT __stdcall SP_META_WiFi_TSSICalibration( unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_TSSICalibration_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WiFi_setRate(unsigned int ms_timeout,unsigned long value);
META_RESULT __stdcall SP_META_WiFi_setRate_r(const int meta_handle, unsigned int ms_timeout,unsigned long value);
META_RESULT __stdcall SP_META_WiFi_ReceivedErrorCount(unsigned int ms_timeout, unsigned long * value);
META_RESULT __stdcall SP_META_WiFi_ReceivedErrorCount_r(const int meta_handle, unsigned int ms_timeout, unsigned long * value);
META_RESULT __stdcall SP_META_WiFi_ReceivedOKCount(unsigned int ms_timeout, unsigned long * value);
META_RESULT __stdcall SP_META_WiFi_ReceivedOKCount_r(const int meta_handle, unsigned int ms_timeout, unsigned long * value);
META_RESULT __stdcall SP_META_WiFi_GetChipVersion( unsigned int ms_timeout,unsigned long * chipVersion);
META_RESULT __stdcall SP_META_WiFi_GetChipVersion_r(const int meta_handle, unsigned int ms_timeout,unsigned long * chipVersion);



typedef struct _NVRAM_ACCESS_STRUCT 
{
    unsigned int dataLen; 
    unsigned int dataOffset; /*set as zero for whole region */
    char * data;
    
} NVRAM_ACCESS_STRUCT;

META_RESULT  __stdcall SP_META_WiFi_WriteNVRAM_r(const int meta_handle, unsigned int  ms_timeout, NVRAM_ACCESS_STRUCT * pReq);
META_RESULT  __stdcall SP_META_WiFi_WriteNVRAM(unsigned int  ms_timeout, NVRAM_ACCESS_STRUCT * pReq);
META_RESULT  __stdcall SP_META_WiFi_ReadNVRAM_r(const int meta_handle, unsigned int  ms_timeout, NVRAM_ACCESS_STRUCT * pReq);
META_RESULT  __stdcall SP_META_WiFi_ReadNVRAM(unsigned int  ms_timeout, NVRAM_ACCESS_STRUCT * pReq);


//for wifi CW mode
//for input parameter nTxRate please set to 0.
//for input parameter nCWModeType please set to 4. 
META_RESULT __stdcall SP_META_WiFi_setCWMode(unsigned int ms_timeout, int nTxRate, int nCWModeType);
META_RESULT __stdcall SP_META_WiFi_setCWMode_r(const int meta_handle, unsigned int ms_timeout, int nTxRate, int nCWModeType);

META_RESULT __stdcall SP_META_WiFi_ReceivedRSSI(unsigned int ms_timeout, long * value);
META_RESULT __stdcall SP_META_WiFi_ReceivedRSSI_r(const int meta_handle, unsigned int ms_timeout, long * value);
//

//For WiFi MT6630
META_RESULT __stdcall SP_META_WiFi_setBandwidthEx(unsigned int ms_timeout, unsigned int nChBandwidth, unsigned int nDataBandwidth, unsigned int nPrimarySetting);
META_RESULT __stdcall SP_META_WiFi_setBandwidthEx_r(const int meta_handle, unsigned int ms_timeout, unsigned int nChBandwidth, unsigned int nDataBandwidth, unsigned int nPrimarySetting);

META_RESULT __stdcall SP_META_WiFi_setJMode(unsigned int ms_timeout, unsigned int nMode);
META_RESULT __stdcall SP_META_WiFi_setJMode_r(const int meta_handle, unsigned int ms_timeout, unsigned int nMode);
//

META_RESULT  __stdcall SP_META_WiFi_setDutyCycle(unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam, int nCWMode);
META_RESULT  __stdcall SP_META_WiFi_setDutyCycle_r(const int meta_handle, unsigned int ms_timeout, WIFI_TX_PARAM_T * pTxParam, int nCWMode);

//add 2016-02-01
META_RESULT __stdcall SP_META_WiFi_setTXPath(unsigned int ms_timeout, unsigned int nPath);
META_RESULT __stdcall SP_META_WiFi_setTXPath_r(const int meta_handle, unsigned int ms_timeout, unsigned int nPath);

META_RESULT __stdcall SP_META_WiFi_setTX1Channel(unsigned int ms_timeout, int channelConfig);
META_RESULT __stdcall SP_META_WiFi_setTX1Channel_r(const int meta_handle, unsigned int ms_timeout, int channelConfig);

META_RESULT __stdcall SP_META_WiFi_setNss(unsigned int ms_timeout, int nNss);
META_RESULT __stdcall SP_META_WiFi_setNss_r(const int meta_handle, unsigned int ms_timeout, int nNss); 

META_RESULT __stdcall SP_META_WiFi_setRXPath(unsigned int ms_timeout, unsigned int nPath);
META_RESULT __stdcall SP_META_WiFi_setRXPath_r(const int meta_handle, unsigned int ms_timeout, unsigned int nPath);

//add 2016-03-31
META_RESULT __stdcall SP_META_WiFi_ReceivedRSSI1(unsigned int ms_timeout, long * value);
META_RESULT __stdcall SP_META_WiFi_ReceivedRSSI1_r(const int meta_handle, unsigned int ms_timeout, long * value);


//Clean Boot Flag
META_RESULT __stdcall SP_META_SetCleanBootFlag(unsigned int ms_timeout,SetCleanBootFlag_REQ *req, SetCleanBootFlag_CNF *cnf);
META_RESULT __stdcall SP_META_SetCleanBootFlag_r(const int meta_handle,unsigned int ms_timeout,SetCleanBootFlag_REQ *req,SetCleanBootFlag_CNF *cnf);

//Battey FW/SOC info
typedef enum{
 BAT_READ_INFO_FAILED=0, 
 BAT_READ_INFO_SUCCESS,
 BAT_READ_FW_SUCCESS,
 BAT_READ_VBAT_SUCCESS 
}WM_Bat_READ_FW_TYPE;

 typedef enum{
    WM_BAT_SOC1_SETTINGS=0,
       WM_BAT_SOC1_CLEAR
 }WM_BAT_SOC_TYPE;

typedef struct
{
      int         ibatteryinfo; //N/A
}WM_Bat_READ_FW_INFO_REQ_T;
 
typedef struct{
      //int         ibatteryinfo; //N/A
      int        nReqReadSocType;    //0-setting, 1-clear
}WM_Bat_READ_SOC_REQ_T; 
 
typedef struct
{
      //unsigned short     SocValue; //N/A
      unsigned char        SocValue;
      unsigned char        SocClearValue;
      int        nReqWriteSocType;    //0-setting, 1-clear
}WM_Bat_WRITE_SOC_REQ_T; 
 
typedef struct
{
    unsigned short    BQ27500_FW_Version;        //0xFFFF
    unsigned short    BQ27500_Battery_Voltage;     //0xFFFF  
    unsigned short    BQ27500_DFI_Version;
//    WM_Bat_READ_FW_TYPE    Drv_Status;     
      int                Drv_Status;
 }WM_Bat_READ_FW_INFO_CNF_T;
 
typedef struct{    
    unsigned char       BQ27500_SOC_Threshold;        //0xFFFF  
    unsigned char        BQ27500_SOC_ClearThreshold;
     
    //WM_Bat_READ_FW_TYPE        Drv_Status; 
    int                Drv_Status;
}WM_Bat_READ_SOC_CNF_T;
 
typedef struct{        
     //WM_Bat_READ_FW_TYPE        Drv_Status; 
    int                Drv_Status;
}WM_Bat_WRITE_SOC_CNF_T;

//GPS module
typedef struct{
    unsigned int    len;
    unsigned char    buff[1024];
}GPS_CMD; 

typedef struct {
    unsigned int    len;
    unsigned char    buff[1024];
}GPS_ACK_BUF;

//GPS callback
typedef void (__stdcall *META_GPS_SEND_COMMAND_CNF)(const GPS_ACK_BUF*cnf, const short token, void *usrData);

META_RESULT  __stdcall SP_META_GPS_Open(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_GPS_Open_r(const int meta_handle,unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_GPS_Close(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_GPS_Close_r(const int meta_handle,unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_GPS_SendCommand(unsigned int ms_timeout,const GPS_CMD *req, GPS_ACK_BUF *cnf,META_GPS_SEND_COMMAND_CNF cb);
META_RESULT  __stdcall SP_META_GPS_SendCommand_r(const int meta_handle,unsigned int ms_timeout,const GPS_CMD *req, GPS_ACK_BUF *cnf,META_GPS_SEND_COMMAND_CNF cb);
META_RESULT  __stdcall SP_META_GPS_SendCommand_Internal(unsigned int ms_timeout,const GPS_CMD *req,GPS_ACK_BUF *cnf,META_GPS_SEND_COMMAND_CNF cb,void * usrData);
META_RESULT  __stdcall SP_META_GPS_SendCommand_Internal_r(const int meta_handle,unsigned int ms_timeout,const GPS_CMD *req, GPS_ACK_BUF *cnf,META_GPS_SEND_COMMAND_CNF cb,void *usrData);
META_RESULT  __stdcall SP_META_GPS_SendCommandMultiThread(unsigned int ms_timeout,const GPS_CMD *req, GPS_ACK_BUF *cnf,META_GPS_SEND_COMMAND_CNF cb,void *usrData);
META_RESULT  __stdcall SP_META_GPS_SendCommandMultiThread_r(const int meta_handle,unsigned int ms_timeout,const GPS_CMD *req, GPS_ACK_BUF *cnf,META_GPS_SEND_COMMAND_CNF cb,void *usrData);




typedef struct
{
    unsigned int    dwSDHCIndex; // MSDC1/2/3. if dwSDHCIndex no equal 1/2/3 auto test.
}FT_SDCARD_REQ;

typedef struct
{
    unsigned char            DatBusWidth;
    int            IsSecuredMode;
    unsigned short    CardTpye;
    unsigned int    SizeOfProtectErea;
    unsigned char            SpeedClass;
    unsigned char            Performance_move;
    unsigned char            AUSize;
    unsigned char    status;
}FT_SDCARD_CNF;

META_RESULT  __stdcall SP_META_SDCARD_Query(unsigned int ms_timeout,const FT_SDCARD_REQ *req, FT_SDCARD_CNF *cnf);
META_RESULT  __stdcall SP_META_SDCARD_Query_r(const int meta_handle,unsigned int ms_timeout,const FT_SDCARD_REQ *req, FT_SDCARD_CNF *cnf);

typedef struct
{
    unsigned long    time_duration;
}LCDFt_REQ;

typedef struct
{
    int status;
}LCDFt_CNF;

META_RESULT __stdcall SP_META_LcdColorTest(unsigned int ms_timeout, LCDFt_REQ *req, LCDFt_CNF *cnf);
META_RESULT __stdcall SP_META_LcdColorTest_r(const int meta_handle, unsigned int ms_timeout, LCDFt_REQ *req, LCDFt_CNF *cnf);

//Low Power
typedef enum
{
    WM_CMD_POWER_DOWN =0, 
    WM_CMD_POWER_UP,
}WM_LOW_POWER_TYPE;

META_RESULT __stdcall SP_META_LowPowerTest(unsigned int ms_timeout, WM_LOW_POWER_TYPE *ptype /*in & out*/);
META_RESULT __stdcall SP_META_LowPowerTest_r(int meta_handle, unsigned int ms_timeout, WM_LOW_POWER_TYPE *ptype /*in & out*/);


META_RESULT __stdcall SP_META_ReadUuid(unsigned int ms_timeout, unsigned int *high, unsigned int *low);
META_RESULT __stdcall SP_META_ReadUuid_r(int meta_handle, unsigned int ms_timeout, unsigned int *high, unsigned int *low);

META_RESULT __stdcall SP_META_WriteUuid(unsigned int ms_timeout, unsigned int high, unsigned int low);
META_RESULT __stdcall SP_META_WriteUuid_r(int meta_handle, unsigned int ms_timeout, unsigned int high, unsigned int low);


typedef enum
{
    GET_MODE_STA = 0,
    SET_MODE_0,  // 00
    SET_MODE_1,  // 01
    SET_MODE_2,  // 10
    SET_MODE_3,  // 11

    GET_DIR_STA, 
    SET_DIR_IN,  // 0
    SET_DIR_OUT, // 1
    
    GET_PULLEN_STA,  
    SET_PULLEN_DISABLE,  // 0
    SET_PULLEN_ENABLE,   // 1
    
    GET_PULL_STA,
    SET_PULL_DOWN,  // 0
    SET_PULL_UP,    // 1
    
    GET_INV_STA,
    SET_INV_ENABLE,  // 1
    SET_INV_DISABLE, // 0
    
    GET_DATA_IN,
    GET_DATA_OUT,
    SET_DATA_LOW,  // 0
    SET_DATA_HIGH, // 1

    SET_MODE_4,
    SET_MODE_5,
    SET_MODE_6,
    SET_MODE_7,


}GPIO_OP;

typedef struct
{
    unsigned int    pin;    // pin number
    GPIO_OP    op;        // operation to GPIO    
}GPIO_REQ;

typedef struct
{
    unsigned int    status;
    unsigned long    data;
}GPIO_CNF;

META_RESULT __stdcall SP_META_GpioCtrl(unsigned int ms_timeout, const GPIO_REQ *req, GPIO_CNF *cnf);
META_RESULT __stdcall SP_META_GpioCtrl_r(int meta_handle, unsigned int ms_timeout, const GPIO_REQ *req, GPIO_CNF *cnf);


META_RESULT __stdcall SP_META_Nvram_Backup(unsigned int ms_timeout, const char *file1, const char *file2);
META_RESULT __stdcall SP_META_Nvram_Backup_r(int meta_handle, unsigned int ms_timeout, const char *file1, const char *file2);
META_RESULT __stdcall SP_META_Nvram_Backup_YUSU(unsigned int ms_timeout, const char *file);
META_RESULT __stdcall SP_META_Nvram_Backup_YUSU_r(int meta_handle, unsigned int ms_timeout, const char *file);

META_RESULT __stdcall SP_META_Nvram_Restore(unsigned int ms_timeout, const char *file1, const char *file2);
META_RESULT __stdcall SP_META_Nvram_Restore_r(int meta_handle, unsigned int ms_timeout, const char *file1, const char *file2);
META_RESULT __stdcall SP_META_Nvram_Restore_YUSU(unsigned int ms_timeout, const char *file);
META_RESULT __stdcall SP_META_Nvram_Restore_YUSU_r(int meta_handle, unsigned int ms_timeout, const char *file);

META_RESULT __stdcall SP_META_Clean_Boot(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_Clean_Boot_r(int meta_handle,unsigned int ms_timeout);

META_RESULT __stdcall SP_META_Mode_Lock(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_Mode_Lock_r(int meta_handle,unsigned int ms_timeout);

typedef struct
{
    char mldrVersion[50];
    char ebootVersion[50];
    char flashVersion[50];
    unsigned short mldrCheckSum;
    unsigned short ebootCheckSum;
    unsigned short flashCheckSum;
    unsigned char status;
}FT_BTLDR_FLASH_VER_CNF;

META_RESULT __stdcall SP_META_Btldr_Flash_Ver(unsigned int ms_timeout, FT_BTLDR_FLASH_VER_CNF *cnf);
META_RESULT __stdcall SP_META_Btldr_Flash_Ver_r(int meta_handle, unsigned int ms_timeout, FT_BTLDR_FLASH_VER_CNF *cnf);


META_RESULT __stdcall SP_META_Nvram2Bin(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_Nvram2Bin_r(int meta_handle, unsigned int ms_timeout);




#define MD_FRAME_MAX_LEN 256

typedef struct
{
    short    frame_length;
    char    frame_data[MD_FRAME_MAX_LEN]; 
}MD_FRAME;

typedef struct _AUDIO_VOLUME_CUSTOM_STRUCT
{
    unsigned char audiovolume_ring[3][7];
    unsigned char audiovolume_key[3][7];
    unsigned char audiovolume_mic[3][7];
    unsigned char audiovolume_fmr[3][7];
    unsigned char audiovolume_sph[3][7];
    unsigned char audiovolume_sid[3][7];
    unsigned char audiovolume_media[3][7];
    unsigned char audiovolume_matv[3][7];
} AUDIO_VOLUME_CUSTOM_STRUCT;

typedef struct 
{
    short speech_input_FIR_coeffs[8][45];
    short speech_output_FIR_coeffs[8][6][45];
    short select_FIR_output_index[8];
    short select_FIR_intput_index[8];
    short speech_mode_para[8][16];
    
}AUDIO_PARAM_MED_STRUCT;

typedef struct
{
    unsigned short speech_mode_wb_para[8][16];
    short sph_wb_in_fir[6][90];
    short sph_wb_out_fir[6][90];
    
}AUDIO_CUSTOM_WB_PARAM_STRUCT;

META_RESULT __stdcall SP_META_SwitchUsbChnl(int enter, const WM_META_ConnectInMETA_Req *req, int *p_bootstop, WM_META_ConnectInMETA_Report *p_report);
META_RESULT __stdcall SP_META_SwitchUsbChnl_r(int meta_handle, int enter, const WM_META_ConnectInMETA_Req *req, int *p_bootstop, WM_META_ConnectInMETA_Report *p_report);

META_RESULT  __stdcall SP_META_NVRAM_Compose_AudioVlomeCustomStruct(AUDIO_VOLUME_CUSTOM_STRUCT *param, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_AudioVlomeCustomStruct(AUDIO_VOLUME_CUSTOM_STRUCT *param, const char *buf, const int buf_len);

META_RESULT  __stdcall SP_META_NVRAM_Compose_AudioMedStruct(AUDIO_PARAM_MED_STRUCT *param, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_AudioMedStruct(AUDIO_PARAM_MED_STRUCT *param, const char *buf, const int buf_len);

META_RESULT  __stdcall SP_META_NVRAM_Compose_AudioCustomWBStruct(AUDIO_CUSTOM_WB_PARAM_STRUCT *param, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_AudioCustomWBStruct(AUDIO_CUSTOM_WB_PARAM_STRUCT *param, const char *buf, const int buf_len);


META_RESULT __stdcall SP_META_Nvram_Backup_Custom(unsigned int ms_timeout, 
                                                    const char *file1, const char *file2,const char * buffer,  int count, int mode );

META_RESULT __stdcall SP_META_Nvram_Backup_Custom_r(int meta_handle, unsigned int ms_timeout, 
                                        const char *file1, const char *file2,const char * buffer,  int count, int mode );


META_RESULT __stdcall SP_META_Customer_Func(int ms_timeout, const unsigned char *data_in, const int data_in_len, int type, unsigned char dummy_in , unsigned char *dummy_out, unsigned char *data_out, int *data_out_len);
META_RESULT __stdcall SP_META_Customer_Func_r(int meta_handle, int ms_timeout, const unsigned char *data_in, const int data_in_len, int type, unsigned char dummy_in, unsigned char *dummy_out,unsigned char *data_out, int *data_out_len);

//For parameter: unsigned char* ChipID, the length should be greater than or equal to 17.
META_RESULT  __stdcall SP_META_GetChipID(unsigned int  ms_timeout, unsigned char* ChipID);
META_RESULT  __stdcall SP_META_GetChipID_r(const int meta_handle, unsigned int  ms_timeout, unsigned char* ChipID);

META_RESULT  __stdcall SP_META_MSensorTest(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_MSensorTest_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_CTPTest(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_CTPTest_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_ALSPSTest(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_ALSPSTest_r(const int meta_handle, unsigned int  ms_timeout);




//-----------------------------------------------------//
//-----------------------NFC--------------------------//
//-----------------------------------------------------//

#define MIFARE4K_LEN        (16)
#define MIFARE1K_LEN        (4)
#define MIFARE1K_PAGE       (4)
#define UID_DATA_LEN        (7)
#define NDEF_DATA_LEN       (256)
#define RAW_COMM_DATA_LEN   (256) 
#define TAG_RAW_DATA_LEN    (256) 
#define TAG_WRITE_MAXDATA   (512)
#define UID_LEN             (10)
#define PNFC_DATA            (256)
#define VERSION_MW            (20)
#define URL_DATA            (64)
#define MTK_NFC_MAX_SE_NUM    (3)

//  NFC: REQ/CNF structure definition
typedef struct 
{
    unsigned int    nfc_enable;               /* feature enable or disable , 0: disable, 1:enable */
    unsigned int    debug_enable;        /*debug enable or disable , 0: disable, 1:enable */ 
    unsigned int    sw_protocol;           /*SW protocol,  0: SW stack, 1: raw data mode */
    unsigned int     get_capabilities;      /*get chip capability 0: no request, 1: request*/

} NFC_SETTING_REQ_S;


typedef struct
{  
    unsigned int    status;                        /* return setting result*/  
    unsigned int    nfc_enable;               /* return feature enable or disable */ 
    unsigned int    debug_enable;        /* return debug enable or disable*/  
    unsigned int    sw_protocol;           /* return SW protocol,*/  
    unsigned int    get_capabilities;      /* return chip capability*/       
    unsigned int    sw_ver;                      /* return software version*/   
    unsigned int    hw_ver;                     /* return hardware version*/  
    unsigned int    fw_ver;                       /* return firmware version*/  
    unsigned int    reader_mode;          /* return support  format bitmap*/  
    unsigned int    card_mode;              /* return support  format bitmap */

} NFC_SETTING_CNF_S;


typedef struct
{  
    unsigned int    reg_type;               /* register notification bitmap */      
    
} NFC_REGNOTIFY_REQ_S;

// Nina modified
typedef struct
{  
    unsigned int     status;          /* return setting result,0 success, other: fail*/  
    
    unsigned int     se;                /* secure element detect, 0: no detect, 1: se typ1 , 2: se type 2*/  
    unsigned int     se_status; /* secure element status, 0:off, 1:Virtual, 2:Wired*/  
    unsigned int     se_type;      /* secure element type, bitmap*/  
    unsigned int     length; /* length of data*/
    
} NFC_REGNOTIFY_CNF_S;


typedef struct
{  
    unsigned int     set_SEtype;      /* setting se  type, 0:off, 1:Virtual, 2:Wired */
    
} NFC_SECURE_REQ_S;

// Nina add 
typedef struct
{  
     unsigned int     status;          /* return setting result, 0:sucess*/
    
} NFC_SECURE_CNF_S;

typedef struct 
{  
    unsigned int    tag_type;               /* return detected tag type*/  
    unsigned int    card_type;            /* card type, 1: Mifare classic 1K*/                                                              
                                                             /* 2: Mifare classic 4K*/                                                              
                                                             /* 3: NDEF*/  
    unsigned int    uid;                        /* card Uid*/  
    unsigned int    sak;                       /* card sak*/               
    unsigned int    atag;                    /* card atag*/  
    unsigned int    appdata;             /* card appdata */ 
    unsigned int    maxdatarate;    /* card maxdatarate */

} NFC_TAG_INFO_S;


typedef struct 
{  
    unsigned int    p2p_type;               /* return detected tag type*/

} NFC_P2P_INFO_S;


typedef union
{  
    NFC_TAG_INFO_S    nfc_tag_info;  
    NFC_P2P_INFO_S    nfc_p2p_info;  

} NFC_DEVICE_INFO_U;


typedef struct 
{  
    unsigned int     status;          /* return setting result, 0:sucess */ 
    unsigned char    type;           /*1 : Tag ,2: p2p */ 
    NFC_DEVICE_INFO_U    nfc_device_info;
    
} NFC_DISCOVERY_CNF_S;

typedef struct 
{
  unsigned int    dis_type;               /* discovery notification bitmap */
  unsigned int duration;                 /* set duration,(unit:ms) */  
    
} NFC_DISCOVERY_REQ_S;


typedef struct
{  
    unsigned int    address;               /*  */ 
    unsigned short  data[MIFARE1K_LEN];

} NFC_MIFARE1K_DATA_S;


typedef struct
{  
    unsigned int    sector;               /*  */ 
    unsigned int    block;  
    unsigned short data[MIFARE4K_LEN];

} NFC_MIFARE4K_DATA_S;


typedef struct
{  
    unsigned  int  ndef_type;  
    unsigned  int  length;        
    unsigned short data[NDEF_DATA_LEN];

} NFC_NDEF_DATA_S;


typedef union
{   
    NFC_MIFARE1K_DATA_S    nfc_Mifare1K_data;   
    NFC_MIFARE4K_DATA_S    nfc_Mifare4K_data;   
    NFC_NDEF_DATA_S    nfc_ndef_data;

} NFC_RW_DATA_U;


typedef struct 
{  
    unsigned int    read_type;               /*  which type want to read*/  
                                                                /* 1 for Mifare classic 1K */                                                                 
                                                                /* 2 for Mifare classic 4K */                                                                 
                                                                /* 3 for NDEF type*/  
    unsigned int    address;                  /* for Mifare classic 1K used*/  
    unsigned int    sector;                    /* for Mifare classic 4K used*/  
    unsigned int    block;                     /* for Mifare classic 4K used*/
    unsigned char   AuthentificationKey;       /* KEY_A:0 , KEY_B:1 */

} NFC_TAGREAD_REQ_S;


typedef struct 
{  
    unsigned int    status;               /*  return read status, 0 success*/  
    unsigned int    type;                 /*1 : Mifare classic 1K ,2: Mifare classic 4K, 3: NDEF */ 
    NFC_RW_DATA_U    nfc_read_data;
    
} NFC_TAGREAD_CNF_S;

typedef struct 
{  
    unsigned int    write_type;               /*  which type want to write*/  
    NFC_RW_DATA_U    nfc_write_data;

} NFC_TAGWRITE_REQ_S;

//Nina add
typedef enum {
    nfc_tag_DEFAULT    = 0,
    nfc_tag_MIFARE_UL  = 1,
    nfc_tag_MIFARE_STD = 2,
    nfc_tag_ISO1443_4A = 3,
    nfc_tag_ISO1443_4B = 4,
    nfc_tag_JEWWL      = 5,
    nfc_tag_NFC        = 6,
    nfc_tag_FELICA     = 7,
    nfc_tag_ISO15693   = 8,
    nfc_NDEF           = 9
}NFC_TAG_TYPE;


//Nina modify
typedef struct 
{  
    unsigned int    status;                /*  return read status, 0 success*/                 
    unsigned int    wrtie_type;      /*  return writed type*/
    //NFC_TAG_TYPE     wrtie_type;   
    
} NFC_TAGWRITE_CNF_S;

typedef struct 
{  
    unsigned int    action;     /* 1: disconnect, */
    
} NFC_TAGDISCONNECT_REQ_S;

// Nina add
typedef struct
{
    unsigned int    status;      /*0: success*/

}NFC_TAGDISCONNECT_CNF_S;

typedef struct 
{  
    unsigned int    action;      /* 1: format to Ndef, */
    
} NFC_TAGFORMAT2NDEF_REQ_S;

// Nina add
typedef struct 
{  
   unsigned int    status;      /*0: success*/
    
} NFC_TAGFORMAT2NDEF_CNF_S;


typedef struct
{
  unsigned int   length;
  unsigned char data[TAG_RAW_DATA_LEN];
} NFC_TAGRAWCOM_REQ_typeA;

typedef struct 
{
  unsigned int   length;
  unsigned char data[TAG_RAW_DATA_LEN];
} NFC_TAGRAWCOM_REQ_typeB;

typedef struct 
{
  unsigned int   length;
  unsigned char  data[TAG_RAW_DATA_LEN];
}NFC_TAGRAWCOM_REQ_typeJewel;

typedef struct 
{
  unsigned int   length;
  unsigned char  data[TAG_RAW_DATA_LEN];
}NFC_TAGRAWCOM_REQ_typeFelica;

typedef union 
{
  NFC_TAGRAWCOM_REQ_typeA  req_data_typeA;
  NFC_TAGRAWCOM_REQ_typeB  req_data_typeB;
  NFC_TAGRAWCOM_REQ_typeJewel req_data_typeJewel;
  NFC_TAGRAWCOM_REQ_typeFelica req_data_typeFelica;

} NFC_TAGRAWCOM_REQ_DATA_U;

typedef struct 
{  
    unsigned int    action;     /*1: enable raw command */ 
    unsigned int    length;     /*Length of written data. Unit is byte. The data is stored in the Meta peer buffer*/

    // Nina add
    NFC_TAGRAWCOM_REQ_DATA_U req_data;   
    
} NFC_TAGRAWCOMM_REQ_S;


typedef struct
{
  unsigned int   length;
  unsigned char data[TAG_RAW_DATA_LEN];

} NFC_TAGRAWCOM_CNF_typeA;

typedef struct
{
  unsigned int   length;
  unsigned char data[TAG_RAW_DATA_LEN];

} NFC_TAGRAWCOM_CNF_typeB;

typedef struct
{
  unsigned int   length;
  unsigned char  data[TAG_RAW_DATA_LEN];

}NFC_TAGRAWCOM_CNF_typeJewel;

typedef struct 
{
  unsigned int   length;
  unsigned char  data[TAG_RAW_DATA_LEN];

}NFC_TAGRAWCOM_CNF_typeFelica;


typedef union 
{
  NFC_TAGRAWCOM_CNF_typeA  rsp_data_typeA;
  NFC_TAGRAWCOM_CNF_typeB  rsp_data_typeB;
  NFC_TAGRAWCOM_CNF_typeJewel  rsp_data_typeJewel;
  NFC_TAGRAWCOM_CNF_typeFelica rsp_data_typeFelica;

} NFC_TAGRAWCOM_CNF_DATA_U;


// Nina add
typedef struct 
{
  //NFC_TAG_TYPE    type;        /*Type A / Type B*/
  unsigned int    type;
  unsigned int    status;      /*0 : success*/
  NFC_TAGRAWCOM_CNF_DATA_U   rsp_data;
} NFC_TAGRAWCOMM_CNF_S;

typedef struct 
{  
    unsigned int    action;      /* 1 : send, 2 receive*/  
    unsigned int    length;      /*Length of written data. Unit is byte. The data is stored in the Meta peer buffer*/

} NFC_P2PCOMM_REQ_S;

// Nina add
typedef struct 
{  
   unsigned int    status;   /* 0:success*/
   unsigned int    length;   /*Length of written data. Unit is byte.*/

} NFC_P2PCOMM_CNF_S;

typedef struct 
{  
    unsigned int    action;      /*1:start test, 0:stop test*/  
    unsigned int    length;      /*Length of written data. Unit is byte. The data is stored in the Meta peer buffer*/
    
} NFC_RDCOMM_REQ_S;

//Nina add
typedef struct 
{  
     unsigned int    status;   /*Test result, 0:success*/
    unsigned int    length;   /*Length of written data. Unit is byte.*/
    
} NFC_RDCOMM_CNF_S;

typedef struct 
{   
    unsigned int   type;           /*Test type: currently, always set 1*/   
    unsigned int   action;          /*Test action, 1: start test, 0:stop test*/   
    
} NFC_SCRIPT_REQ_S;

typedef struct 
{   
    signed int   result;         /*Test result,0 :success*/

} NFC_SCRIPT_CNF_S;

typedef struct { 
    unsigned int   type;    /*Test type: currently, always set 1*/
    unsigned int   action;    /*Test action, 1: start test, 0:stop test*/  
    unsigned char  modulation_type;   /* 0:type A, 1:type B, 2:type F, 3:No Modulation */
    unsigned char  bitrate;           /* 0:106kbps, 1:212kbps, 2:424kbps */
} NFC_TXALWAYS_REQ_S;


typedef struct { 
    unsigned int   type;           /*Test type: currently, always set 1*/
    unsigned int   action;           /*Test action, 1: start test, 0:stop test*/  
    unsigned short  technology;    /*bitmask: MifareUL=bit 0, MifareStd=bit1, ISO14443_4A=bit 2, ISO14443_4B=bit 3, Jewel=bit 4, Felica=bit 5, ISO15693=bit 6 */
    unsigned short  protocols;     /*bitmask: Iso14443A=bit 0, Iso14443B=bit 1, Felica212=bit 2, Felica424=bit 3, Iso15693=bit 4 */
} NFC_CARDEMULATION_REQ_S;

typedef struct 
{   
    unsigned int   type;                /*Test type: currently, always set 1*/   
    unsigned int   action;          /*Test action, 1: start test, 0:stop test*/   
    unsigned int   uid_type;        /* 1: uid 4bytes, 2 : uid 7bytes*/       
    unsigned short data[UID_DATA_LEN];       /*uid content*/
    
} NFC_SCRIPTUID_REQ_S;

typedef struct 
{   
    signed int   result;                 /*Test result, 0: success*/   
    unsigned int uid_type;         /* 1: uid 4bytes, 2 : uid 7bytes */       
    unsigned short data[UID_DATA_LEN];      /*uid content*/
    
} NFC_SCRIPTUID_CNF_S;

typedef struct { 
    unsigned int   type;           
    unsigned int   action;           
    unsigned short  technology;    
    unsigned short  protocols; 
} NFC_CARDMODETEST_REQ_S;

//Chunlan 2013-4-28

typedef enum {
    nfc_ndef_lang_DEFAULT = 0,
    nfc_ndef_lang_DE = 1,
    nfc_ndef_lang_EN = 2,
    nfc_ndef_lang_FR = 3
} NFC_NDEF_LANG_TYPE;

typedef enum {
    nfc_ndef_type_uri = 0,
    nfc_ndef_type_text,
    nfc_ndef_type_sp,
    nfc_ndef_type_others,
} NFC_NDEF_TYPE;

typedef struct {
    char   Name[64];
    char   Compagny[64];
    char   Titlep[64];
    char   Tel[32];
    char   Email[64];
    char   Adress[128];
    char   PostalCode[32];
    char   City[64];
    char   CompagnyUrl[64];
} Vcard;

typedef struct {
    unsigned char  Compagny[64];
    unsigned short CompagnyLength;
    unsigned char  CompagnyUrl[64];
    unsigned short CompagnyUrlLength;
} SmartPoster;

typedef struct {
    unsigned short DataLength;
    unsigned char  data[TAG_WRITE_MAXDATA];
} Text_S;

typedef struct {
    unsigned short URLLength;
    unsigned char  URLData[URL_DATA];
} URL_S;

typedef struct {
    char   EXTTagType[64];
    char   EXTData[TAG_WRITE_MAXDATA];
    unsigned short EXTLength;
} EXTTag;

typedef union {
//    SmartPoster  SP_Data;
//    Vcard        VC_Data;
    Text_S         TX_Data;
    URL_S          URL_Data;
//    EXTTag       EXT_Data;
} NFC_TAG_WRITE_NDEF_DATA;

typedef struct {
    unsigned int                    length;
//    NFC_NDEF_TYPE             ndef_type;
    unsigned int ndef_type;
//    NFC_NDEF_LANG_TYPE        language;
    unsigned int language;
    NFC_TAG_WRITE_NDEF_DATA   ndef_data;
} NFC_TAG_WRITE_NDEF;

typedef struct {
    unsigned int action;          /* Action, please refer ENUM of EM_ACTION*/
    unsigned int supporttype;     /* supporttype, please refer BITMAP of EM_ALS_READER_M_TYPE*/
    unsigned int typeA_datarate;  /* TypeA,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    unsigned int typeB_datarate;  /* TypeB,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    unsigned int typeV_datarate;  /* TypeV,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    unsigned int typeF_datarate;  /* TypeF,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    unsigned int typeV_subcarrier;/* 0: subcarrier, 1 :dual subcarrier*/
//    unsigned int typeV_codingmode;/*0:1 out of 4, 1: 1 out of 256*/
} NFC_EM_ALS_READERM_REQ_S;

typedef struct {
    int  result;          /* 0:Success,Tag connected, 1: Fail, 2:Tag disconnected*/
    unsigned int isNDEF;          /* 1:NDEF, 0: Non-NDEF*/
    unsigned int UidLen;
    unsigned char  Uid[32];
} NFC_EM_ALS_READERM_NTF_S;

typedef struct {
    int  result;          /* 0:Success, 1: Fail,*/
} NFC_EM_ALS_READERM_CNF_S;

typedef struct {
    int  action;          /* Action, please refer ENUM of EM_OPT_ACTION*/   
    NFC_TAG_WRITE_NDEF ndef_write;
} NFC_EM_ALS_READERM_OPT_REQ_S;

typedef struct {
    //   NFC_NDEF_TYPE ndef_type;
    unsigned int   length;
    unsigned int ndef_type;
    unsigned char  recordId[32];
    unsigned char  lang[3];
    unsigned char  recordFlags;
    unsigned char  recordTnf;
    unsigned char  data[512];
} NFC_TAG_READ_NDEF;

typedef struct {
    unsigned int  result;          /* 0:Success,1:Fail*/
    NFC_TAG_READ_NDEF ndef_read;
} NFC_EM_ALS_READERM_OPT_CNF_S;

/* --------------------------------------------------------*/
/* P2P_MODE_RELATED                                        */
/* --------------------------------------------------------*/
typedef struct {
    unsigned int action;          /* Action, please refer ENUM of EM_ACTION*/
    unsigned int supporttype;     /* supporttype, please refer BITMAP of EM_ALS_READER_M_TYPE*/
    unsigned int typeA_datarate;  /* TypeA,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    unsigned int typeF_datarate;  /* TypeV,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    unsigned int mode;            /* BITMAPS bit0: Passive mode, bit1: Active mode, please refer BITMAP of EM_P2P_MODE*/
    unsigned int role;            /* BITMAPS bit0: Initator, bit1: Target, please refer BITMAP of EM_P2P_ROLE*/
    unsigned int isDisableCardM;  /* 0: , 1: disable card mode*/
} NFC_EM_ALS_P2P_REQ_S;

typedef struct {
    int  link_status;     /* 1:llcp link is up,0:llcp link is down*/
    //UINT32  datalen;
    //UINT8 data[256];
} NFC_EM_ALS_P2P_NTF_S;

typedef struct {
    int  result;          /* 0:Success,1:Fail*/
} NFC_EM_ALS_P2P_CNF_S;

/* -------------------------------------------------------- */
/* CARD_MODE_RELATED                                        */
/* -------------------------------------------------------- */
typedef struct {
    
    unsigned int seid;
    unsigned int status;
    unsigned int type;
    unsigned int connecttype;
    unsigned int lowpowermode;
    unsigned int bpf;
    
} mtk_nfc_tool_se_info;

typedef struct {
    
    unsigned int status;
    mtk_nfc_tool_se_info SeInfor[MTK_NFC_MAX_SE_NUM];
    unsigned char SeCount;
    
} NFC_EM_SE_GET_LIST;


typedef struct {
    unsigned int action;          /* Action, please refer ENUM of EM_ACTION*/
    unsigned int SWNum;           /* SWNum, please refer BITMAP of EM_ALS_CARD_M_SW_NUM*/
    unsigned int supporttype;     /* supporttype, please refer BITMAP of EM_ALS_READER_M_TYPE*/
    unsigned int fgvirtualcard;   /* 1:enable virtual card, 0:disable virtual card(default)   */
} NFC_EM_ALS_CARDM_REQ_S;

typedef struct {
    int  result;          /*0:Success,1:Fail*/
} NFC_EM_ALS_CARDM_CNF_S;

/* -------------------------------------------------------- */
/* POLLING_MODE_RELATED                                     */
/* -------------------------------------------------------- */
typedef struct {
    unsigned int action;          /* Action, please refer ENUM of EM_ACTION*/
    unsigned int phase;           /* 0:Listen phase, 1:Pause phase*/
    unsigned int Period;
    unsigned int enablefunc;      /* enablefunc, please refer BITMAP of EM_ENABLE_FUNC*/
    NFC_EM_ALS_P2P_REQ_S     p2pM;
    NFC_EM_ALS_CARDM_REQ_S   cardM;
    NFC_EM_ALS_READERM_REQ_S readerM;
} NFC_EM_POLLING_REQ_S;

typedef struct {
    int  result;          /* 0:Success,1:Fail*/
} NFC_EM_POLLING_CNF_S;

typedef union {
    NFC_EM_ALS_P2P_NTF_S     p2p;
    NFC_EM_ALS_CARDM_CNF_S   card;
    NFC_EM_ALS_READERM_NTF_S reader;
} NFC_EM_POLLING_FUNC_NTF_S;

typedef struct {
    int detecttype;       /* enablefunc, please refer ENUM of EM_ENABLE_FUNC*/
    NFC_EM_POLLING_FUNC_NTF_S ntf;
} NFC_EM_POLLING_NTF_S;

/* -------------------------------------------------------- */
/* TX carrier signal                                        */
/* -------------------------------------------------------- */
typedef struct {
    unsigned int action;          /* Action, please refer ENUM of EM_ACTION*/
} NFC_EM_TX_CARR_ALS_ON_REQ_S;

typedef struct {
    unsigned int result;          /* 0:Success,1:Fail*/
} NFC_EM_TX_CARR_ALS_ON_CNF_S;

/* -------------------------------------------------------- */
/* CARD_MODE_RELATED                                        */
/* -------------------------------------------------------- */

typedef struct {
    unsigned int action;          /* Action, please refer ENUM of EM_ACTION*/
    unsigned int supporttype;     /* supporttype, please refer BITMAP of EM_ALS_READER_M_TYPE*/
    //UINT32 typeA_datarate;  /* TypeA,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    //UINT32 typeB_datarate;  /* TypeB,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
    unsigned int typeF_datarate;  /* TypeF,datarate, please refer BITMAP of EM_ALS_READER_M_SPDRATE*/
} NFC_EM_VIRTUAL_CARD_REQ_S;

typedef struct {
    unsigned int result;          /* 0:Success,1:Fail*/
} NFC_EM_VIRTUAL_CARD_CNF_S;

/* --------------------------------------------------------*/
/* PNFC command                                            */
/* --------------------------------------------------------*/
typedef struct {
    unsigned int   action;          /* Action, please refer ENUM of EM_ACTION*/
    unsigned int   datalen;
    unsigned char  data[256];
} NFC_EM_PNFC_RAW_REQ_S;

typedef struct  
{
    NFC_EM_PNFC_RAW_REQ_S pnfc_req;
} NFC_EM_PNFC_REQ_S;

typedef struct {
    unsigned int result;          /* 0:Success,1:Fail*/
    unsigned int datalen;
    unsigned char  data[256];
} NFC_EM_PNFC_CNF_S;


/* --------------------------------------------------------*/
/* Version                                                 */
/* --------------------------------------------------------*/

typedef struct {
    unsigned short fw_ver;
    unsigned short hw_ver;
    char   mw_ver[VERSION_MW];
} NFC_SW_VERSION_CNF_S;

/* --------------------------------------------------------*/
/* HW Test Tool Version                                                 */
/* --------------------------------------------------------*/

typedef struct {
    unsigned int version;
} NFC_META_CHIP_VER_CNF_S;

/* --------------------------------------------------------*/
/* Option setting                                          */
/* --------------------------------------------------------*/
typedef struct
{
    unsigned short   forceDownLoad; 
    unsigned short   TagAutoPresenceChk; 
} NFC_TEST_MODE_SETTING_REQ_S;

typedef struct
{
    int result;
} NFC_TEST_MODE_SETTING_CNF_S;

/* --------------------------------------------------------*/
/* Loopback set                                            */
/* --------------------------------------------------------*/
typedef struct
{
    char   action;
} NFC_LOOPBACK_TEST_REQ_S;

typedef struct
{
    int result;
} NFC_LOOPBACK_TEST_CNF_S;

/* --------------------------------------------------------*/
/* SWP Test                                                */
/* --------------------------------------------------------*/
typedef struct { 
    int  action;
    int  SEmap;
} NFC_FM_SWP_TEST_REQ_S;

typedef struct {
    int result;
} NFC_FM_SWP_TEST_CNF_S;
//  NFC: Callback function definition
//typedef void (__stdcall * NFC_DISCOVERY_CB)(const NFC_DISCOVERY_CNF * pDisCnf, const short token, void *usrData);

typedef void (__stdcall *META_NFC_NOTIFY_CNF)(const NFC_EM_ALS_READERM_NTF_S *cnf);
typedef void (__stdcall *META_NFC_P2P_NOTIRY)(const NFC_EM_ALS_P2P_NTF_S *p2p_cnf);
typedef void (__stdcall *META_NFC_POOLINGLOOP_NOTIFY)(const NFC_EM_POLLING_NTF_S *pooling_loop_cnf);

//  NFC: API declaration
META_RESULT  __stdcall SP_META_NFC_Setting(unsigned int  ms_timeout, NFC_SETTING_REQ_S * pSetReq, NFC_SETTING_CNF_S * pSetCnf);
META_RESULT  __stdcall SP_META_NFC_Setting_r(const int meta_handle, unsigned int  ms_timeout, NFC_SETTING_REQ_S * pSetReq, NFC_SETTING_CNF_S * pSetCnf);
META_RESULT  __stdcall SP_META_NFC_RegNotify(unsigned int  ms_timeout, NFC_REGNOTIFY_REQ_S * pRegReq, NFC_REGNOTIFY_CNF_S * pRegCnf);
META_RESULT  __stdcall SP_META_NFC_RegNotify_r(const int meta_handle, unsigned int  ms_timeout, NFC_REGNOTIFY_REQ_S * pRegReq, NFC_REGNOTIFY_CNF_S * pRegCnf);
//META_RESULT  __stdcall SP_META_NFC_SecureElement(unsigned int  ms_timeout, NFC_SECURE_REQ_S * pSecReq);
//META_RESULT  __stdcall SP_META_NFC_SecureElement_r(const int meta_handle, unsigned int  ms_timeout, NFC_SECURE_REQ_S * pSecReq);
META_RESULT  __stdcall SP_META_NFC_SecureElement(unsigned int  ms_timeout, NFC_SECURE_REQ_S * pSecReq , NFC_SECURE_CNF_S * pSecCnf);
META_RESULT  __stdcall SP_META_NFC_SecureElement_r(const int meta_handle, unsigned int  ms_timeout, NFC_SECURE_REQ_S * pSecReq ,NFC_SECURE_CNF_S * pSecCnf);
//META_RESULT  __stdcall SP_META_NFC_Discovery(unsigned int  ms_timeout, const NFC_DISCOVERY_CB cb, short *token, void *usrData);
//META_RESULT  __stdcall SP_META_NFC_Discovery_r(const int meta_handle, unsigned int  ms_timeout, const NFC_DISCOVERY_CB cb, short *token, void *usrData);
//META_RESULT  __stdcall SP_META_NFC_Discovery(unsigned int  ms_timeout, NFC_DISCOVERY_REQ * pDisReq, const NFC_DISCOVERY_CB cb, short *token, void *usrData);
//META_RESULT  __stdcall SP_META_NFC_Discovery_r(const int meta_handle, unsigned int  ms_timeout, NFC_DISCOVERY_REQ * pDisReq, const NFC_DISCOVERY_CB cb, short *token, void *usrData);
META_RESULT  __stdcall SP_META_NFC_Discovery(unsigned int  ms_timeout, NFC_DISCOVERY_REQ_S * pDisReq, NFC_DISCOVERY_CNF_S * pDisCnf);
META_RESULT  __stdcall SP_META_NFC_Discovery_r(const int meta_handle, unsigned int  ms_timeout, NFC_DISCOVERY_REQ_S * pDisReq, NFC_DISCOVERY_CNF_S * pDisCnf);
META_RESULT  __stdcall SP_META_NFC_TagRead(unsigned int  ms_timeout, NFC_TAGREAD_REQ_S * pTagReadReq, NFC_TAGREAD_CNF_S * pTagReadCnf);
META_RESULT  __stdcall SP_META_NFC_TagRead_r(const int meta_handle, unsigned int  ms_timeout, NFC_TAGREAD_REQ_S * pTagReadReq, NFC_TAGREAD_CNF_S * pTagReadCnf);
META_RESULT  __stdcall SP_META_NFC_TagWrite(unsigned int  ms_timeout, NFC_TAGWRITE_REQ_S * pTagWriteReq, NFC_TAGWRITE_CNF_S * pTagWriteCnf);
META_RESULT  __stdcall SP_META_NFC_TagWrite_r(const int meta_handle, unsigned int  ms_timeout, NFC_TAGWRITE_REQ_S * pTagWriteReq, NFC_TAGWRITE_CNF_S * pTagWriteCnf);
META_RESULT  __stdcall SP_META_NFC_TagDisconnect(unsigned int  ms_timeout, NFC_TAGDISCONNECT_REQ_S * pDisReq,NFC_TAGDISCONNECT_CNF_S * pDisCnf);
META_RESULT  __stdcall SP_META_NFC_TagDisconnect_r(const int meta_handle, unsigned int  ms_timeout, NFC_TAGDISCONNECT_REQ_S * pDisReq,NFC_TAGDISCONNECT_CNF_S * pDisCnf);
META_RESULT  __stdcall SP_META_NFC_TagFormatNDEF(unsigned int  ms_timeout, NFC_TAGFORMAT2NDEF_REQ_S * pFormatReq, NFC_TAGFORMAT2NDEF_CNF_S * pFormatCnf);
META_RESULT  __stdcall SP_META_NFC_TagFormatNDEF_r(const int meta_handle, unsigned int  ms_timeout, NFC_TAGFORMAT2NDEF_REQ_S * pFormatReq, NFC_TAGFORMAT2NDEF_CNF_S * pFormatCnf);
META_RESULT  __stdcall SP_META_NFC_TagRawComm(unsigned int  ms_timeout, NFC_TAGRAWCOMM_REQ_S * pRawReq , NFC_TAGRAWCOMM_CNF_S * pRawCnf);
META_RESULT  __stdcall SP_META_NFC_TagRawComm_r(const int meta_handle, unsigned int  ms_timeout, NFC_TAGRAWCOMM_REQ_S * pRawReq , NFC_TAGRAWCOMM_CNF_S * pRawCnf);
META_RESULT  __stdcall SP_META_NFC_P2PComm(unsigned int  ms_timeout, NFC_P2PCOMM_REQ_S * pP2PReq,NFC_P2PCOMM_CNF_S * pP2PCnf);
META_RESULT  __stdcall SP_META_NFC_P2PComm_r(const int meta_handle, unsigned int  ms_timeout, NFC_P2PCOMM_REQ_S * pP2PReq,NFC_P2PCOMM_CNF_S * pP2PCnf);
META_RESULT  __stdcall SP_META_NFC_RDComm(unsigned int  ms_timeout, NFC_RDCOMM_REQ_S * pRDReq,NFC_RDCOMM_CNF_S * pRDCnf);
META_RESULT  __stdcall SP_META_NFC_RDComm_r(const int meta_handle, unsigned int  ms_timeout, NFC_RDCOMM_REQ_S * pRDReq,NFC_RDCOMM_CNF_S * pRDCnf);
META_RESULT  __stdcall SP_META_NFC_TxAlwaysOn(unsigned int  ms_timeout, NFC_TXALWAYS_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_TxAlwaysOn_r(const int meta_handle, unsigned int  ms_timeout, NFC_TXALWAYS_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_TxAlwaysOnWOACK(unsigned int  ms_timeout, NFC_TXALWAYS_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_TxAlwaysOnWOACK_r(const int meta_handle, unsigned int  ms_timeout, NFC_TXALWAYS_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
//META_RESULT  __stdcall SP_META_NFC_CardEmulationMode(unsigned int  ms_timeout, NFC_CARDEMULATION_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
//META_RESULT  __stdcall SP_META_NFC_CardEmulationMode_r(const int meta_handle, unsigned int  ms_timeout, NFC_CARDEMULATION_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_ReaderModeTest(unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_ReaderModeTest_r(const int meta_handle, unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_P2PModeTest(unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_P2PModeTest_r(const int meta_handle, unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_SWPSelfTest(unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_SWPSelfTest_r(const int meta_handle, unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_AntennaSelfTest(unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_AntennaSelfTest_r(const int meta_handle, unsigned int  ms_timeout, NFC_SCRIPT_REQ_S * pScriptReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_TagUidRW(unsigned int  ms_timeout, NFC_SCRIPTUID_REQ_S * pUidReq, NFC_SCRIPTUID_CNF_S * pUidCnf);
META_RESULT  __stdcall SP_META_NFC_TagUidRW_r(const int meta_handle, unsigned int  ms_timeout, NFC_SCRIPTUID_REQ_S * pUidReq, NFC_SCRIPTUID_CNF_S * pUidCnf);
META_RESULT  __stdcall SP_META_NFC_CardModeTest(unsigned int  ms_timeout, NFC_CARDMODETEST_REQ_S * pCardModeReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_CardModeTest_r(const int meta_handle, unsigned int  ms_timeout, NFC_CARDMODETEST_REQ_S * pCardModeReq, NFC_SCRIPT_CNF_S * pScriptCnf);
META_RESULT  __stdcall SP_META_NFC_Em_Als_Reader_Mode(unsigned int  ms_timeout, NFC_CARDMODETEST_REQ_S * pEmAlsReadermReq, NFC_EM_ALS_READERM_CNF_S * pEmAlsReadermCnf, META_NFC_NOTIFY_CNF nfc_c,int action);
META_RESULT  __stdcall SP_META_NFC_Em_Als_Reader_Mode_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_ALS_READERM_REQ_S * pEmAlsReadermReq, NFC_EM_ALS_READERM_CNF_S * pEmAlsReadermCnf, META_NFC_NOTIFY_CNF nfc_c,int action);
META_RESULT  __stdcall SP_META_NFC_Em_Als_Reader_Mode_OPT_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_ALS_READERM_OPT_REQ_S * pEmAlsReadermOptReq,NFC_EM_ALS_READERM_OPT_CNF_S * pEmAlsReadermOptCnf);
META_RESULT  __stdcall SP_META_NFC_Em_Als_Reader_Mode_OPT(unsigned int  ms_timeout, NFC_EM_ALS_READERM_OPT_REQ_S * pEmAlsReadermOptReq, NFC_EM_ALS_READERM_OPT_CNF_S * pEmAlsReadermOptCnf);
META_RESULT  __stdcall SP_META_NFC_Em_Als_P2P_Mode_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_ALS_P2P_REQ_S * pEmAlsP2PmReq, NFC_EM_ALS_P2P_CNF_S * pEmAlsP2PmCnf, META_NFC_P2P_NOTIRY nfc_cb);
META_RESULT  __stdcall SP_META_NFC_Em_Als_P2P_Mode(unsigned int  ms_timeout, NFC_EM_ALS_P2P_REQ_S * pEmAlsP2PmReq, NFC_EM_ALS_P2P_CNF_S * pEmAlsP2PmCnf, META_NFC_P2P_NOTIRY nfc_cb);
META_RESULT  __stdcall SP_META_NFC_CardMode_SetSE_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_SE_GET_LIST * pCardModeSetSECnf);
META_RESULT  __stdcall SP_META_NFC_CardMode_SetSE(unsigned int  ms_timeout, NFC_EM_SE_GET_LIST * pCardModeSetSECnf);
META_RESULT  __stdcall SP_META_NFC_CardMode_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_ALS_CARDM_REQ_S * pCardModeReq, NFC_EM_ALS_CARDM_CNF_S * pCardModeCnf);
META_RESULT  __stdcall SP_META_NFC_CardMode(unsigned int  ms_timeout,  NFC_EM_ALS_CARDM_REQ_S * pCardModeReq, NFC_EM_ALS_CARDM_CNF_S * pCardModeCnf);
META_RESULT  __stdcall SP_META_NFC_TX_Carrier_Signal_AlsOn_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_TX_CARR_ALS_ON_REQ_S * pTxCarrierAlsOnReq, NFC_EM_TX_CARR_ALS_ON_CNF_S * pTxCarrierAlsOnCnf);
META_RESULT  __stdcall SP_META_NFC_TX_Carrier_Signal_AlsOn(unsigned int  ms_timeout,  NFC_EM_TX_CARR_ALS_ON_REQ_S * pTxCarrierAlsOnReq, NFC_EM_TX_CARR_ALS_ON_CNF_S * pTxCarrierAlsOnCnf);
META_RESULT  __stdcall SP_META_NFC_Virtural_Card_Func_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_VIRTUAL_CARD_REQ_S * pVirtualCardFuncReq, NFC_EM_VIRTUAL_CARD_CNF_S * pVirtualCardFuncCnf);
META_RESULT  __stdcall SP_META_NFC_Virtural_Card_Func(unsigned int  ms_timeout,  NFC_EM_VIRTUAL_CARD_REQ_S * pVirtualCardFuncReq, NFC_EM_VIRTUAL_CARD_CNF_S * pVirtualCardFuncCnf);
META_RESULT  __stdcall SP_META_NFC_PNFC_COMMAND_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_PNFC_REQ_S * pPNFCCommandReq, NFC_EM_PNFC_CNF_S * pPNFCCommandCnf);
META_RESULT  __stdcall SP_META_NFC_PNFC_COMMAND(unsigned int  ms_timeout,  NFC_EM_PNFC_REQ_S * pPNFCCommandReq, NFC_EM_PNFC_CNF_S * pPNFCCommandCnf);
META_RESULT  __stdcall SP_META_NFC_VERSION_QUERY_r(const int meta_handle, unsigned int  ms_timeout, NFC_SW_VERSION_CNF_S * pVersionQueryCnf);
META_RESULT  __stdcall SP_META_NFC_VERSION_QUERY(unsigned int  ms_timeout, NFC_SW_VERSION_CNF_S * pVersionQueryCnf);
META_RESULT  __stdcall SP_META_NFC_Option_r(const int meta_handle, unsigned int  ms_timeout, NFC_TEST_MODE_SETTING_REQ_S * pOptionSettingReq, NFC_TEST_MODE_SETTING_CNF_S * pOptionSettingCnf);
META_RESULT  __stdcall SP_META_NFC_Option(unsigned int  ms_timeout,  NFC_TEST_MODE_SETTING_REQ_S * pOptionSettingReq, NFC_TEST_MODE_SETTING_CNF_S * pOptionSettingCnf);
META_RESULT  __stdcall SP_META_NFC_Loopback_Test_r(const int meta_handle, unsigned int  ms_timeout, NFC_LOOPBACK_TEST_REQ_S * pLoopbackTestReq, NFC_LOOPBACK_TEST_CNF_S * pLoopbackTestCnf);
META_RESULT  __stdcall SP_META_NFC_Loopback_Test(unsigned int  ms_timeout,  NFC_LOOPBACK_TEST_REQ_S * pLoopbackTestReq, NFC_LOOPBACK_TEST_CNF_S * pLoopbackTestCnf);
META_RESULT  __stdcall SP_META_NFC_SWP_Test_r(const int meta_handle, unsigned int  ms_timeout, NFC_FM_SWP_TEST_REQ_S * pSWPTestReq, NFC_FM_SWP_TEST_CNF_S * pSWPTestCnf);
META_RESULT  __stdcall SP_META_NFC_SWP_Test(unsigned int  ms_timeout,  NFC_FM_SWP_TEST_REQ_S * pSWPTestReq, NFC_FM_SWP_TEST_CNF_S * pSWPTestCnf);
META_RESULT  __stdcall SP_META_NFC_PollingLoopMode_r(const int meta_handle, unsigned int  ms_timeout, NFC_EM_POLLING_REQ_S * pPollingLoopModeReq, NFC_EM_POLLING_CNF_S * pPollingLoopModeCnf,META_NFC_POOLINGLOOP_NOTIFY poolingloopcb);
META_RESULT  __stdcall SP_META_NFC_PollingLoopMode(unsigned int  ms_timeout, NFC_EM_POLLING_REQ_S * pPollingLoopModeReq, NFC_EM_POLLING_CNF_S * pPollingLoopModeCnf, META_NFC_POOLINGLOOP_NOTIFY poolingloopcb);
META_RESULT  __stdcall SP_META_NFC_HW_Version_Test_r(const int meta_handle, unsigned int  ms_timeout, NFC_META_CHIP_VER_CNF_S * pHWVerTestCnf);
META_RESULT  __stdcall SP_META_NFC_HW_Version_Test(unsigned int  ms_timeout, NFC_META_CHIP_VER_CNF_S * pHWVerTestCnf);


//------------------------------------------------------------------------------
// Capture Related Functions                                                    
//------------------------------------------------------------------------------

typedef enum {
    BAYER_PTN_GR = 0,
    BAYER_PTN_R,
    BAYER_PTN_B,
    BAYER_PTN_GB
} CAMERA_BAYER_PATTERN;




META_RESULT __stdcall SP_META_CCT_PreviewOnLCD_Ex(bool bEnablePreview);
META_RESULT __stdcall SP_META_CCT_PreviewOnLCD_Ex_r(const int meta_handle, bool bEnablePreview);
META_RESULT __stdcall SP_META_CCT_SubPreviewOnLCD(bool bEnablePreview);
META_RESULT __stdcall SP_META_CCT_SubPreviewOnLCD_r(const int meta_handle, bool bEnablePreview);
META_RESULT __stdcall SP_META_CCT_PhotoFlashControl(void);
META_RESULT __stdcall SP_META_CCT_PhotoFlashControl_r(const int meta_handle);




// 2011-11-10 Wei Fang add


META_RESULT __stdcall SP_META_GetDynamicUSBComPortExWithFilter(unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop, char *info, int length, char *valid_usb_info);
META_RESULT __stdcall SP_META_GetDynamicUSBComPortExWithFilter_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short *com_port, int *p_scanstop, char *info, int length, char *valid_usb_info);


// EMMC Module



typedef struct
{       
    unsigned char   status;   // The operation whether success , 1 means success
} EMMC_CLEAR_CNF_S;

typedef struct
{       
    unsigned char   sign;   // No means
} EMMC_CLEAR_REQ_S;

typedef struct
{
    unsigned char   sign;   // No means
} EMMC_FORMAT_TCARD_REQ_S;

typedef struct
{
    unsigned char   sign;   // No means
} EMMC_UNMOUNT_REQ_S;

typedef struct
{       
    unsigned char   status;   // The operation whether success , 1 means success
} EMMC_FORMAT_TCARD_CNF_S;

typedef struct 
{       
    unsigned char   status;   // The operation whether success , 1 means success
}EMMC_CLEAR_WITHOUT_TCARD_CNF_S;

typedef struct 
{
    unsigned char   sign;   // No means
}EMMC_CLEAR_WITHOUT_TCARD_REQ_S;

typedef struct 
{       
    unsigned char   status;   // The operation whether success , 1 means success
}EMMC_UNMOUNT_CNF_S;

typedef enum {
    FT_SHUTDOWN_OP_POWEROFF = 0,
    FT_SHUTDOWN_OP_REBOOT,
    FT_SHUTDOWN_OP_ATMDISCONNECT,
    FT_SHUTDOWN_OP_WAITUSB,
    FT_SHUTDOWN_OP_END = 0x0fffffff
} FT_SHUTDOWN_OP;


META_RESULT __stdcall SP_META_ClearValue_r(const int meta_handle, unsigned int  ms_timeout, EMMC_CLEAR_CNF_S *pCnf);
META_RESULT __stdcall SP_META_ClearValue(unsigned int  ms_timeout, EMMC_CLEAR_CNF_S *pCnf);

META_RESULT __stdcall SP_META_EMMC_FormatTCard_r(const int meta_handle, unsigned int  ms_timeout, EMMC_FORMAT_TCARD_CNF_S *pCnf);
META_RESULT __stdcall SP_META_EMMC_FormatTCard(unsigned int  ms_timeout, EMMC_FORMAT_TCARD_CNF_S *pCnf);

META_RESULT __stdcall SP_META_ClearValue_WithoutTCard_r(const int meta_handle, unsigned int  ms_timeout, EMMC_CLEAR_WITHOUT_TCARD_CNF_S *pCnf);
META_RESULT __stdcall SP_META_ClearValue_WithoutTCard(unsigned int  ms_timeout, EMMC_CLEAR_WITHOUT_TCARD_CNF_S *pCnf);

META_RESULT __stdcall SP_META_ClearValueEx_r(const int meta_handle, unsigned int  ms_timeout, EMMC_CLEAR_CNF_S *pCnf);
META_RESULT __stdcall SP_META_ClearValueEx(unsigned int  ms_timeout, EMMC_CLEAR_CNF_S *pCnf);

META_RESULT __stdcall SP_META_ClearValue_WithoutTCardEx_r(const int meta_handle, unsigned int  ms_timeout, EMMC_CLEAR_WITHOUT_TCARD_CNF_S *pCnf);
META_RESULT __stdcall SP_META_ClearValue_WithoutTCardEx(unsigned int  ms_timeout, EMMC_CLEAR_WITHOUT_TCARD_CNF_S *pCnf);

META_RESULT  __stdcall SP_META_Unmount_Data_r(const int meta_handle, unsigned int  ms_timeout, EMMC_UNMOUNT_CNF_S *pCnf);
META_RESULT  __stdcall SP_META_Unmount_Data(unsigned int  ms_timeout, EMMC_UNMOUNT_CNF_S *pCnf);


// unmount data and disconnect meta
META_RESULT  __stdcall SP_META_DisconnectWithTarget_Ex_r(const int meta_handle, EMMC_UNMOUNT_CNF_S *pCnf);
META_RESULT  __stdcall SP_META_Disconneted(const int meta_handle, const int mode);
// ENCRYPTED

typedef struct
{       
    unsigned char  sign;   // No means
} CRYPTFS_QUERYSUPPORT_REQ;

typedef struct
{       
    unsigned char   support;    // 1 means support; 0 means unsupport
} CRYPTFS_QUERYSUPPORT_CNF;

typedef struct
{
   unsigned char pwd[32];
   int  length;
} CRYPTFS_VERITIF_REQ;

typedef struct
{       
    unsigned char match_result;   // 1 means match, 0 means unmatch
} CRYPTFS_VERITIF_CNF;


typedef struct
{       
    unsigned char cfg;   // 0 means to disable 'default encryption', 1 means to enable 'default encryption'
} CRYPTFS_SET_CFG_REQ;

typedef struct
{       
    unsigned char set_cfg_result; // 1 means to set cfg successfully, 0 means that failed to set cfg 
} CRYPTFS_SET_CFG_CNF;


typedef struct
{       
    unsigned char  sign;   // No means
} CRYPTFS_GET_CFG_REQ;

typedef struct
{   
    unsigned char get_cfg_result;    //0 means to disable 'default encryption', 
                                     //1 means to enable 'default encryption', 
                                     //'F' means failure that no such cfg or something wrong
} CRYPTFS_GET_CFG_CNF;


META_RESULT __stdcall SP_META_ENCRYPTED_Support(unsigned int  ms_timeout, CRYPTFS_QUERYSUPPORT_CNF *pCnf);
META_RESULT __stdcall SP_META_ENCRYPTED_Support_r(const int meta_handle, unsigned int  ms_timeout, CRYPTFS_QUERYSUPPORT_CNF *pCnf);


META_RESULT __stdcall SP_META_ENCRYPTED_VertifyPwd_r(const int meta_handle, unsigned int  ms_timeout, CRYPTFS_VERITIF_REQ *pReq ,CRYPTFS_VERITIF_CNF *pCnf);
META_RESULT __stdcall SP_META_ENCRYPTED_VertifyPwd(unsigned int  ms_timeout, CRYPTFS_VERITIF_REQ *pReq ,CRYPTFS_VERITIF_CNF *pCnf);

META_RESULT __stdcall SP_META_ENCRYPTED_SetConfig_r(const int meta_handle, unsigned int  ms_timeout, CRYPTFS_SET_CFG_REQ *pReq ,CRYPTFS_SET_CFG_CNF *pCnf);
META_RESULT __stdcall SP_META_ENCRYPTED_SetConfig(unsigned int  ms_timeout, CRYPTFS_SET_CFG_REQ *pReq ,CRYPTFS_SET_CFG_CNF *pCnf);

META_RESULT __stdcall SP_META_ENCRYPTED_GetConfig_r(const int meta_handle, unsigned int  ms_timeout, CRYPTFS_GET_CFG_CNF *pCnf);
META_RESULT __stdcall SP_META_ENCRYPTED_GetConfig(unsigned int  ms_timeout, CRYPTFS_GET_CFG_CNF *pCnf);



//MODEM(DFO)
typedef struct 
{
    unsigned char reserved;   //just reserved
} MODEM_QUERY_INFO_REQ;

typedef struct 
{
    unsigned int modem_number;
    unsigned int modem_id;
} MODEM_QUERY_INFO_CNF;

META_RESULT __stdcall SP_META_MODEM_Query_Info(unsigned int  ms_timeout, MODEM_QUERY_INFO_REQ *pReq, MODEM_QUERY_INFO_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Query_Info_r(const int meta_handle, unsigned int  ms_timeout, MODEM_QUERY_INFO_REQ *pReq, MODEM_QUERY_INFO_CNF *pCnf);


typedef struct 
{
    unsigned char reserved;   //just reserved
} MODEM_CAPABILITY_LIST_REQ;

typedef enum 
{
    FT_MODEM_SRV_INVALID = 0,
    FT_MODEM_SRV_TST = 1,
    FT_MODEM_SRV_DHL = 2,
    FT_MODEM_SRV_C2K = 3,
    FT_MODEM_SRV_END = 0x0fffffff
}FT_MODEM_SRV;

typedef enum 
{
    FT_MODEM_CH_NATIVE_INVALID = 0,
    FT_MODEM_CH_NATIVE_TST = 1,
    FT_MODEM_CH_TUNNELING = 2,
    FT_MODEM_CH_TUNNELING_IGNORE_CKSM = 3,
    FT_MODEM_CH_NATIVE_C2K = 4,
    FT_MODEM_CH_END = 0x0fffffff
}FT_MODEM_CH_TYPE;

typedef struct 
{
    unsigned int md_service;
    unsigned int ch_type;
    unsigned char reserved;
}MODEM_CAPABILITY; 

typedef struct
{
    MODEM_CAPABILITY modem_cap[8];
}MODEM_CAPABILITY_LIST_CNF; 


META_RESULT __stdcall SP_META_MODEM_Capability(unsigned int  ms_timeout, MODEM_CAPABILITY_LIST_REQ *pReq, MODEM_CAPABILITY_LIST_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Capability_r(const int meta_handle, unsigned int  ms_timeout, MODEM_CAPABILITY_LIST_REQ *pReq, MODEM_CAPABILITY_LIST_CNF *pCnf);


typedef struct 
{
    unsigned int modem_id;
    unsigned int modem_type;
}MODEM_SET_MODEMTYPE_REQ;

typedef struct 
{
    unsigned char reserved;    
}MODEM_SET_MODEMTYPE_CNF;

META_RESULT __stdcall SP_META_MODEM_Set_ModemType(unsigned int  ms_timeout, MODEM_SET_MODEMTYPE_REQ *pReq,MODEM_SET_MODEMTYPE_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Set_ModemType_r(const int meta_handle, unsigned int  ms_timeout, MODEM_SET_MODEMTYPE_REQ *pReq, MODEM_SET_MODEMTYPE_CNF *pCnf);

typedef struct 
{
    unsigned int modem_id;
}MODEM_GET_CURRENTMODEMTYPE_REQ;

typedef struct 
{
    unsigned int current_modem_type;
}MODEM_GET_CURENTMODEMTYPE_CNF;

META_RESULT __stdcall SP_META_MODEM_Get_CurrentModemType(unsigned int  ms_timeout, MODEM_GET_CURRENTMODEMTYPE_REQ *pReq,MODEM_GET_CURENTMODEMTYPE_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Get_CurrentModemType_r(const int meta_handle, unsigned int  ms_timeout, MODEM_GET_CURRENTMODEMTYPE_REQ *pReq, MODEM_GET_CURENTMODEMTYPE_CNF *pCnf);

typedef struct 
{
    unsigned int modem_id;    
}MODEM_QUERY_MDIMGTYPE_REQ;

typedef struct 
{
    unsigned int mdimg_type[16];
}MODEM_QUERY_MDIMGTYPE_CNF;

META_RESULT __stdcall SP_META_MODEM_Query_MDIMGType(unsigned int  ms_timeout, MODEM_QUERY_MDIMGTYPE_REQ *pReq,MODEM_QUERY_MDIMGTYPE_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Query_MDIMGType_r(const int meta_handle, unsigned int  ms_timeout, MODEM_QUERY_MDIMGTYPE_REQ *pReq, MODEM_QUERY_MDIMGTYPE_CNF *pCnf);


typedef struct 
{
    unsigned char reserved;    
}MODEM_QUERY_DOWNLOAD_STATUS_REQ;


typedef struct 
{
    unsigned int percentage;
    unsigned int status_code;
}MODEM_QUERY_DOWNLOAD_STATUS_CNF;


META_RESULT __stdcall SP_META_MODEM_Query_Download_Status(unsigned int  ms_timeout, MODEM_QUERY_DOWNLOAD_STATUS_REQ *pReq,MODEM_QUERY_DOWNLOAD_STATUS_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Query_Download_Status_r(const int meta_handle, unsigned int  ms_timeout, MODEM_QUERY_DOWNLOAD_STATUS_REQ *pReq,MODEM_QUERY_DOWNLOAD_STATUS_CNF *pCnf);

typedef struct 
{
    unsigned char modem_index;    
    unsigned char reserved;    
}MODEM_TRIGGER_NATIVE_DOWNLOAD_REQ;

typedef struct 
{
    unsigned char reserved;    
}MODEM_TRIGGER_NATIVE_DOWNLOAD_CNF;

META_RESULT __stdcall SP_META_MODEM_TRIGGER_NATIVE_DOWNLOAD(unsigned int ms_timeout, MODEM_TRIGGER_NATIVE_DOWNLOAD_REQ *pReq, MODEM_TRIGGER_NATIVE_DOWNLOAD_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_TRIGGER_NATIVE_DOWNLOAD_r(const int meta_handle, unsigned int ms_timeout,MODEM_TRIGGER_NATIVE_DOWNLOAD_REQ *pReq, MODEM_TRIGGER_NATIVE_DOWNLOAD_CNF *pCnf);

typedef struct
{
    unsigned char modem_index;
    unsigned char mode;//normal=1, meta=2
}MODEM_REBOOT_REQ;

typedef struct 
{
    unsigned int reserved ;
}MODEM_REBOOT_CNF;

META_RESULT __stdcall SP_META_MODEM_Reboot_Modem(unsigned int  ms_timeout, MODEM_REBOOT_REQ *pReq,MODEM_REBOOT_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Reboot_Modem_r(const int meta_handle, unsigned int  ms_timeout, MODEM_REBOOT_REQ *pReq, MODEM_REBOOT_CNF *pCnf);

typedef struct
{
    unsigned char modem_index; //reserved
}MODEM_GET_MODEMMODE_REQ;

typedef struct 
{
    unsigned char mode; //normal=1, meta=2
}MODEM_GET_MODEMMODE_CNF;

META_RESULT __stdcall SP_META_MODEM_Get_ModemMode(unsigned int  ms_timeout, MODEM_GET_MODEMMODE_REQ *pReq,MODEM_GET_MODEMMODE_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Get_ModemMode_r(const int meta_handle, unsigned int  ms_timeout, MODEM_GET_MODEMMODE_REQ *pReq, MODEM_GET_MODEMMODE_CNF *pCnf);

typedef struct
{
    unsigned int modem_id; //reserved, no use
}MODEM_QUERY_MDDBPATH_REQ;

typedef struct 
{
    unsigned char mddb_path[64];
}MODEM_QUERY_MDDBPATH_CNF;

META_RESULT __stdcall SP_META_MODEM_Query_MDDBPath(unsigned int  ms_timeout, MODEM_QUERY_MDDBPATH_REQ *pReq,MODEM_QUERY_MDDBPATH_CNF *pCnf);
META_RESULT __stdcall SP_META_MODEM_Query_MDDBPath_r(const int meta_handle, unsigned int  ms_timeout, MODEM_QUERY_MDDBPATH_REQ *pReq, MODEM_QUERY_MDDBPATH_CNF *pCnf);


typedef struct
{       
    unsigned int action;   //0:disable; 1:enable 
} MODEM_SUPPORT_COMPRESS_REQ;

typedef struct 
{
    unsigned int result;  //0:fail; 1:sucess
} MODEM_SUPPORT_COMPRESS_CNF;

META_RESULT __stdcall SP_META_MODEM_Support_Compress(unsigned int  ms_timeout, MODEM_SUPPORT_COMPRESS_REQ *pReq, MODEM_SUPPORT_COMPRESS_CNF  *pCnf);
META_RESULT __stdcall SP_META_MODEM_Support_Compress_r(const int meta_handle, unsigned int  ms_timeout,  MODEM_SUPPORT_COMPRESS_REQ *pReq, MODEM_SUPPORT_COMPRESS_CNF  *pCnf);

//Set mobile log for meta mode
typedef struct
{
    int reserved;
}SAVE_MOBILE_LOG_REQ;

typedef struct
{
    int drv_status;
}SAVE_MOBILE_LOG_CNF;

META_RESULT __stdcall SP_META_SaveMobileLog(unsigned int ms_timeout,SAVE_MOBILE_LOG_REQ *req, SAVE_MOBILE_LOG_CNF *cnf);
META_RESULT __stdcall SP_META_SaveMobileLog_r(const int meta_handle,unsigned int ms_timeout,SAVE_MOBILE_LOG_REQ *req,SAVE_MOBILE_LOG_CNF *cnf);

//

typedef struct
{
    unsigned int level;
}SET_LOG_LEVEL_REQ;

typedef struct
{
    int reserved;
}SET_LOG_LEVEL_CNF;

META_RESULT __stdcall SP_META_SetLogLevel(unsigned int ms_timeout,SET_LOG_LEVEL_REQ *req, SET_LOG_LEVEL_CNF *cnf);
META_RESULT __stdcall SP_META_SetLogLevel_r(const int meta_handle,unsigned int ms_timeout,SET_LOG_LEVEL_REQ *req,SET_LOG_LEVEL_CNF *cnf);

META_RESULT __stdcall SP_META_SDIOAutoCalibration(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_SDIOAutoCalibration_r(const int meta_handle,unsigned int ms_timeout);

META_RESULT __stdcall SP_META_SDIOCheckCalibration(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_SDIOCheckCalibration_r(const int meta_handle,unsigned int ms_timeout);

META_RESULT __stdcall SP_META_BT_OPEN(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_BT_OPEN_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT __stdcall SP_META_BT_CLOSE(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_BT_CLOSE_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT __stdcall SP_META_WIFI_OPEN(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WIFI_OPEN_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT __stdcall SP_META_WIFI_CLOSE(unsigned int ms_timeout);
META_RESULT __stdcall SP_META_WIFI_CLOSE_r(const int meta_handle, unsigned int ms_timeout);

#define MAX_WIFI_SCRIPT_LENGTH 1024

typedef struct
{
    unsigned char script[MAX_WIFI_SCRIPT_LENGTH];
}WIFI_SCRIPT_REQ;

typedef struct
{
    unsigned char confirm[MAX_WIFI_SCRIPT_LENGTH];
}WIFI_SCRIPT_CNF;

META_RESULT  __stdcall SP_META_WiFi_SendScript(const int meta_handle, unsigned int  ms_timeout, WIFI_SCRIPT_REQ * req,WIFI_SCRIPT_CNF *cnf);
META_RESULT  __stdcall SP_META_WiFi_SendScript_r(const int meta_handle, unsigned int  ms_timeout, WIFI_SCRIPT_REQ * req,WIFI_SCRIPT_CNF *cnf);

// Get Sim Card
META_RESULT __stdcall SP_META_GetSimCardNum(unsigned int ms_timeout, unsigned int *number);
META_RESULT __stdcall SP_META_GetSimCardNum_r(const int meta_handle, unsigned int ms_timeout, unsigned int *number);

typedef struct
{
    unsigned char sd_path[256];
} EXTERNAL_SD_CARD_PATH_CNF;

META_RESULT __stdcall SP_META_GetExternalSDCardPath(unsigned int ms_timeout, EXTERNAL_SD_CARD_PATH_CNF *cnf);
META_RESULT __stdcall SP_META_GetExternalSDCardPath_r(const int meta_handle,unsigned int ms_timeout, EXTERNAL_SD_CARD_PATH_CNF *cnf);

// HDCP
#define HDCP_KEY_ARRAY_NUMBER 287
typedef struct
{
    unsigned char HdcpKeyArray[HDCP_KEY_ARRAY_NUMBER];
} FILE_CUSTOM_HDCP_KEY_STRUCT;

META_RESULT  __stdcall SP_META_NVRAM_Compose_HDCP(const FILE_CUSTOM_HDCP_KEY_STRUCT *param, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_HDCP(FILE_CUSTOM_HDCP_KEY_STRUCT *param, const char *buf, const int buf_len);
// This api is not supported in target side

// BT Module 
META_RESULT  __stdcall SP_META_BT_TxPureTest(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_CNF cb_tx, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_TxPureTest_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_CNF cb_tx, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_RxTestStart(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_RxTestStart_r(const int meta_handle, unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_TxPureTest_V2(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_TxPureTest_V2_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST    *snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_RxTestStart_V2(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_RxTestStart_V2_r(const int meta_handle, unsigned int ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_RxTestEnd(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_RxTestEnd_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);

// This api is not supported in target side

// BT Module 
META_RESULT  __stdcall SP_META_BT_TxPureTest(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_CNF cb_tx, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_TxPureTest_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_CNF cb_tx, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_RxTestStart(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_RxTestStart_r(const int meta_handle, unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_TxPureTest_V2(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST *snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_TxPureTest_V2_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST    *snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void  *cb_arg);
META_RESULT  __stdcall SP_META_BT_RxTestStart_V2(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_RxTestStart_V2_r(const int meta_handle, unsigned int ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall SP_META_BT_RxTestEnd(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_RxTestEnd_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_EnablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_BT_DisablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);

// WIFI Module
META_RESULT  __stdcall SP_META_NVRAM_WiFi_MacAddress_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_MacAddress(const WiFi_MacAddress_S  *mac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_MacAddress(WiFi_MacAddress_S  *mac, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_DacDcOffset_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_DacDcOffset(const WiFi_DAC_DC_Offset_S  *dac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_DacDcOffset(WiFi_DAC_DC_Offset_S  *dac, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_TxPower2400M_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_TxPower2400M(const WiFi_TxPower_2400M_S  *txpwr, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_TxPower2400M(WiFi_TxPower_2400M_S  *txpwr, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_TxPower5000M_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_TxPower5000M(const WiFi_TxPower_5000M_S  *txpwr, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_TxPower5000M(WiFi_TxPower_5000M_S  *txpwr, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_ALC_2400M(const WiFi_ALC_2400M_S  *alc, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_ALC_2400M(WiFi_ALC_2400M_S  *alc, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_ALC_2400M_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_TxALC2400M_Len(int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_TxALC2400M(const WiFi_TxALC_2400M_S  *txalc, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_TxALC2400M(WiFi_TxALC_2400M_S  *txalc, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_WiFi_Stop(unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_Stop_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall SP_META_WiFi_ContTx(unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_ContTx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_LocalFrequencyMeasure(unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_LocalFrequencyMeasure_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_CarrierSuppressionMeasure(unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_CarrierSuppressionMeasure_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_ContPktTx(unsigned int  ms_timeout, const WiFi_TestPktTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_ContPktTx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktTx_S *req);
META_RESULT  __stdcall SP_META_WiFi_ContPktTx_Ex(unsigned int  ms_timeout, const WiFi_TestPktTx_Ex_S *req);
META_RESULT  __stdcall SP_META_WiFi_ContPktTx_Ex_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktTx_Ex_S *req);

//-----------------------------------------------------//
//  WiFi Calibration: WNDRV SET Functions              //
//-----------------------------------------------------//

META_RESULT  __stdcall SP_META_WiFi_SetPowerManagementMode(unsigned int  ms_timeout, const WiFi_PowerManagementMode_E  mode);
META_RESULT  __stdcall SP_META_WiFi_SetPowerManagementMode_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_PowerManagementMode_E  mode);
META_RESULT  __stdcall SP_META_WiFi_ContPktRx(unsigned int  ms_timeout, const WiFi_TestPktRx_S *req);
META_RESULT  __stdcall SP_META_WiFi_ContPktRx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktRx_S *req);
META_RESULT  __stdcall SP_META_WiFi_SetRegDomain(unsigned int  ms_timeout, const WiFi_RegDomain_S  *req);
META_RESULT  __stdcall SP_META_WiFi_SetRegDomain_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_RegDomain_S  *req);
META_RESULT  __stdcall SP_META_WiFi_SetDbmToDac(unsigned int  ms_timeout, const WiFi_DBM2DAC_Set_S *req);
META_RESULT  __stdcall SP_META_WiFi_SetDbmToDac_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_DBM2DAC_Set_S *req);
META_RESULT  __stdcall SP_META_WiFi_MACReg32Write(unsigned int  ms_timeout, const WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_MACReg32Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_MACReg16Write(unsigned int  ms_timeout, const WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_MACReg16Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_BBRegWrite(unsigned int  ms_timeout, const WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_BBRegWrite_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_EEPROM_Write(unsigned int  ms_timeout, const WiFi_EEPROM_S *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_EEPROM_Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_EEPROM_S *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_QueryTxStatus(unsigned int  ms_timeout, WiFi_TxStatus_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryTxStatus_r(const int meta_handle, unsigned int  ms_timeout, WiFi_TxStatus_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryTxStatus_Ex(unsigned int  ms_timeout, WiFi_TxStatus_Ex_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryTxStatus_Ex_r(const int meta_handle, unsigned int  ms_timeout, WiFi_TxStatus_Ex_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryRxStatus(unsigned int  ms_timeout, WiFi_RxStatus_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryRxStatus_r(const int meta_handle, unsigned int  ms_timeout, WiFi_RxStatus_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryChannelList(unsigned int  ms_timeout, WiFi_ChannelList_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryChannelList_r(const int meta_handle, unsigned int  ms_timeout, WiFi_ChannelList_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryRxCounter(unsigned int  ms_timeout, WiFi_RxCounter_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryRxCounter_r(const int meta_handle, unsigned int  ms_timeout, WiFi_RxCounter_S *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryDbmToDac(unsigned int  ms_timeout, WiFi_DBM2DAC_Query_S  *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryDbmToDac_r(const int meta_handle, unsigned int  ms_timeout, WiFi_DBM2DAC_Query_S  *cnf);


//-----------------------------------------------------//
//  WiFi Calibration: WNDRV QUERY Functions            //
//-----------------------------------------------------//
META_RESULT  __stdcall SP_META_WiFi_MACReg32Read(unsigned int  ms_timeout, WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_MACReg32Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_MACReg32_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_MACReg16Read(unsigned int  ms_timeout, WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_MACReg16Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_MACReg16_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_BBRegRead(unsigned int  ms_timeout, WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_BBRegRead_r(const int meta_handle, unsigned int  ms_timeout, WiFi_BBReg8_S  *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_EEPROM_Read(unsigned int  ms_timeout, WiFi_EEPROM_S *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_EEPROM_Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_EEPROM_S *array, unsigned int array_cnt);
META_RESULT  __stdcall SP_META_WiFi_DacDcOffsetAutoCalibration(unsigned int  ms_timeout, WiFi_DAC_DC_Offset_S  *cnf);
META_RESULT  __stdcall SP_META_WiFi_DacDcOffsetAutoCalibration_r(const int meta_handle, unsigned int  ms_timeout, WiFi_DAC_DC_Offset_S  *cnf);


//-----------------------------------------------------//
//  WiFi Calibration: Exported Functions               //
//-----------------------------------------------------//
META_RESULT  __stdcall SP_META_WiFi_QueryChipCapability(unsigned int  ms_timeout, WiFi_ChipCapability_S  *cnf);
META_RESULT  __stdcall SP_META_WiFi_QueryChipCapability_r(const int meta_handle, unsigned int  ms_timeout, WiFi_ChipCapability_S  *cnf);
META_RESULT  __stdcall SP_META_WiFi_SetMacAddress(unsigned int  ms_timeout, const WiFi_MacAddress_S  *mac);
META_RESULT  __stdcall SP_META_WiFi_SetMacAddress_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MacAddress_S  *mac);
META_RESULT  __stdcall SP_META_WiFi_SetTxPower2400M(unsigned int  ms_timeout, const WiFi_TxPower_2400M_S  *txpwr);
META_RESULT  __stdcall SP_META_WiFi_SetTxPower2400M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxPower_2400M_S  *txpwr);
META_RESULT  __stdcall SP_META_WiFi_SetTxPower5000M(unsigned int  ms_timeout, const WiFi_TxPower_5000M_S  *txpwr);
META_RESULT  __stdcall SP_META_WiFi_SetTxPower5000M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxPower_5000M_S  *txpwr);
META_RESULT  __stdcall SP_META_WiFi_SetDacDcOffset(unsigned int  ms_timeout, const WiFi_DAC_DC_Offset_S  *dac_dc_offset);
META_RESULT  __stdcall SP_META_WiFi_SetDacDcOffset_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_DAC_DC_Offset_S  *dac_dc_offset);

META_RESULT  __stdcall SP_META_WiFi_SetTxALC2400M(unsigned int  ms_timeout, const WiFi_TxALC_2400M_S  *txalc);
META_RESULT  __stdcall SP_META_WiFi_SetTxALC2400M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxALC_2400M_S  *txalc);


// ADC Cal
META_RESULT  __stdcall SP_META_ADC_GetChannelNum(unsigned int  ms_timeout, unsigned int * pNum);
META_RESULT  __stdcall SP_META_ADC_GetChannelNum_r(const int meta_handle, unsigned int  ms_timeout, unsigned int * pNum);
META_RESULT  __stdcall SP_META_ADC_QueryEfuseCalExist(unsigned int  ms_timeout, unsigned int * pIsExist);
META_RESULT  __stdcall SP_META_ADC_QueryEfuseCalExist_r(const int meta_handle, unsigned int  ms_timeout, unsigned int * pIsExist);


// pVol: battery voltage(mV) 
// pCapacity: battery capacity
META_RESULT  __stdcall SP_META_ADC_GetBatVol(unsigned int  ms_timeout, int * pVol);   
META_RESULT  __stdcall SP_META_ADC_GetBatVol_r(const int meta_handle, unsigned int ms_timeout, int * pVol);
META_RESULT  __stdcall SP_META_ADC_GetBatCapacity(unsigned int  ms_timeout, int * pCapacity);
META_RESULT  __stdcall SP_META_ADC_GetBatCapacity_r(const int meta_handle, unsigned int ms_timeout, int * pCapacity);
META_RESULT  __stdcall SP_META_ADC_GetCurrent(unsigned int  ms_timeout, int * pCurrent);   
META_RESULT  __stdcall SP_META_ADC_GetCurrent_r(const int meta_handle, unsigned int ms_timeout, int * pCurrent);
//

// GPS
META_RESULT  __stdcall SP_META_GPS_Stop(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_GPS_Stop_r(const int meta_handle,unsigned int ms_timeout);


// Base Band Test
/*META_RESULT  __stdcall SP_META_PMIC_RegRead(unsigned int ms_timeout, const WM_CMD_ReadPMICRegister_REQ_T *req, WM_CMD_ReadRegister_CNF_T *cnf) ;
META_RESULT  __stdcall SP_META_PMIC_RegRead_r(const int meta_handle,unsigned int ms_timeout, const WM_CMD_ReadPMICRegister_REQ_T *req, WM_CMD_ReadRegister_CNF_T *cnf);
META_RESULT  __stdcall SP_META_PMIC_RegWrite(unsigned int ms_timeout, const WM_CMD_WritePMICRegister_REQ_T *req, WM_CMD_WriteRegister_CNF_T *cnf) ;
META_RESULT  __stdcall SP_META_PMIC_RegWrite_r(const int meta_handle,unsigned int ms_timeout, const WM_CMD_WritePMICRegister_REQ_T *req, WM_CMD_WriteRegister_CNF_T *cnf);
META_RESULT  __stdcall SP_META_PMIC_RegRead_DWORD(unsigned int ms_timeout, const WM_CMD_ReadPMICRegister_DWORD_REQ_T *req, WM_CMD_ReadRegister_DWORD_CNF_T *cnf) ;
META_RESULT  __stdcall SP_META_PMIC_RegRead_DWORD_r(const int meta_handle,unsigned int ms_timeout, const WM_CMD_ReadPMICRegister_DWORD_REQ_T *req, WM_CMD_ReadRegister_DWORD_CNF_T *cnf);
META_RESULT  __stdcall SP_META_PMIC_RegWrite_DWORD(unsigned int ms_timeout, const WM_CMD_WritePMICRegister_DWORD_REQ_T *req, WM_CMD_WriteRegister_DWORD_CNF_T *cnf) ;
META_RESULT  __stdcall SP_META_PMIC_RegWrite_DWORD_r(const int meta_handle,unsigned int ms_timeout, const WM_CMD_WritePMICRegister_DWORD_REQ_T *req, WM_CMD_WriteRegister_DWORD_CNF_T *cnf);
*/

// Battery
//META_RESULT  __stdcall SP_META_Battery_DownloadImage(unsigned int ms_timeout, const WM_Bat_DLImage_REQ_T *req, WM_Bat_DLImage_CNF_T *cnf, char* fileAddress);
//META_RESULT  __stdcall SP_META_Battery_DownloadImage_r(const int meta_handle,unsigned int ms_timeout, const WM_Bat_DLImage_REQ_T *req, WM_Bat_DLImage_CNF_T *cnf, char* fileAddress);
META_RESULT  __stdcall SP_META_Battery_Read_FW_INFO(unsigned int ms_timeout, const WM_Bat_READ_FW_INFO_REQ_T *req,WM_Bat_READ_FW_INFO_CNF_T *cnf);
META_RESULT  __stdcall SP_META_Battery_Read_FW_INFO_r(const int meta_handle,unsigned int ms_timeout, const WM_Bat_READ_FW_INFO_REQ_T *req,WM_Bat_READ_FW_INFO_CNF_T *cnf);
META_RESULT  __stdcall SP_META_Battery_Read_SOC(unsigned int ms_timeout, const WM_Bat_READ_SOC_REQ_T *req, WM_Bat_READ_SOC_CNF_T *cnf);
META_RESULT  __stdcall SP_META_Battery_Read_SOC_r(const int meta_handle,unsigned int ms_timeout, const WM_Bat_READ_SOC_REQ_T *req, WM_Bat_READ_SOC_CNF_T *cnf);
META_RESULT  __stdcall SP_META_Battery_Write_SOC(unsigned int ms_timeout,const WM_Bat_WRITE_SOC_REQ_T *req, WM_Bat_WRITE_SOC_CNF_T *cnf); 
META_RESULT  __stdcall SP_META_Battery_Write_SOC_r(const int meta_handle,unsigned int ms_timeout, const WM_Bat_WRITE_SOC_REQ_T *req, WM_Bat_WRITE_SOC_CNF_T *cnf);
META_RESULT  __stdcall SP_META_Battery_Update_FW(unsigned int ms_timeout,const WM_Bat_UPImage_REQ_T*req, WM_Bat_UPImage_CNF_T *cnf); 
META_RESULT  __stdcall SP_META_Battery_Update_FW_r(const int meta_handle,unsigned int ms_timeout, const WM_Bat_UPImage_REQ_T *req, WM_Bat_UPImage_CNF_T *cnf);
META_RESULT  __stdcall SP_META_Battery_Enable_IT(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_Battery_Enable_IT_r(int meta_handle, unsigned int ms_timeout);


// ECI
META_RESULT __stdcall SP_META_EciPortTest(unsigned int ms_timeout, unsigned long portIdx);
META_RESULT __stdcall SP_META_EciPortTest_r(int meta_handle, unsigned int ms_timeout, unsigned long portIdx);


// Query 
//META_RESULT  __stdcall SP_META_QueryIfTargetSupportISP(unsigned int ms_timeout);
//META_RESULT  __stdcall SP_META_QueryIfTargetSupportISP_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportAcoustic16level(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportAcoustic16level_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportAudioParam45Tap(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportAudioParam45Tap_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BTPowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_BTPowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportWifiALC(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_QueryIfTargetSupportWifiALC_r(const int meta_handle, unsigned int ms_timeout);


// MD
META_RESULT __stdcall SP_META_SendMDCmd(unsigned int ms_timeout, MD_FRAME *frame/*in & out*/);
META_RESULT __stdcall SP_META_SendMDCmd_r(int meta_handle, unsigned int ms_timeout, MD_FRAME *frame/*in & out*/);

// LED
META_RESULT  __stdcall SP_META_SetLEDLightLevel(unsigned int ms_timeout, KeypadBK_REQ *req);
META_RESULT  __stdcall SP_META_SetLEDLightLevel_r(const int meta_handle, unsigned int ms_timeout, KeypadBK_REQ *req);


// Misc
META_RESULT  __stdcall SP_META_CTI_SendPacketCmd(const unsigned char *pPayLoadBuffer, int nPayloadLength);
META_RESULT  __stdcall SP_META_CTI_SendPacketCmd_r(const int meta_handle, const unsigned char *pPayLoadBuffer, int nPayloadLength);
META_RESULT  __stdcall SP_META_CTI_SetPacketCallback(META_CTI_CallBack  pCBFunc, void* param);
META_RESULT  __stdcall SP_META_CTI_SetPacketCallback_r(const int meta_handle, META_CTI_CallBack  pCBFunc, void* param);

// HW Test Tool Manual test.
META_RESULT  __stdcall SP_META_Audio_GetSupportAfeRegAccess(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_Audio_GetSupportAfeRegAccess_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_Audio_RunAfeRegAccess(unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_Audio_RunAfeRegAccess_r(const int meta_handle, unsigned int ms_timeout);

//-----------------------------------------------------//
//  GAMMA Test              //
//-----------------------------------------------------//
typedef struct {
    unsigned char aalink;
    unsigned char aal;
    unsigned char color;
    unsigned char gamma;
    unsigned char ccorr;
} PQ_ONOFF_CONTROL;

META_RESULT __stdcall SP_META_GAMMA_PQ_ONOFF(unsigned int ms_timeout,PQ_ONOFF_CONTROL *req);
META_RESULT __stdcall SP_META_GAMMA_PQ_ONOFF_r(const int meta_handle, unsigned int ms_timeout,PQ_ONOFF_CONTROL *req);


typedef struct {
    unsigned int r;
    unsigned int g;
    unsigned int b;
} INK_RGB_PATTERN;

META_RESULT __stdcall SP_META_GAMMA_SET_DISP_PATTERN(unsigned int ms_timeout,INK_RGB_PATTERN *req);
META_RESULT __stdcall SP_META_GAMMA_SET_DISP_PATTERN_r(const int meta_handle,unsigned int ms_timeout,INK_RGB_PATTERN *req);

typedef struct {
    unsigned int size;
} LUT_SIZE;

META_RESULT __stdcall SP_META_GAMMA_SET_LUT_SIZE(unsigned int ms_timeout,LUT_SIZE *req);
META_RESULT __stdcall SP_META_GAMMA_SET_LUT_SIZE_r(const int meta_handle,unsigned int ms_timeout,LUT_SIZE *req);

#define GAMMA_TABLE_MAX 1024

typedef struct {
    unsigned int rgbindex;
    unsigned short gamma_table[GAMMA_TABLE_MAX];
} LUT_RGB_VALUE;


META_RESULT __stdcall SP_META_GAMMA_WRITE_LUT(unsigned int ms_timeout, LUT_RGB_VALUE *req);
META_RESULT __stdcall SP_META_GAMMA_WRITE_LUT_r(const int meta_handle,unsigned int ms_timeout, LUT_RGB_VALUE *req);

typedef struct {
    unsigned int save_index;
} LUT_SAVE_INDEX;

META_RESULT __stdcall SP_META_GAMMA_WRITE_LUT_FINISH(unsigned int ms_timeout, LUT_SAVE_INDEX *req);
META_RESULT __stdcall SP_META_GAMMA_WRITE_LUT_FINISH_r(const int meta_handle,unsigned int ms_timeout, LUT_SAVE_INDEX *req);

typedef struct{
    unsigned int checksum;
}GAMMA_STATUS_RETURN_CHECKSUM;

META_RESULT __stdcall SP_META_GAMMA_READ_CHECKSUM(unsigned int ms_timeout,GAMMA_STATUS_RETURN_CHECKSUM *cnf);
META_RESULT __stdcall SP_META_GAMMA_READ_CHECKSUM_r(const int meta_handle,unsigned int ms_timeout,GAMMA_STATUS_RETURN_CHECKSUM *cnf);

typedef struct {
    unsigned int gain_index;
    unsigned int r;
    unsigned int g;
    unsigned int b;
} GAIN_RGB_VALUE;

META_RESULT __stdcall SP_META_GAMMA_WRITE_GAIN(unsigned int ms_timeout,GAIN_RGB_VALUE *req); 
META_RESULT __stdcall SP_META_GAMMA_WRITE_GAIN_r(const int meta_handle,unsigned int ms_timeout,GAIN_RGB_VALUE *req); 



//DRM Key Install
typedef struct 
{
    unsigned int result;
} DRMKEY_INSTALL_SET_CNF;

typedef struct
{
    unsigned int req;  // unused
} DRMKEY_INSTALL_QUERY_REQ;

typedef struct
{
    unsigned int  keycount;
    unsigned int  keytype[512];
} DRMKEY_INSTALL_QUERY_CNF;

typedef struct
{
       unsigned int  keylength;
    unsigned char content[128];
} DRMKEY_WRITE_MCID_REQ;

typedef struct 
{
    unsigned int result;
} DRMKEY_WRITE_MCID_CNF;

typedef struct
{
    unsigned int req;  // unused
} DRMKEY_READ_MCID_REQ;

typedef struct 
{
    unsigned int  keylength;
    unsigned char content[128];
} DRMKEY_READ_MCID_CNF;
META_RESULT __stdcall SP_META_DRMKey_Install_Set(unsigned int  ms_timeout, const char *file, DRMKEY_INSTALL_SET_CNF *pCnf);
META_RESULT __stdcall SP_META_DRMKey_Install_Set_r(const int meta_handle, unsigned int  ms_timeout, const char *file, DRMKEY_INSTALL_SET_CNF *pCnf);


META_RESULT __stdcall SP_META_DRMKey_Install_Query(unsigned int  ms_timeout, DRMKEY_INSTALL_QUERY_REQ *pReq, DRMKEY_INSTALL_QUERY_CNF *pCnf);
META_RESULT __stdcall SP_META_DRMKey_Install_Query_r(const int meta_handle, unsigned int  ms_timeout, DRMKEY_INSTALL_QUERY_REQ *pReq, DRMKEY_INSTALL_QUERY_CNF *pCnf);

META_RESULT __stdcall SP_META_DRMKey_Write_MCID(unsigned int  ms_timeout, DRMKEY_WRITE_MCID_REQ *pReq, DRMKEY_WRITE_MCID_CNF *pCnf);
META_RESULT __stdcall SP_META_DRMKey_Write_MCID_r(const int meta_handle, unsigned int  ms_timeout, DRMKEY_WRITE_MCID_REQ *pReq, DRMKEY_WRITE_MCID_CNF *pCnf);

META_RESULT __stdcall SP_META_DRMKey_Read_MCID(unsigned int  ms_timeout, DRMKEY_READ_MCID_REQ *pReq, DRMKEY_READ_MCID_CNF *pCnf);
META_RESULT __stdcall SP_META_DRMKey_Read_MCID_r(const int meta_handle, unsigned int  ms_timeout, DRMKEY_READ_MCID_REQ *pReq, DRMKEY_READ_MCID_CNF *pCnf);

//Attestation key

// REQ
typedef struct
{
    unsigned int    file_size;
    unsigned char   stage;
} ATTESTATIONKEY_INSTALL_SET_REQ;

typedef struct 
{
    unsigned int result;
} ATTESTATIONKEY_INSTALL_SET_CNF;

META_RESULT __stdcall SP_META_AttestationKey_Install_Set(unsigned int  ms_timeout, const char *file, ATTESTATIONKEY_INSTALL_SET_CNF *pCnf);
META_RESULT __stdcall SP_META_AttestationKey_Install_Set_r(const int meta_handle, unsigned int  ms_timeout, const char *file, ATTESTATIONKEY_INSTALL_SET_CNF *pCnf);


//HDCP
typedef struct 
{
    unsigned int install_result;   //0 means success, 1 means fail
} HDCP_INSTALL_CNF;

META_RESULT __stdcall SP_META_HDCP_Install(unsigned int  ms_timeout, const char *file, const char *cek_file, HDCP_INSTALL_CNF *pCnf);
META_RESULT __stdcall SP_META_HDCP_Install_r(const int meta_handle, unsigned int  ms_timeout, const char *file, const char *cek_file, HDCP_INSTALL_CNF *pCnf);
//-------------END---------------

//special test
typedef struct
{
    int  reserved;  //no use
}SPECIALTEST_HUGEDATA_REQ;

typedef struct
{
    unsigned char result;
}SPECIALTEST_HUGEDATA_CNF;


META_RESULT  __stdcall SP_META_SpecialTest_HugeData(unsigned int ms_timeout, unsigned int datasize);
META_RESULT  __stdcall SP_META_SpecialTest_HugeData_r(const int meta_handle, unsigned int ms_timeout, unsigned int datasize);

META_RESULT  __stdcall SP_META_SpecialTest_RawData(unsigned int ms_timeout, unsigned char *dest, unsigned char *src, unsigned int datasize);
META_RESULT  __stdcall SP_META_SpecialTest_RawData_r(const int meta_handle, unsigned int ms_timeout, unsigned char *dest, unsigned char *src, unsigned int datasize);


//-----------------------------------------------------//
//  Switch SIM Functions                               //
//-----------------------------------------------------//

typedef struct
{
    unsigned int reserved;
}SIM_QUERY_MDTYPE_REQ;

typedef struct
{
    unsigned int md_type;
}SIM_QUERY_MDTYPE_CNF;

typedef struct
{
    unsigned int reserved;
}SIM_QUERY_PRJTYPE_REQ;

typedef struct
{
    unsigned int prj_type;
}SIM_QUERY_PRJTYPE_CNF;

typedef struct
{
    unsigned int reserved;
}SIM_QUERY_MDIDXSET_REQ;

typedef struct
{
    unsigned int md_idxset;
}SIM_QUERY_MDIDXSET_CNF;

typedef struct
{
    unsigned int mode_cmd;
}SIM_SET_SWITCHER_REQ;

typedef struct
{
    unsigned int reserved;
}SIM_SET_SWITCHER_CNF;

typedef struct
{
    unsigned int reserved;
}SIM_QUERY_SSW_REQ;

typedef struct
{
    unsigned int ssw_val;
}SIM_QUERY_SSW_CNF;


META_RESULT __stdcall SP_META_SIM_Check_ExtMd_r(const int meta_handle, unsigned int  ms_timeout, SIM_QUERY_MDTYPE_REQ *pReq ,SIM_QUERY_MDTYPE_CNF *pCnf);
META_RESULT __stdcall SP_META_SIM_Check_ExtMd(unsigned int  ms_timeout, SIM_QUERY_MDTYPE_REQ *pReq ,SIM_QUERY_MDTYPE_CNF *pCnf);

META_RESULT __stdcall SP_META_SIM_Query_PrjType_r(const int meta_handle, unsigned int  ms_timeout, SIM_QUERY_PRJTYPE_REQ *pReq ,SIM_QUERY_PRJTYPE_CNF *pCnf);
META_RESULT __stdcall SP_META_SIM_Query_PrjType(unsigned int  ms_timeout, SIM_QUERY_PRJTYPE_REQ *pReq ,SIM_QUERY_PRJTYPE_CNF *pCnf);

META_RESULT __stdcall SP_META_SIM_Query_MdIdxSet_r(const int meta_handle, unsigned int  ms_timeout, SIM_QUERY_MDIDXSET_REQ *pReq ,SIM_QUERY_MDIDXSET_CNF *pCnf);
META_RESULT __stdcall SP_META_SIM_Query_MdIdxSet(unsigned int  ms_timeout, SIM_QUERY_MDIDXSET_REQ *pReq ,SIM_QUERY_MDIDXSET_CNF *pCnf);

META_RESULT __stdcall SP_META_SIM_Set_Switcher_r(const int meta_handle, unsigned int  ms_timeout, SIM_SET_SWITCHER_REQ *pReq ,SIM_SET_SWITCHER_CNF *pCnf);
META_RESULT __stdcall SP_META_SIM_Set_Switcher(unsigned int  ms_timeout, SIM_SET_SWITCHER_REQ *pReq ,SIM_SET_SWITCHER_CNF *pCnf);

META_RESULT __stdcall SP_META_SIM_Query_SSW_r(const int meta_handle, unsigned int  ms_timeout, SIM_QUERY_SSW_REQ *pReq ,SIM_QUERY_SSW_CNF *pCnf);
META_RESULT __stdcall SP_META_SIM_Query_SSW(unsigned int  ms_timeout, SIM_QUERY_SSW_REQ *pReq, SIM_QUERY_SSW_CNF *pCnf);

//for mdlogger ctrl
typedef struct
{
    unsigned int mode;     //1: usb, 2:SD
    unsigned int action;   //0: stop, 1: start
}MDLOGGER_SWITCH_MODE_REQ;

typedef struct
{
    unsigned int reserved;
}MDLOGGER_SWITCH_MODE_CNF;

typedef struct
{
    unsigned int reserved;

}MDLOGGER_QUERY_STATUS_REQ;

typedef struct
{
    unsigned int status;  //0: stop 1:logging
}MDLOGGER_QUERY_STATUS_CNF;

typedef struct
{
    unsigned int reserved;

}MDLOGGER_QUERY_LOGPATH_REQ;

typedef struct
{
    unsigned char path[256];
}MDLOGGER_QUERY_LOGPATH_CNF;

META_RESULT __stdcall SP_META_Mdlogger_Switch_Mode_r(const int meta_handle, unsigned int  ms_timeout, MDLOGGER_SWITCH_MODE_REQ *pReq, MDLOGGER_SWITCH_MODE_CNF *pCnf);
META_RESULT __stdcall SP_META_Mdlogger_Switch_Mode(unsigned int  ms_timeout,MDLOGGER_SWITCH_MODE_REQ *pReq, MDLOGGER_SWITCH_MODE_CNF *pCnf);

META_RESULT __stdcall SP_META_Mdlogger_Query_Status_r(const int meta_handle, unsigned int  ms_timeout, MDLOGGER_QUERY_STATUS_CNF *pCnf);
META_RESULT __stdcall SP_META_Mdlogger_Query_status(unsigned int  ms_timeout, MDLOGGER_QUERY_STATUS_CNF *pCnf);

META_RESULT __stdcall SP_META_Mdlogger_Query_NormalLog_Path_r(const int meta_handle, unsigned int ms_timeout, MDLOGGER_QUERY_LOGPATH_CNF *pCnf);
META_RESULT __stdcall SP_META_Mdlogger_Query_NormalLog_Path(unsigned int ms_timeout, MDLOGGER_QUERY_LOGPATH_CNF *pCnf);

META_RESULT __stdcall SP_META_Mdlogger_Query_EELog_Path_r(const int meta_handle, unsigned int ms_timeout, MDLOGGER_QUERY_LOGPATH_CNF *pCnf);
META_RESULT __stdcall SP_META_Mdlogger_Query_EELog_Path(unsigned int ms_timeout, MDLOGGER_QUERY_LOGPATH_CNF *pCnf);


// for mobilelog ctrl
typedef struct
{
    unsigned int mode;     //reserved, in the future maybe->1: usb, 2:SD
    unsigned int action;   //0: stop, 1: start
}MOBILELOG_SWITCH_MODE_REQ;

typedef struct
{
    unsigned int reserved;
}MOBILELOG_SWITCH_MODE_CNF;

typedef struct
{
    unsigned int reserved;

}MOBILELOG_QUERY_LOGPATH_REQ;

typedef struct
{
    unsigned char path[256];
}MOBILELOG_QUERY_LOGPATH_CNF;

typedef struct
{
    unsigned int type;  //0:default filter 1:customization filter
}MDLOGGER_SET_FILTER_REQ;

META_RESULT __stdcall SP_META_Mobilelog_Switch_Mode_r(const int meta_handle, unsigned int  ms_timeout, MOBILELOG_SWITCH_MODE_REQ *pReq, MOBILELOG_SWITCH_MODE_CNF *pCnf);
META_RESULT __stdcall SP_META_Mobilelog_Switch_Mode(unsigned int  ms_timeout,MOBILELOG_SWITCH_MODE_REQ *pReq, MOBILELOG_SWITCH_MODE_CNF *pCnf);

META_RESULT __stdcall SP_META_Mobilelog_Query_Log_Path_r(const int meta_handle, unsigned int ms_timeout, MOBILELOG_QUERY_LOGPATH_CNF *pCnf);
META_RESULT __stdcall SP_META_Mobilelog_Query_Log_Path(unsigned int ms_timeout, MOBILELOG_QUERY_LOGPATH_CNF *pCnf);

META_RESULT __stdcall SP_META_Set_Mdlogger_Filter_r(const int meta_handle, unsigned int  ms_timeout, MDLOGGER_SET_FILTER_REQ *pReq, const char *srcPath);
META_RESULT __stdcall SP_META_Set_Mdlogger_Filter(unsigned int  ms_timeout, MDLOGGER_SET_FILTER_REQ *pReq, const char *srcPath);


typedef struct
{
    unsigned int type;        //0:modemlog 1:mobilelog
    unsigned int action;    //0:stop  1:start
}TARGET_LOG_PULL_REQ;

typedef struct
{
    unsigned int reserved;

}TARGET_LOG_PULL_CNF;

typedef struct
{
    unsigned int type;    //0:modemlog 1:mobilelog 2:modem EE log
}TARGET_LOG_PULL_STATUS_REQ;

typedef struct
{
    unsigned int status;  //0:pulling 1:done
}TARGET_LOG_PULL_STATUS_CNF;

META_RESULT  __stdcall SP_META_Pull_Log_r(const int meta_handle, unsigned int  ms_timeout, TARGET_LOG_PULL_REQ *pReq, TARGET_LOG_PULL_CNF *pCn);
META_RESULT  __stdcall SP_META_Pull_Log(unsigned int  ms_timeout, TARGET_LOG_PULL_REQ *pReq, TARGET_LOG_PULL_CNF *pCn);

META_RESULT  __stdcall SP_META_Query_Log_Pulling_Status_r(const int meta_handle, unsigned int  ms_timeout, TARGET_LOG_PULL_STATUS_REQ *pReq, TARGET_LOG_PULL_STATUS_CNF *pCn);
META_RESULT  __stdcall SP_META_Query_Log_Pulling_Status(unsigned int  ms_timeout, TARGET_LOG_PULL_STATUS_REQ *pReq, TARGET_LOG_PULL_STATUS_CNF *pCn);

//for ADC CAR TUNE Value
META_RESULT  __stdcall SP_META_ADC_SetCarTuneVal_r(const int meta_handle, unsigned int ms_timeout, int val);
META_RESULT  __stdcall SP_META_ADC_SetCarTuneVal(unsigned int ms_timeout, int val);

META_RESULT  __stdcall SP_META_ADC_GetCarTuneVal_r(const int meta_handle, unsigned int ms_timeout, int *val);
META_RESULT  __stdcall SP_META_ADC_GetCarTuneVal(unsigned int ms_timeout, int *val);
//for system env setting
typedef struct
{
    unsigned char name[256];
    unsigned char value[256];
}SYS_ENV_SET_REQ;

typedef struct
{
    unsigned int reserved;
}SYS_ENV_SET_CNF;

typedef struct
{
    unsigned char name[256];
}SYS_ENV_GET_REQ;

typedef struct
{
    unsigned char value[256];
}SYS_ENV_GET_CNF;

META_RESULT  __stdcall SP_META_Sysenv_Set_r(const int meta_handle, unsigned int ms_timeout, SYS_ENV_SET_REQ *pReq, SYS_ENV_SET_CNF *pCnf);
META_RESULT  __stdcall SP_META_Sysenv_Set(unsigned int ms_timeout, SYS_ENV_SET_REQ *pReq, SYS_ENV_SET_CNF *pCnf);

META_RESULT  __stdcall SP_META_Sysenv_Get_r(const int meta_handle, unsigned int ms_timeout, SYS_ENV_GET_REQ *pReq, SYS_ENV_GET_CNF *pCnf);
META_RESULT  __stdcall SP_META_Sysenv_Get(unsigned int ms_timeout, SYS_ENV_GET_REQ *pReq, SYS_ENV_GET_CNF *pCnf);

META_RESULT  __stdcall SP_META_Disable_CCB_Buffer_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall SP_META_Disable_CCB_Buffer(unsigned int ms_timeout);

//for multi-log
META_RESULT  __stdcall SP_META_Open_Multi_Thread_Log(const char* filename, int nThreadID);
META_RESULT  __stdcall SP_META_Close_Multi_Thread_Log(int nThreadID);
META_RESULT  __stdcall SP_META_Set_Multi_Thread_ID(const int meta_handle, int nThreadID);
META_RESULT  __stdcall SP_META_InsertConfirmThreadId(const int meta_handle);
//
//query WCN driver ready
typedef struct
{
    unsigned int result;
}QUERY_WCNDRIVER_READY_CNF;

META_RESULT __stdcall SP_META_Query_WCNDriver_Ready_r(const int meta_handle, unsigned int  ms_timeout, QUERY_WCNDRIVER_READY_CNF *pCnf);
META_RESULT __stdcall SP_META_Query_WCNDriver_Ready(unsigned int  ms_timeout, QUERY_WCNDRIVER_READY_CNF *pCnf);


typedef struct
{
    unsigned char path_name[256];    //folder path
    unsigned char filename_substr[256];  //file name sub string,if set it as "*", we will parse all the file in the folder
}FILE_OPERATION_PARSE_REQ;

typedef struct
{
    unsigned int file_count;        //file count for folder
}FILE_OPERATION_PARSE_CNF;


typedef struct
{
    unsigned int index;             //[0, file_count)
}FILE_OPERATION_GETFILEINFO_REQ;

typedef enum
{
    FT_FILE_TYPE_INVALID = 0,
    FT_FILE_TYPE_FILE = 1,
    FT_FILE_TYPE_FOLDER = 2,
    FT_FILE_TYPE_END = 0x0fffffff
}FT_FILE_TYPE;

typedef struct
{
    unsigned int file_type;
    unsigned int file_size;    //if the file_type is folder, we will return file_size as 0.
    unsigned char file_name[256];
}FT_FILE_INFO;

typedef struct
{
    FT_FILE_INFO file_info;
}FILE_OPERATION_GETFILEINFO_CNF;


META_RESULT __stdcall SP_META_File_Operation_Parse_r(const int meta_handle, unsigned int  ms_timeout, FILE_OPERATION_PARSE_REQ *pReq, FILE_OPERATION_PARSE_CNF *pCnf);
META_RESULT __stdcall SP_META_File_Operation_Parse(unsigned int  ms_timeout, FILE_OPERATION_PARSE_REQ *pReq, FILE_OPERATION_PARSE_CNF *pCnf);

META_RESULT __stdcall SP_META_File_Operation_GetFileInfo_r(const int meta_handle, unsigned int  ms_timeout, FILE_OPERATION_GETFILEINFO_REQ *pReq, FILE_OPERATION_GETFILEINFO_CNF *pCnf);
META_RESULT __stdcall SP_META_File_Operation_GetFileInfo(unsigned int  ms_timeout, FILE_OPERATION_GETFILEINFO_REQ *pReq, FILE_OPERATION_GETFILEINFO_CNF *pCnf);

META_RESULT __stdcall SP_META_File_Operation_SendFile_r(const int meta_handle, unsigned int  ms_timeout, const char *pSourceFileName, const char *pDestFileName);
META_RESULT __stdcall SP_META_File_Operation_SendFile(unsigned int  ms_timeout, const char *pSourceFileName, const char *pDestFileName);

META_RESULT __stdcall SP_META_File_Operation_ReceiveFile_r(const int meta_handle, unsigned int  ms_timeout, const char *pSourceFileName, const char *pDestFileName);
META_RESULT __stdcall SP_META_File_Operation_ReceiveFile_rW(const int meta_handle, unsigned int  ms_timeout, const char *pSourceFileName, const wchar_t *pDestFileName);
META_RESULT __stdcall SP_META_File_Operation_ReceiveFile(unsigned int  ms_timeout, const char *pSourceFileName, const char *pDestFileName);


//
//switch usb/socket connect
typedef struct
{
    unsigned int flag;   //0: wifi to usb,  1: usb to wifi
}SWITCH_WIFI_USB_REQ;

typedef struct
{
    unsigned int result;
}SWITCH_WIFI_USB_CNF;

META_RESULT __stdcall SP_META_Switch_WiFiUSB_r(const int meta_handle, unsigned int  ms_timeout, SWITCH_WIFI_USB_REQ *pReq, SWITCH_WIFI_USB_CNF *pCnf);
META_RESULT __stdcall SP_META_Switch_WiFiUSB(unsigned int  ms_timeout, SWITCH_WIFI_USB_REQ *pReq, SWITCH_WIFI_USB_CNF *pCnf);

//atm
typedef struct
{
    unsigned int flag;
}SET_ATM_FLAG_REQ;

typedef struct
{
    int reserved;
}SET_ATM_FLAG_CNF;


META_RESULT __stdcall SP_META_Set_ATMFlag_r(const int meta_handle, unsigned int  ms_timeout, SET_ATM_FLAG_REQ *pReq, SET_ATM_FLAG_CNF *pCnf);
META_RESULT __stdcall SP_META_Set_ATMFlag(unsigned int  ms_timeout, SET_ATM_FLAG_REQ *pReq, SET_ATM_FLAG_CNF *pCnf);
typedef struct
{
    unsigned int type; //0: ATM flag  1: meta log flag
    unsigned int flag;
}SET_PRODUCT_INFO_REQ;

typedef struct
{
    int    reserved;
}SET_PRODUCT_INFO_CNF;

META_RESULT __stdcall SP_META_Set_ProductInfo_r(const int meta_handle, unsigned int  ms_timeout, SET_PRODUCT_INFO_REQ *pReq, SET_PRODUCT_INFO_CNF *pCnf);
META_RESULT __stdcall SP_META_Set_ProductInfo(unsigned int  ms_timeout, SET_PRODUCT_INFO_REQ *pReq, SET_PRODUCT_INFO_CNF *pCnf);

//sys clock
typedef struct
{
    unsigned int year;
    unsigned int mon;
    unsigned int day;
    unsigned int hour;
    unsigned int min;
    unsigned int sec;
    unsigned int ms;
}SET_TARGET_CLOCK_REQ;

typedef struct
{
    unsigned int reserved;
}SET_TARGET_CLOCK_CNF;

META_RESULT __stdcall SP_META_Set_TargetClock_r(const int meta_handle, unsigned int  ms_timeout, SET_TARGET_CLOCK_REQ *pReq, SET_TARGET_CLOCK_CNF *pCnf);
META_RESULT __stdcall SP_META_Set_TargetClock(unsigned int  ms_timeout, SET_TARGET_CLOCK_REQ *pReq, SET_TARGET_CLOCK_CNF *pCnf);


typedef struct
{
     unsigned char log[256];
}PRINTF_LOG_REQ;

typedef struct
{
    int reserved;
}PRINTF_LOG_CNF;

META_RESULT __stdcall SP_META_Print_CusLog_r(const int meta_handle, unsigned int  ms_timeout, PRINTF_LOG_REQ *pReq, PRINTF_LOG_CNF *pCnf);
META_RESULT __stdcall SP_META_Print_CusLog(unsigned int  ms_timeout, PRINTF_LOG_REQ *pReq, PRINTF_LOG_CNF *pCnf);

//RAT Config

typedef struct
{
    unsigned char optr[64];
}RATCONFIG_READOPTR_CNF;

META_RESULT __stdcall SP_META_RATConfig_ReadOptr_r(const int meta_handle, unsigned int  ms_timeout, RATCONFIG_READOPTR_CNF *pCnf);
META_RESULT __stdcall SP_META_RATConfig_ReadOptr(unsigned int  ms_timeout, RATCONFIG_READOPTR_CNF *pCnf);


typedef struct
{
    unsigned char optrseg[64];
}RATCONFIG_READOPTRSEG_CNF;

META_RESULT __stdcall SP_META_RATConfig_ReadOptrSeg_r(const int meta_handle, unsigned int  ms_timeout, RATCONFIG_READOPTRSEG_CNF *pCnf);
META_RESULT __stdcall SP_META_RATConfig_ReadOptrSeg(unsigned int  ms_timeout, RATCONFIG_READOPTRSEG_CNF *pCnf);


typedef struct
{
    unsigned char rat_value[64];
}RATCONFIG_GETCURRENTRAT_CNF;

META_RESULT __stdcall SP_META_RATConfig_GetCurrentRat_r(const int meta_handle, unsigned int  ms_timeout, RATCONFIG_GETCURRENTRAT_CNF *pCnf);
META_RESULT __stdcall SP_META_RATConfig_GetCurrentRat(unsigned int  ms_timeout, RATCONFIG_GETCURRENTRAT_CNF *pCnf);


typedef struct
{
    unsigned char set_rat_value[64];
}RATCONFIG_SETNEWRAT_REQ;


typedef struct
{
    unsigned int set_result; //0:Fail; 1:Success, need reboot target; 2:Success, no need reboot
}RATCONFIG_SETNEWRAT_CNF;

META_RESULT __stdcall SP_META_RATConfig_SetNewRat_r(const int meta_handle, unsigned int  ms_timeout, RATCONFIG_SETNEWRAT_REQ *pReq, RATCONFIG_SETNEWRAT_CNF *pCnf);
META_RESULT __stdcall SP_META_RATConfig_SetNewRat(unsigned int  ms_timeout, RATCONFIG_SETNEWRAT_REQ *pReq, RATCONFIG_SETNEWRAT_CNF *pCnf);


//Multi-SIM
typedef struct
{
    unsigned char msim_value[16];
} MSIM_GETVALUE_CNF;


META_RESULT __stdcall SP_META_MSIM_GetValue_r(const int meta_handle, unsigned int  ms_timeout, MSIM_GETVALUE_CNF *pCnf);
META_RESULT __stdcall SP_META_MSIM_GetValue(unsigned int ms_timeout, MSIM_GETVALUE_CNF *pCnf);

typedef struct
{
    unsigned char msim_value[16];
} MSIM_SETVALUE_REQ;

typedef struct
{
    unsigned int set_result;
} MSIM_SETVALUE_CNF;

META_RESULT __stdcall SP_META_MSIM_SetValue_r(const int meta_handle, unsigned int  ms_timeout, MSIM_SETVALUE_REQ *pReq, MSIM_SETVALUE_CNF *pCnf);
META_RESULT __stdcall SP_META_MSIM_SetValue(unsigned int ms_timeout, MSIM_SETVALUE_REQ *pReq, MSIM_SETVALUE_CNF *pCnf);

typedef struct
{
    unsigned int reserved; //reserved, no use
} QUERY_APDBPATH_REQ;

typedef struct 
{
    unsigned char apdb_path[128];
} QUERY_APDBPATH_CNF;

META_RESULT __stdcall SP_META_Query_APDBPath(unsigned int ms_timeout, QUERY_APDBPATH_REQ *pReq,QUERY_APDBPATH_CNF *pCnf);
META_RESULT __stdcall SP_META_Query_APDBPath_r(const int meta_handle, unsigned int ms_timeout, QUERY_APDBPATH_REQ *pReq, QUERY_APDBPATH_CNF *pCnf);

typedef enum
{
	CTRL_CLOSE_PORT,
	CTRL_NOT_CLOSE_PORT,
	CTRL_UNMOUNT_CLOSE_PORT,
	CTRL_PC_OP_END = 0x0fffffff
}FT_DISCONN_PC_OP;

typedef enum
{
	FT_CTRL_POWEROFF,
	FT_CTRL_REBOOT,
	FT_CTRL_REBOOT_RECOVERY,
	FT_CTRL_REBOOT_BYDELAY,
	FT_CTRL_DISCONN_ATM,
	FT_CTRL_CHECKUSB_POWEROFF,
	FT_CTRL_DONOTHING,
	FT_CTRL_TARGET_OP_END = 0x0fffffff
}FT_DISCONN_TARGET_OP;

typedef struct
{ 
	FT_DISCONN_PC_OP         op_pc;
    FT_DISCONN_TARGET_OP	 op_target;
	unsigned int	         delay;      //it is valid when target type is FT_CTRL_REBOOT_BYDELAY
	unsigned int			 reserved;
}META_DISCONN_REQ;

typedef struct
{
	unsigned char   unmount_status;	//it is valid when pc type is CTRL_UMOUNT_CLOSE_PORT
	unsigned int	reserved;
}META_DISCONN_CNF;

META_RESULT  __stdcall SP_META_Disconnection_r(const int meta_handle, META_DISCONN_REQ *pReq, META_DISCONN_CNF *pCnf);
META_RESULT  __stdcall SP_META_NVRAM_GetAllLIDNameLength_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_GetAllLIDName_r(const int meta_handle, char *buf, const int buf_len, int *NofLID);
META_RESULT  __stdcall SP_META_NVRAM_GetRecStructNameLength_r(const int meta_handle, const char *LID, int *len);
META_RESULT  __stdcall SP_META_NVRAM_GetRecStructName_r(const int meta_handle, const char *LID, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_GetAllRecFieldNameLength_r(const int meta_handle, const char *LID, int *len);
META_RESULT  __stdcall SP_META_NVRAM_GetAllRecFieldName_r(const int meta_handle, const char *LID, char *buf, const int buf_len, int *NofField);
META_RESULT  __stdcall SP_META_NVRAM_CheckFieldNameExist_r(const int meta_handle, const char *LID, const char *Field, bool *result);
META_RESULT  __stdcall SP_META_NVRAM_GetRecNum_r(const int meta_handle, const char *LID, int *num);
META_RESULT  __stdcall SP_META_NVRAM_GetRecLen_r(const int meta_handle, const char *LID, int *len);
META_RESULT  __stdcall SP_META_NVRAM_SetRecFieldValue_r(const int meta_handle, const char *LID, const char *field, char *buf, const int buf_len, void *value, const int value_len);
META_RESULT  __stdcall SP_META_NVRAM_GetRecFieldValue_r(const int meta_handle, const char *LID, const char *field, const char *buf, const int buf_len,void *value, const int value_len);
META_RESULT  __stdcall SP_META_NVRAM_SetRecFieldBitValue_r(const int meta_handle, const char *LID, const char *field, const char *bitname, char *buf, const int buf_len, const int bitvalue);
META_RESULT  __stdcall SP_META_NVRAM_GetRecFieldBitValue_r(const int meta_handle, const char *LID, const char *field, const char *bitname, const char *buf, const int buf_len, int *bitvalue);
META_RESULT  __stdcall SP_META_NVRAM_QueryIsLIDExist_r(const int meta_handle, const char *LID);
META_RESULT  __stdcall SP_META_NVRAM_agcPathLoss_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_agcPathLoss_r(const int meta_handle, const l1cal_agcPathLoss_T *loss, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_agcPathLoss_r(const int meta_handle, l1cal_agcPathLoss_T *loss, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_rampTable_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_rampTable_r(const int meta_handle, const l1cal_rampTable_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_rampTable_r(const int meta_handle, l1cal_rampTable_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_interRampData_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_interRampData_r(const int meta_handle, const l1cal_interRampData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_interRampData_r(const int meta_handle, l1cal_interRampData_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_crystalAfcData_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_crystalAfcData_r(const int meta_handle, const l1cal_crystalAfcData_T *xo_afc, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_crystalAfcData_r(const int meta_handle, l1cal_crystalAfcData_T *xo_afc, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Calculate_IMEI_CD_r(const int meta_handle, const char *imei, unsigned short *p_cd);
META_RESULT  __stdcall SP_META_NVRAM_IMEISV_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_IMEISV_NoCheck_r(const int meta_handle, const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_IMEISV_r(const int meta_handle, const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_IMEISV_ex_r(const int meta_handle, const IMEISV_struct_T  *p_imeisv, char *buf, const int buf_len,bool DoCheckSum);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_IMEISV_r(const int meta_handle, IMEISV_struct_T  *p_imeisv, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_RFSpecialCoef_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_SKY74045_RFSpecialCoef_r(const int meta_handle, const RF_SKY74045_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_SKY74045_RFSpecialCoef_r(const int meta_handle, RF_SKY74045_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_SKY74117_RFSpecialCoef_r(const int meta_handle, const RF_SKY74117_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_SKY74117_RFSpecialCoef_r(const int meta_handle, RF_SKY74117_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_MT6139B_RFSpecialCoef_r(const int meta_handle, const RF_MT6139B_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_MT6139B_RFSpecialCoef_r(const int meta_handle, RF_MT6139B_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_BRIGHT5P_RFSpecialCoef_r(const int meta_handle, const RF_BRIGHT5P_Coef_T *rf_mod_coef, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_BRIGHT5P_RFSpecialCoef_r(const int meta_handle, RF_BRIGHT5P_Coef_T *rf_mod_coef, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_EPSK_interRampData_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_EPSK_interRampData_r(const int meta_handle, const l1cal_EPSK_interRampData_T *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_EPSK_interRampData_r(const int meta_handle, l1cal_EPSK_interRampData_T *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_MacAddress_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_MacAddress_r(const int meta_handle, const WiFi_MacAddress_S  *mac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_MacAddress_r(const int meta_handle, WiFi_MacAddress_S  *mac, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_TxPower2400M_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_TxPower2400M_r(const int meta_handle, const WiFi_TxPower_2400M_S  *txpwr, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_TxPower2400M_r(const int meta_handle, WiFi_TxPower_2400M_S  *txpwr, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_TxPower5000M_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_TxPower5000M_r(const int meta_handle, const WiFi_TxPower_5000M_S  *txpwr, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_TxPower5000M_r(const int meta_handle, WiFi_TxPower_5000M_S  *txpwr, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_DacDcOffset_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_DacDcOffset_r(const int meta_handle, const WiFi_DAC_DC_Offset_S  *dac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_DacDcOffset_r(const int meta_handle, WiFi_DAC_DC_Offset_S  *dac, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_ALC_2400M_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_ALC_2400M_r(const int meta_handle, const WiFi_ALC_2400M_S  *alc, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_ALC_2400M_r(const int meta_handle, WiFi_ALC_2400M_S  *alc, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_rampTable_Len_Ex_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_rampTable_Ex_r(const int meta_handle, const l1cal_rampTable_T_Ex *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_rampTable_Ex_r(const int meta_handle, l1cal_rampTable_T_Ex *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_rampTable_Len_Ex2_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_rampTable_Ex2_r(const int meta_handle, const l1cal_rampTable_T_Ex2 *tbl, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_rampTable_Ex2_r(const int meta_handle, l1cal_rampTable_T_Ex2 *tbl, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Compose_tempdacData_r(const int meta_handle, const ul1cal_tempdacData_T  *dac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Decompose_tempdacData_r(const int meta_handle, ul1cal_tempdacData_T  *dac, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Compose_pathlossData_r(const int meta_handle, const ul1cal_pathlossData_T  *pathloss, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Decompose_pathlossData_r(const int meta_handle, ul1cal_pathlossData_T  *pathloss, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Compose_txdacData_r(const int meta_handle, const ul1cal_txdacData_T  *txdac, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_3G_Decompose_txdacData_r(const int meta_handle, ul1cal_txdacData_T  *txdac, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_GetLIDVersion_r(const int meta_handle, const char *LID,unsigned short *ver);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_RFMD3500Radio_r(const int meta_handle, const nvram_ef_btradio_rfmd3500_struct  *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_RFMD3500Radio_r(const int meta_handle, nvram_ef_btradio_rfmd3500_struct  *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6601Radio_r(const int meta_handle,const nvram_ef_btradio_mt6601_struct  *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6601Radio_r(const int meta_handle, nvram_ef_btradio_mt6601_struct  *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_TxALC2400M_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Compose_TxALC2400M_r(const int meta_handle, const WiFi_TxALC_2400M_S  *txalc, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_WiFi_Decompose_TxALC2400M_r(const int meta_handle, WiFi_TxALC_2400M_S  *txalc, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_MT6140tx_PaVbias_r(const int meta_handle, const mt6140tx *pavbias, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_MT6140tx_PaVbias_r(const int meta_handle, mt6140tx *pavbias, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BBTXParameters_Len_r(const int meta_handle, int *len);
META_RESULT  __stdcall SP_META_NVRAM_Compose_BBTXParameters_r(const int meta_handle, const BBTXParameters_T *bbtx, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_BBTXParameters_r(const int meta_handle, BBTXParameters_T *bbtx, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6611Radio_r(const int meta_handle, const NVRAM_BTRADIO_MT6611_S *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6611Radio_r(const int meta_handle, NVRAM_BTRADIO_MT6611_S *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6620Radio_r(const int meta_handle, const NVRAM_BTRADIO_MT6620_S *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6620Radio_r(const int meta_handle, NVRAM_BTRADIO_MT6620_S *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Compose_MT6626Radio_r(const int meta_handle, const NVRAM_BTRADIO_MT6626_S *radio, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_Decompose_MT6626Radio_r(const int meta_handle, NVRAM_BTRADIO_MT6626_S *radio, const char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_BT_QueryChipByStructSize_r(const int meta_handle, BT_CHIP_ID_E * chipID);
META_RESULT  __stdcall SP_META_NVRAM_Compose_HDCP_r(const int meta_handle, const FILE_CUSTOM_HDCP_KEY_STRUCT *param, char *buf, const int buf_len);
META_RESULT  __stdcall SP_META_NVRAM_Decompose_HDCP_r(const int meta_handle, FILE_CUSTOM_HDCP_KEY_STRUCT *param, const char *buf, const int buf_len);
////////////////////////////////////////////////////////////////////////////
/*****************For production line tool test flag start*****************/

/////////////////////////////////////////////////////////
/***************From mtk_test_flag.h file***************/
/*
* ****************************************
*                 ATE_Tool
* ****************************************
*/
typedef struct _s_ate_gsm_flag
{
    unsigned char        ate_gsm_flag[4];
} s_ate_gsm_flag;         // 4Bytes

typedef struct _s_ate_tdscdma_flag
{
    unsigned char        ate_tdscdma_flag[2];
} s_ate_tdscdma_flag;    // 2Bytes

typedef struct _s_ate_wcdma_flag
{
    unsigned char        ate_wcdma_flag[2];
} s_ate_wcdma_flag;      // 2Bytes

typedef struct _s_ate_lte_flag
{
    unsigned char        ate_lte_flag[2];
} s_ate_lte_flag;    // 2Bytes

typedef struct _s_ate_cdma_flag
{
    unsigned char        ate_cdma_flag[2];
} s_ate_cdma_flag;      // 2Bytes

typedef struct _s_ate_nsft_flag
{
    unsigned char        ate_nsft_flag[2];
} s_ate_nsft_flag;      // 2Bytes

typedef struct _s_ate_wireless_flag
{
    unsigned char        ate_wireless_flag[2];
} s_ate_wireless_flag;  // 2Bytes

typedef struct s_ate_other_flag
{
    unsigned char        ate_other_flag[1];
} s_ate_other_flag;     // 1Bytes

typedef struct _s_ate_flag
{
    unsigned char                    sw_index;
    unsigned char                    md_index;

    s_ate_gsm_flag            gsm_flag;
    s_ate_tdscdma_flag      tdscdma_flag;
    s_ate_wcdma_flag         wcdma_flag;
    s_ate_lte_flag            lte_flag;
    s_ate_cdma_flag         cdma_flag;
    s_ate_other_flag          other_flag;
    s_ate_nsft_flag          nsft_flag;
    s_ate_wireless_flag     wireless_flag;

    unsigned char                    reserved[3];
} s_ate_flag;       // 22Bytes


/*
* ****************************************
*                 WCN_ATE_Tool
* ****************************************
*/
typedef struct _s_wcn_ate_flag
{
    unsigned char        wcn_ate_flag[4];
} s_wcn_ate_flag;   // 4Bytes

/*
* ****************************************
*                 HW_Test_Tool
* ****************************************
*/
typedef struct _s_hw_test_flag
{
    unsigned char        hw_test_flag[20];
} s_hw_test_flag;               // 20Bytes

/*
* ****************************************
*            ATA_Tool & Factory Mode
* ****************************************
*/
typedef struct _s_factory_mode_flag
{
    unsigned char        ata_flag;
    unsigned char        reserved[20-1];
} s_factory_mode_flag;    // 20Bytes

/*
* ****************************************
*            SN Writer
* ****************************************
*/
typedef struct _s_sn_write_flag
{
    unsigned char        sn_write_flag[2];
} s_sn_write_flag;  // 2Bytes


/*
* ****************************************
*            s_proinfo_test_flag
* ****************************************
*/
typedef struct _s_mtk_test_flag
{
    s_ate_flag            ate_flag[5];    // 110Bytes
    s_wcn_ate_flag        wcn_ate_flag;    // 4Bytes
    s_hw_test_flag        hw_test_flag;    // 20Bytes
    s_factory_mode_flag    factory_mode_flag; // 20Bytes
    s_sn_write_flag     sn_write_flag;  //2Bytes
    unsigned char        reserved[14];
} s_mtk_test_flag;    // 170Bytes
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
/*********From CFG_PRODUCT_INFO_File.h file*************/
// the record structure define of PRODUCT_INFO nvram file
typedef struct
{
    unsigned char   imei[8];
    unsigned char   svn;
    unsigned char   pad;
} nvram_ef_imei_imeisv_struct;

typedef struct
{
    unsigned char   BTAddr[6];
    unsigned char   WifiAddr[6];
    unsigned char   ADBSeriaNo[20];
    unsigned char   revered[32];
} s_target_info_record;

typedef struct
{
    unsigned char  boot_mode;   //0:normal, 1: meta, etc
    unsigned char  com_type;    //0:unknow com, 1:uart, 2:usb
    unsigned char  com_id;      // 0:enable mobile log meta mode, enable adb(composite device)
                                // 1:enable mobile log meta mode, disable adb(single device)
                                // 2:disable mobile log meta mode, enable adb(composite device)
                                // 3:disable mobile log meta mode, disable adb(single device)
} s_mtk_boot_mode_flag;


typedef struct
{
    unsigned char               barcode[64];    // 64B
    nvram_ef_imei_imeisv_struct IMEI[4];        // 40B
    s_target_info_record        target_info;    // 64B
    s_mtk_test_flag             mtk_test_flag;  // 170B
    s_mtk_boot_mode_flag        mtk_boot_mode_flag; //3B
    unsigned char reserved[1024-170-64-40-64-3];
}PRODUCT_INFO;
/////////////////////////////////////////////////////////

//====================== parser log file function====================//
/**
  * \ingroup NoDefYet
  */
bool __stdcall extractLogFile_s(char* orgFile,char* prefix,char *destFilePath);

/*******************For production line tool test flag end*****************/
////////////////////////////////////////////////////////////////////////////


#if defined(__cplusplus)
}
#endif // #if defined(__cplusplus)

#endif // #ifndef META_DLL_H



